; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	e:\X-Project\#2.JX\Source\Sources\Core\Src\Scene\KIpoTree.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	?SetColor@KLColor@@QAEXK@Z			; KLColor::SetColor
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\scenedatadef.h
;	COMDAT ?SetColor@KLColor@@QAEXK@Z
_TEXT	SEGMENT
_dwColor$ = 8						; size = 4
?SetColor@KLColor@@QAEXK@Z PROC				; KLColor::SetColor, COMDAT
; _this$ = ecx

; 373  : 		r = (unsigned short)((dwColor>>16) & 0xff);

	mov	eax, DWORD PTR _dwColor$[esp-4]
	mov	edx, eax
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	mov	WORD PTR [ecx], dx

; 374  : 		g = (unsigned short)((dwColor>>8) & 0xff);

	movzx	dx, ah

; 375  : 		b = (unsigned short)(dwColor & 0xff);

	movzx	eax, al
	mov	WORD PTR [ecx+2], dx
	mov	WORD PTR [ecx+4], ax

; 376  : 	}

	ret	4
?SetColor@KLColor@@QAEXK@Z ENDP				; KLColor::SetColor
_TEXT	ENDS
PUBLIC	?Scale@KLColor@@QAEXM@Z				; KLColor::Scale
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?Scale@KLColor@@QAEXM@Z
_TEXT	SEGMENT
tv184 = -4						; size = 4
tv170 = -4						; size = 4
tv168 = -4						; size = 4
tv161 = -4						; size = 4
tv131 = -4						; size = 4
tv91 = -4						; size = 4
tv84 = -4						; size = 4
tv183 = 8						; size = 2
tv165 = 8						; size = 4
tv164 = 8						; size = 2
tv68 = 8						; size = 4
tv67 = 8						; size = 2
_f$ = 8							; size = 4
?Scale@KLColor@@QAEXM@Z PROC				; KLColor::Scale, COMDAT
; _this$ = ecx

; 378  : 	{

	push	ecx

; 379  : 		r = (int)(r * f);

	movzx	eax, WORD PTR [ecx]
	mov	DWORD PTR tv184[esp+4], eax
	fild	DWORD PTR tv184[esp+4]
	fld	DWORD PTR _f$[esp]
	fnstcw	WORD PTR tv183[esp]
	movzx	eax, WORD PTR tv183[esp]
	fld	ST(0)
	fmulp	ST(2), ST(0)
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv170[esp+4], eax
	fxch	ST(1)

; 380  : 		g = (int)(g * f);

	movzx	eax, WORD PTR [ecx+2]
	fldcw	WORD PTR tv170[esp+4]
	fistp	DWORD PTR tv168[esp+4]
	movzx	edx, WORD PTR tv168[esp+4]
	mov	WORD PTR [ecx], dx
	fldcw	WORD PTR tv183[esp]
	mov	DWORD PTR tv165[esp], eax
	fild	DWORD PTR tv165[esp]
	fnstcw	WORD PTR tv164[esp]
	fmul	ST(0), ST(1)
	movzx	eax, WORD PTR tv164[esp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv161[esp+4], eax

; 381  : 		b = (int)(b * f);

	movzx	eax, WORD PTR [ecx+4]
	fldcw	WORD PTR tv161[esp+4]
	fistp	DWORD PTR tv84[esp+4]
	movzx	edx, WORD PTR tv84[esp+4]
	mov	WORD PTR [ecx+2], dx
	fldcw	WORD PTR tv164[esp]
	mov	DWORD PTR tv68[esp], eax
	fild	DWORD PTR tv68[esp]
	fnstcw	WORD PTR tv67[esp]
	fmulp	ST(1), ST(0)
	movzx	eax, WORD PTR tv67[esp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv131[esp+4], eax
	fldcw	WORD PTR tv131[esp+4]
	fistp	DWORD PTR tv91[esp+4]
	movzx	edx, WORD PTR tv91[esp+4]
	mov	WORD PTR [ecx+4], dx
	fldcw	WORD PTR tv67[esp]

; 382  : 	}

	pop	ecx
	ret	4
?Scale@KLColor@@QAEXM@Z ENDP				; KLColor::Scale
_TEXT	ENDS
PUBLIC	?GetColor@KLColor@@QAEKXZ			; KLColor::GetColor
; Function compile flags: /Ogtpy
;	COMDAT ?GetColor@KLColor@@QAEKXZ
_TEXT	SEGMENT
?GetColor@KLColor@@QAEKXZ PROC				; KLColor::GetColor, COMDAT
; _this$ = ecx

; 385  : 		return 0xff000000 | (r<<16) | (g<<8) | b;

	movzx	eax, WORD PTR [ecx]
	movzx	edx, WORD PTR [ecx+2]
	movzx	ecx, WORD PTR [ecx+4]
	or	eax, -256				; ffffff00H
	shl	eax, 8
	or	eax, edx
	shl	eax, 8
	or	eax, ecx

; 386  : 	}

	ret	0
?GetColor@KLColor@@QAEKXZ ENDP				; KLColor::GetColor
_TEXT	ENDS
PUBLIC	??0_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??0_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 441  : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 442  : 		}

	ret	0
??0_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::_Iterator_base
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 61   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 27   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+20]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 28   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 31   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 32   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 36   : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what
	mov	eax, DWORD PTR [ecx+16]

; 37   : 		}

	ret	0

; 36   : 		return (_Str.c_str());

$LN7@what:
	lea	eax, DWORD PTR [ecx+16]

; 37   : 		}

	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 106  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 107  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 110  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 111  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_fabsf
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 384  :         {return ((float)fabs((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	fabs
	fstp	DWORD PTR tv129[esp-4]
	fld	DWORD PTR tv129[esp-4]
	ret	0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	?fabs@@YAMM@Z					; fabs
; Function compile flags: /Ogtpy
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 510  :         {return (fabsf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	fabs
	fstp	DWORD PTR tv131[esp-4]
	fld	DWORD PTR tv131[esp-4]
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
PUBLIC	??_7KLightBase@@6B@				; KLightBase::`vftable'
PUBLIC	??0KLightBase@@QAE@XZ				; KLightBase::KLightBase
PUBLIC	??_R4KLightBase@@6B@				; KLightBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKLightBase@@@8				; KLightBase `RTTI Type Descriptor'
PUBLIC	??_R3KLightBase@@8				; KLightBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KLightBase@@8				; KLightBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KLightBase@@8			; KLightBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Breath@KLightBase@@UAEXXZ			; KLightBase::Breath
;	COMDAT ??_R1A@?0A@EA@KLightBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@KLightBase@@8 DD FLAT:??_R0?AVKLightBase@@@8 ; KLightBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KLightBase@@8
rdata$r	ENDS
;	COMDAT ??_R2KLightBase@@8
rdata$r	SEGMENT
??_R2KLightBase@@8 DD FLAT:??_R1A@?0A@EA@KLightBase@@8	; KLightBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3KLightBase@@8
rdata$r	SEGMENT
??_R3KLightBase@@8 DD 00H				; KLightBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2KLightBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKLightBase@@@8
_DATA	SEGMENT
??_R0?AVKLightBase@@@8 DD FLAT:??_7type_info@@6B@	; KLightBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKLightBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KLightBase@@6B@
rdata$r	SEGMENT
??_R4KLightBase@@6B@ DD 00H				; KLightBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKLightBase@@@8
	DD	FLAT:??_R3KLightBase@@8
rdata$r	ENDS
;	COMDAT ??_7KLightBase@@6B@
CONST	SEGMENT
??_7KLightBase@@6B@ DD FLAT:??_R4KLightBase@@6B@	; KLightBase::`vftable'
	DD	FLAT:?Breath@KLightBase@@UAEXXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0KLightBase@@QAE@XZ
_TEXT	SEGMENT
??0KLightBase@@QAE@XZ PROC				; KLightBase::KLightBase, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7KLightBase@@6B@
	ret	0
??0KLightBase@@QAE@XZ ENDP				; KLightBase::KLightBase
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.h
_TEXT	ENDS
;	COMDAT ?Breath@KLightBase@@UAEXXZ
_TEXT	SEGMENT
?Breath@KLightBase@@UAEXXZ PROC				; KLightBase::Breath, COMDAT
; _this$ = ecx

; 50   : 	virtual void Breath(){}

	ret	0
?Breath@KLightBase@@UAEXXZ ENDP				; KLightBase::Breath
_TEXT	ENDS
PUBLIC	__real@4f800000
PUBLIC	?Breath@KSelfBreathLight@@UAEXXZ		; KSelfBreathLight::Breath
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4f800000
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Breath@KSelfBreathLight@@UAEXXZ
_TEXT	SEGMENT
tv226 = -8						; size = 4
tv216 = -8						; size = 4
tv240 = -4						; size = 4
?Breath@KSelfBreathLight@@UAEXXZ PROC			; KSelfBreathLight::Breath, COMDAT
; _this$ = ecx

; 31   : {

	sub	esp, 8
	push	esi
	push	edi
	mov	esi, ecx

; 32   : 	DWORD dwCurTime = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0

; 33   : 	
; 34   : 	fRadius += (dwCurTime - dwLastBreathTime) / fCycle * (fMaxRange - fMinRange) * nDir * 2;

	mov	ecx, DWORD PTR [esi+44]
	mov	edi, eax
	sub	eax, DWORD PTR [esi+48]
	mov	DWORD PTR tv216[esp+16], ecx
	test	eax, eax
	mov	DWORD PTR tv240[esp+16], eax
	fild	DWORD PTR tv240[esp+16]
	jge	SHORT $LN14@Breath
	fadd	DWORD PTR __real@4f800000
$LN14@Breath:

; 35   : 	if(nDir == 1 && fRadius > fMaxRange)

	cmp	ecx, 1
	fdiv	DWORD PTR [esi+40]
	fld	DWORD PTR [esi+32]
	fsub	DWORD PTR [esi+28]
	fmulp	ST(1), ST(0)
	fimul	DWORD PTR tv216[esp+16]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR [esi+36]
	fstp	DWORD PTR tv226[esp+16]
	fld	DWORD PTR tv226[esp+16]
	fst	DWORD PTR [esi+36]
	jne	SHORT $LN3@Breath
	fld	DWORD PTR [esi+32]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Breath
	fstp	ST(0)

; 36   : 	{
; 37   : 		nDir = -1;

	mov	DWORD PTR [esi+44], -1

; 38   : 		fRadius = fMaxRange;

	fld	DWORD PTR [esi+32]
	fstp	DWORD PTR [esi+36]

; 44   : 	}
; 45   : 	m_nRadius = (int)fRadius;

	fld	DWORD PTR [esi+36]
	call	__ftol2_sse

; 46   : 	dwLastBreathTime = dwCurTime;

	mov	DWORD PTR [esi+48], edi
	pop	edi
	mov	DWORD PTR [esi+24], eax
	pop	esi

; 47   : }

	add	esp, 8
	ret	0
$LN3@Breath:

; 39   : 	}
; 40   : 	else if(nDir == -1 && fRadius < fMinRange)

	cmp	ecx, -1
	jne	SHORT $LN12@Breath
	fld	DWORD PTR [esi+28]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@Breath

; 41   : 	{
; 42   : 		nDir = 1;
; 43   : 		fRadius = fMinRange;

	fld	DWORD PTR [esi+28]
	mov	DWORD PTR [esi+44], 1
	fstp	DWORD PTR [esi+36]

; 44   : 	}
; 45   : 	m_nRadius = (int)fRadius;

	fld	DWORD PTR [esi+36]
	call	__ftol2_sse

; 46   : 	dwLastBreathTime = dwCurTime;

	mov	DWORD PTR [esi+48], edi
	pop	edi
	mov	DWORD PTR [esi+24], eax
	pop	esi

; 47   : }

	add	esp, 8
	ret	0
$LN12@Breath:

; 41   : 	{
; 42   : 		nDir = 1;
; 43   : 		fRadius = fMinRange;

	fstp	ST(0)
$LN1@Breath:

; 44   : 	}
; 45   : 	m_nRadius = (int)fRadius;

	fld	DWORD PTR [esi+36]
	call	__ftol2_sse

; 46   : 	dwLastBreathTime = dwCurTime;

	mov	DWORD PTR [esi+48], edi
	pop	edi
	mov	DWORD PTR [esi+24], eax
	pop	esi

; 47   : }

	add	esp, 8
	ret	0
?Breath@KSelfBreathLight@@UAEXXZ ENDP			; KSelfBreathLight::Breath
_TEXT	ENDS
PUBLIC	??_GKIpotBranch@@QAEPAXI@Z			; KIpotBranch::`scalar deleting destructor'
EXTRN	??1KIpotBranch@@QAE@XZ:PROC			; KIpotBranch::~KIpotBranch
; Function compile flags: /Ogtpy
;	COMDAT ??_GKIpotBranch@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GKIpotBranch@@QAEPAXI@Z PROC				; KIpotBranch::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1KIpotBranch@@QAE@XZ			; KIpotBranch::~KIpotBranch
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GKIpotBranch@@QAEPAXI@Z ENDP				; KIpotBranch::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?RemoveRtoGroupWithPermanentLeaf@KIpoTree@@AAEXXZ ; KIpoTree::RemoveRtoGroupWithPermanentLeaf
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveRtoGroupWithPermanentLeaf@KIpoTree@@AAEXXZ
_TEXT	SEGMENT
?RemoveRtoGroupWithPermanentLeaf@KIpoTree@@AAEXXZ PROC	; KIpoTree::RemoveRtoGroupWithPermanentLeaf, COMDAT
; _this$ = ecx

; 152  : 	KIpotRuntimeObj* pRto;
; 153  : 	while(pRto = (KIpotRuntimeObj*)m_PermanentLeaf.pBrother)

	mov	eax, DWORD PTR [ecx+56]
	xor	edx, edx
	cmp	eax, edx
	je	SHORT $LN1@RemoveRtoG
	push	esi
	npad	6
$LL2@RemoveRtoG:

; 154  : 	{
; 155  : 		m_PermanentLeaf.pBrother = pRto->pBrother;

	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+56], esi

; 156  : 		pRto->pAheadBrother = NULL;

	mov	DWORD PTR [eax+48], edx

; 157  : 		pRto->pBrother = NULL;

	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, edx
	jne	SHORT $LL2@RemoveRtoG
	pop	esi
$LN1@RemoveRtoG:

; 158  : 	}
; 159  : }

	ret	0
?RemoveRtoGroupWithPermanentLeaf@KIpoTree@@AAEXXZ ENDP	; KIpoTree::RemoveRtoGroupWithPermanentLeaf
_TEXT	ENDS
PUBLIC	?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z	; KIpoTree::AddBranch
EXTRN	?AddAObject@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z:PROC ; KIpotBranch::AddAObject
EXTRN	??0KIpotBranch@@QAE@XZ:PROC			; KIpotBranch::KIpotBranch
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?AddBranch@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z:PROC ; KIpotBranch::AddBranch
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z$0
__ehfuncinfo$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T112682 = 8						; size = 4
_pBranchObj$ = 8					; size = 4
?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z PROC	; KIpoTree::AddBranch, COMDAT
; _this$ = ecx

; 172  : {

	push	-1
	push	__ehhandler$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 173  : 	if (m_pMainBranch)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@AddBranch

; 174  : 		m_pMainBranch->AddBranch(pBranchObj);

	mov	eax, DWORD PTR _pBranchObj$[esp+20]
	push	eax
	call	?AddBranch@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z ; KIpotBranch::AddBranch

; 179  : 	}
; 180  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
$LN3@AddBranch:

; 175  : 	else if (pBranchObj)

	mov	edi, DWORD PTR _pBranchObj$[esp+20]
	test	edi, edi
	je	SHORT $LN1@AddBranch

; 176  : 	{
; 177  : 		m_pMainBranch = new KIpotBranch;

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T112682[esp+20], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	je	SHORT $LN6@AddBranch
	mov	ecx, eax
	call	??0KIpotBranch@@QAE@XZ			; KIpotBranch::KIpotBranch
	jmp	SHORT $LN7@AddBranch
$LN6@AddBranch:
	xor	eax, eax
$LN7@AddBranch:

; 178  : 		m_pMainBranch->AddAObject(pBranchObj);

	push	edi
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+36], -1
	mov	DWORD PTR [esi], eax
	call	?AddAObject@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z ; KIpotBranch::AddAObject
$LN1@AddBranch:

; 179  : 	}
; 180  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z$0:
	mov	eax, DWORD PTR $T112682[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddBranch@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z ENDP	; KIpoTree::AddBranch
PUBLIC	?AddLeafLine@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z ; KIpoTree::AddLeafLine
EXTRN	?AddLeafLine@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z:PROC ; KIpotBranch::AddLeafLine
; Function compile flags: /Ogtpy
;	COMDAT ?AddLeafLine@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z
_TEXT	SEGMENT
_pLeaf$ = 8						; size = 4
?AddLeafLine@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z PROC	; KIpoTree::AddLeafLine, COMDAT
; _this$ = ecx

; 221  : {

	mov	eax, ecx

; 222  : 	if (m_pMainBranch)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@AddLeafLin

; 223  : 		m_pMainBranch->AddLeafLine(pLeaf);

	jmp	?AddLeafLine@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z ; KIpotBranch::AddLeafLine
$LN2@AddLeafLin:

; 224  : 	else
; 225  : 		m_DefaultBranch.AddLeafLine(pLeaf);

	lea	ecx, DWORD PTR [eax+4]
	jmp	?AddLeafLine@KIpotBranch@@QAEXPAUKIpotBuildinObj@@@Z ; KIpotBranch::AddLeafLine
?AddLeafLine@KIpoTree@@QAEXPAUKIpotBuildinObj@@@Z ENDP	; KIpoTree::AddLeafLine
_TEXT	ENDS
PUBLIC	?SetPermanentBranchPos@KIpoTree@@QAEXHHH@Z	; KIpoTree::SetPermanentBranchPos
EXTRN	?SetLine@KIpotBranch@@QAEXPAUtagPOINT@@0@Z:PROC	; KIpotBranch::SetLine
; Function compile flags: /Ogtpy
;	COMDAT ?SetPermanentBranchPos@KIpoTree@@QAEXHHH@Z
_TEXT	SEGMENT
_p2$ = -16						; size = 8
_p1$ = -8						; size = 8
_nLeftX$ = 8						; size = 4
_nRightX$ = 12						; size = 4
_y$ = 16						; size = 4
?SetPermanentBranchPos@KIpoTree@@QAEXHHH@Z PROC		; KIpoTree::SetPermanentBranchPos, COMDAT
; _this$ = ecx

; 324  : 	POINT	p1, p2;
; 325  : 	if (nLeftX < nRightX)

	mov	eax, DWORD PTR _nLeftX$[esp-4]
	mov	edx, DWORD PTR _nRightX$[esp-4]
	sub	esp, 16					; 00000010H
	cmp	eax, edx

; 326  : 	{
; 327  : 		p1.x = nLeftX;
; 328  : 		p2.x = nRightX;

	jl	SHORT $LN8@SetPermane

; 329  : 	}
; 330  : 	else if (nLeftX > nRightX)

	jle	SHORT $LN2@SetPermane

; 331  : 	{
; 332  : 		p2.x = nLeftX;

	mov	DWORD PTR _p2$[esp+16], eax

; 333  : 		p1.x = nRightX;

	mov	DWORD PTR _p1$[esp+16], edx

; 334  : 	}
; 335  : 	else

	jmp	SHORT $LN1@SetPermane
$LN2@SetPermane:

; 336  : 	{
; 337  : 		p1.x = nLeftX;
; 338  : 		p2.x = nRightX + 2048;

	add	edx, 2048				; 00000800H
$LN8@SetPermane:
	mov	DWORD PTR _p2$[esp+16], edx
	mov	DWORD PTR _p1$[esp+16], eax
$LN1@SetPermane:

; 339  : 	}
; 340  : 	p2.y = p1.y = y;

	mov	eax, DWORD PTR _y$[esp+12]
	mov	DWORD PTR _p1$[esp+20], eax
	mov	DWORD PTR _p2$[esp+20], eax

; 341  : 	m_DefaultBranch.SetLine(&p1, &p2);

	lea	eax, DWORD PTR _p2$[esp+16]
	push	eax
	lea	edx, DWORD PTR _p1$[esp+20]
	push	edx
	add	ecx, 4
	call	?SetLine@KIpotBranch@@QAEXPAUtagPOINT@@0@Z ; KIpotBranch::SetLine

; 342  : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?SetPermanentBranchPos@KIpoTree@@QAEXHHH@Z ENDP		; KIpoTree::SetPermanentBranchPos
_TEXT	ENDS
PUBLIC	__real@4040000000000000
PUBLIC	__real@c2000000
PUBLIC	__real@42000000
PUBLIC	?FillLineObstacle@KIpoTree@@AAEXHHHHH@Z		; KIpoTree::FillLineObstacle
;	COMDAT __real@4040000000000000
; File c:\program files\microsoft visual studio 8\vc\include\math.h
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
CONST	ENDS
;	COMDAT __real@c2000000
CONST	SEGMENT
__real@c2000000 DD 0c2000000r			; -32
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
CONST	ENDS
;	COMDAT ?FillLineObstacle@KIpoTree@@AAEXHHHHH@Z
_TEXT	SEGMENT
_fFlope1$ = -28						; size = 4
_fy1$ = -28						; size = 4
_gx1$ = -24						; size = 4
_gy1$ = -20						; size = 4
_fdx$ = -20						; size = 4
_gx2$ = -16						; size = 4
_gy2$ = -12						; size = 4
_vDir$ = -8						; size = 8
tv767 = 8						; size = 4
tv762 = 8						; size = 4
tv759 = 8						; size = 4
tv757 = 8						; size = 4
tv752 = 8						; size = 4
tv749 = 8						; size = 4
tv574 = 8						; size = 4
tv525 = 8						; size = 4
tv522 = 8						; size = 4
tv517 = 8						; size = 4
tv514 = 8						; size = 4
tv424 = 8						; size = 4
tv421 = 8						; size = 4
tv416 = 8						; size = 4
tv363 = 8						; size = 4
tv358 = 8						; size = 4
tv351 = 8						; size = 4
_fStepX$ = 8						; size = 4
_fdy$ = 8						; size = 4
_fx1$ = 8						; size = 4
_x1$ = 8						; size = 4
_gStepY$ = 12						; size = 4
_y1$ = 12						; size = 4
_gStepX$ = 16						; size = 4
_x2$ = 16						; size = 4
_fStepY$ = 20						; size = 4
_y2$ = 20						; size = 4
_nObstacleID$ = 24					; size = 4
?FillLineObstacle@KIpoTree@@AAEXHHHHH@Z PROC		; KIpoTree::FillLineObstacle, COMDAT
; _this$ = ecx

; 433  : {

	sub	esp, 28					; 0000001cH
	push	ebx

; 434  : 	if(x1 >= x2)

	mov	ebx, DWORD PTR _x2$[esp+28]
	push	ebp
	mov	ebp, DWORD PTR _x1$[esp+32]
	cmp	ebp, ebx
	push	esi
	mov	esi, ecx
	jge	$LN1@FillLineOb

; 435  : 		return;
; 436  : 
; 437  : 	float fx1, fy1, fx2, fy2, fdx, fdy, fStepX, fStepY;
; 438  : 	int gStepX, gStepY, gx, gy, nIdx, gx1, gy1, gx2, gy2;
; 439  : 	fx1 = (float)x1, fy1 = (float)y1, fx2 = (float)x2, fy2 = (float)y2;

	fild	DWORD PTR _x1$[esp+36]

; 440  : 	fdx = (float)fabs(fx2 - fx1);
; 441  : 	fdy = (float)fabs(fy2 - fy1);
; 442  : 	KVector2 vDir;
; 443  : 	vDir.fX = fdx;
; 444  : 	vDir.fY = fdy;
; 445  : 	float fFlope1, fFlope2;
; 446  : 	gx1 = x1 / LIGHTING_GRID_SIZEX;

	mov	eax, ebp
	cdq
	and	edx, 31					; 0000001fH
	fstp	DWORD PTR _fx1$[esp+36]
	add	eax, edx
	fild	DWORD PTR _y1$[esp+36]
	push	edi
	mov	edi, eax

; 447  : 	gy1 = y1 / LIGHTING_GRID_SIZEX;

	mov	eax, DWORD PTR _y1$[esp+40]
	fstp	DWORD PTR _fy1$[esp+44]
	cdq
	fild	DWORD PTR _x2$[esp+40]
	and	edx, 31					; 0000001fH
	fld	DWORD PTR _fx1$[esp+40]
	add	eax, edx
	fld	ST(0)
	mov	ecx, eax
	fsubp	ST(2), ST(0)

; 448  : 	gx2 = x2 / LIGHTING_GRID_SIZEX;

	mov	eax, ebx
	fxch	ST(1)
	cdq
	fstp	DWORD PTR tv525[esp+40]
	and	edx, 31					; 0000001fH
	fld	DWORD PTR tv525[esp+40]
	add	eax, edx
	fabs
	mov	ebx, eax
	fstp	DWORD PTR tv522[esp+40]

; 449  : 	gy2 = y2 / LIGHTING_GRID_SIZEX;

	mov	eax, DWORD PTR _y2$[esp+40]
	fld	DWORD PTR tv522[esp+40]
	cdq
	fstp	DWORD PTR _fdx$[esp+44]
	fild	DWORD PTR _y2$[esp+40]
	and	edx, 31					; 0000001fH
	fld	DWORD PTR _fy1$[esp+44]
	add	edx, eax
	fld	ST(0)
	sar	edi, 5
	fsubp	ST(2), ST(0)
	sar	ecx, 5
	fxch	ST(1)
	sar	ebx, 5
	sar	edx, 5
	fstp	DWORD PTR tv517[esp+40]
	mov	DWORD PTR _gx1$[esp+44], edi
	fld	DWORD PTR tv517[esp+40]
	mov	DWORD PTR _gx2$[esp+44], ebx
	fabs
	mov	DWORD PTR _gy2$[esp+44], edx
	fstp	DWORD PTR tv514[esp+40]
	fld	DWORD PTR tv514[esp+40]
	fstp	DWORD PTR _fdy$[esp+40]
	fld	DWORD PTR _fdx$[esp+44]
	mov	DWORD PTR _gy1$[esp+44], ecx
	fst	DWORD PTR _vDir$[esp+44]
	fld	DWORD PTR _fdy$[esp+40]
	fst	DWORD PTR _vDir$[esp+48]

; 450  : 
; 451  : 	fFlope1 = fdy / fdx;

	fld	ST(0)
	fdiv	ST(0), ST(2)
	fst	DWORD PTR _fFlope1$[esp+44]

; 452  : 
; 453  : 	// 斜率小于45度的情况
; 454  : 	if(fdx >= fdy)

	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	$LN70@FillLineOb

; 455  : 	{
; 456  : 		if(gx1 == gx2)

	cmp	edi, ebx
	je	$LN73@FillLineOb

; 457  : 			return;
; 458  : 
; 459  : 		if(x2 > x1)

	or	eax, -1
	cmp	DWORD PTR _x2$[esp+40], ebp
	lea	ecx, DWORD PTR [eax+2]
	jle	SHORT $LN24@FillLineOb

; 460  : 		{
; 461  : 			gStepX = 1;
; 462  : 			fStepX = LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@42000000
	mov	DWORD PTR _gStepX$[esp+40], ecx

; 463  : 		}
; 464  : 		else

	jmp	SHORT $LN120@FillLineOb
$LN24@FillLineOb:

; 465  : 		{
; 466  : 			gStepX = -1;
; 467  : 			fStepX = -LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@c2000000
	mov	DWORD PTR _gStepX$[esp+40], eax
$LN120@FillLineOb:

; 468  : 		}
; 469  : 		if(y2 > y1)

	mov	edx, DWORD PTR _y1$[esp+40]
	fstp	DWORD PTR _fStepX$[esp+40]
	cmp	DWORD PTR _y2$[esp+40], edx
	jle	SHORT $LN80@FillLineOb
	fstp	ST(0)

; 470  : 		{
; 471  : 			gStepY = 1;

	mov	DWORD PTR _gStepY$[esp+40], ecx
	fstp	ST(0)

; 472  : 			fStepY = fdy / fdx * LIGHTING_GRID_SIZEX;
; 473  : 		}
; 474  : 		else

	jmp	SHORT $LN121@FillLineOb
$LN80@FillLineOb:

; 468  : 		}
; 469  : 		if(y2 > y1)

	fstp	ST(2)

; 475  : 		{
; 476  : 			gStepY = -1;

	mov	DWORD PTR _gStepY$[esp+40], eax

; 477  : 			fStepY = -fdy / fdx * LIGHTING_GRID_SIZEX;

	fchs
	fdivrp	ST(1), ST(0)
$LN121@FillLineOb:
	fld	QWORD PTR __real@4040000000000000
	mov	ebx, DWORD PTR _nObstacleID$[esp+40]
	mov	ebp, DWORD PTR _vDir$[esp+48]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _fStepY$[esp+40]
	fld	DWORD PTR _fFlope1$[esp+44]
	fld	DWORD PTR _fStepX$[esp+40]
	jmp	SHORT $LN20@FillLineOb
$LN65@FillLineOb:
	fld	DWORD PTR _fy1$[esp+44]
	fld	DWORD PTR _fx1$[esp+40]
	fxch	ST(4)
	fxch	ST(1)
	fxch	ST(3)
	fxch	ST(1)
$LN20@FillLineOb:

; 478  : 		}
; 479  : 		while(1)
; 480  : 		{
; 481  : 			int nx = (int)fx1;
; 482  : 			int ny = (int)fy1;
; 483  : 
; 484  : 			gx = nx / LIGHTING_GRID_SIZEX;

	fld	ST(4)
	call	__ftol2_sse

; 485  : 			gy = ny / LIGHTING_GRID_SIZEX;

	fld	ST(3)
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
	sar	edi, 5
	call	__ftol2_sse
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx

; 486  : 
; 487  : 			if(gx >0 && gx < LIGHTING_GRID_WIDTH - 1 && gy >0 && gy < LIGHTING_GRID_HEIGHT - 1)

	lea	ecx, DWORD PTR [edi-1]
	sar	eax, 5
	cmp	ecx, 45					; 0000002dH
	ja	$LN67@FillLineOb
	lea	edx, DWORD PTR [eax-1]
	cmp	edx, 93					; 0000005dH
	ja	$LN67@FillLineOb

; 488  : 			{
; 489  : 				nIdx = gy * LIGHTING_GRID_WIDTH + gx;
; 490  : 				pObstacle[nIdx].nObstacle = nObstacleID;
; 491  : 				pObstacle[nIdx].vDir = vDir;

	mov	ebp, DWORD PTR _vDir$[esp+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 4
	lea	edx, DWORD PTR [ecx+edi]
	lea	ecx, DWORD PTR [edx+6]
	shl	ecx, 4
	mov	DWORD PTR [ecx+esi], ebx
	mov	ecx, edx
	shl	ecx, 4
	mov	DWORD PTR [ecx+esi+100], ebp
	mov	ebp, DWORD PTR _vDir$[esp+48]
	mov	DWORD PTR [ecx+esi+104], ebp

; 492  : 
; 493  : 				fFlope2 = (float)(fabs((gy + gStepY) * 32.0f - fy1) / fabs((gx + gStepX) * 32.0f - fx1));

	mov	ecx, DWORD PTR _gStepY$[esp+40]
	add	ecx, eax
	mov	eax, DWORD PTR _gStepX$[esp+40]
	mov	DWORD PTR tv574[esp+40], ecx

; 494  : 				if(fFlope2 > fFlope1)

	fild	DWORD PTR tv574[esp+40]
	add	eax, edi
	fmul	ST(0), ST(3)
	fsub	ST(0), ST(4)
	fstp	DWORD PTR tv424[esp+40]
	fld	DWORD PTR tv424[esp+40]
	fabs
	fstp	DWORD PTR tv421[esp+40]
	fld	DWORD PTR tv421[esp+40]
	mov	DWORD PTR tv416[esp+40], eax
	fild	DWORD PTR tv416[esp+40]
	fmul	ST(0), ST(4)
	fsub	ST(0), ST(6)
	fstp	DWORD PTR tv363[esp+40]
	fld	DWORD PTR tv363[esp+40]
	fabs
	fstp	DWORD PTR tv358[esp+40]
	fdiv	DWORD PTR tv358[esp+40]
	fstp	DWORD PTR tv351[esp+40]
	fld	DWORD PTR tv351[esp+40]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN17@FillLineOb

; 495  : 				{
; 496  : 					nIdx = (gy + gStepY) * LIGHTING_GRID_WIDTH + gx;

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 4
	add	eax, edi

; 497  : 					pObstacle[nIdx].nObstacle = nObstacleID;
; 498  : 					pObstacle[nIdx].vDir = vDir;
; 499  : 				}
; 500  : 				else

	jmp	SHORT $LN122@FillLineOb
$LN17@FillLineOb:

; 501  : 				{
; 502  : 					nIdx = gy * LIGHTING_GRID_WIDTH + gx + gStepX;

	mov	eax, DWORD PTR _gStepX$[esp+40]
	add	eax, edx
$LN122@FillLineOb:

; 503  : 					pObstacle[nIdx].nObstacle = nObstacleID;
; 504  : 					pObstacle[nIdx].vDir = vDir;

	mov	edx, DWORD PTR _vDir$[esp+44]
	lea	ecx, DWORD PTR [eax+6]
	shl	ecx, 4
	shl	eax, 4
	mov	DWORD PTR [eax+esi+104], ebp
	mov	DWORD PTR [eax+esi+100], edx
	mov	DWORD PTR [ecx+esi], ebx
$LN67@FillLineOb:

; 505  : 				}
; 506  : 			}
; 507  : 
; 508  : 			fx1 += fStepX;
; 509  : 			fy1 += fStepY;
; 510  : 			gx1 += gStepX;

	mov	eax, DWORD PTR _gx1$[esp+44]
	fld	ST(0)
	add	eax, DWORD PTR _gStepX$[esp+40]
	faddp	ST(5), ST(0)
	fxch	ST(4)

; 511  : 			if(gx1 == gx2)

	cmp	eax, DWORD PTR _gx2$[esp+44]
	fstp	DWORD PTR _fx1$[esp+40]
	mov	DWORD PTR _gx1$[esp+44], eax
	fld	DWORD PTR _fStepY$[esp+40]
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _fy1$[esp+44]
	jne	$LN65@FillLineOb
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 512  : 			{
; 513  : 				gx = ((int)fx1) / LIGHTING_GRID_SIZEX;

	fld	DWORD PTR _fx1$[esp+40]
	call	__ftol2_sse

; 514  : 				gy = ((int)fy1) / LIGHTING_GRID_SIZEX;

	fld	DWORD PTR _fy1$[esp+44]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
	sar	edi, 5
	call	__ftol2_sse
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx

; 515  : 				if(gx >0 && gx < LIGHTING_GRID_WIDTH - 1 && gy >0 && gy < LIGHTING_GRID_HEIGHT - 1)

	lea	ecx, DWORD PTR [edi-1]
	sar	eax, 5
	cmp	ecx, 45					; 0000002dH
	ja	$LN68@FillLineOb
	lea	edx, DWORD PTR [eax-1]
	cmp	edx, 93					; 0000005dH
	ja	$LN68@FillLineOb

; 516  : 				{
; 517  : 					nIdx = gy * LIGHTING_GRID_WIDTH + gx;
; 518  : 					pObstacle[nIdx].nObstacle = nObstacleID;
; 519  : 					pObstacle[nIdx].vDir = vDir;

	mov	edx, DWORD PTR _vDir$[esp+44]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, edi
	lea	ecx, DWORD PTR [eax+6]
	shl	ecx, 4
	shl	eax, 4
	pop	edi
	mov	DWORD PTR [ecx+esi], ebx
	mov	DWORD PTR [eax+esi+104], ebp
	mov	DWORD PTR [eax+esi+100], edx
	pop	esi
	pop	ebp
	pop	ebx

; 592  : 				}
; 593  : 				return;
; 594  : 			}
; 595  : 		}
; 596  : 	}
; 597  : }

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
$LN70@FillLineOb:

; 520  : 				}
; 521  : 				return;
; 522  : 			}
; 523  : 		}
; 524  : 	}
; 525  : 	// 斜率大于45度的情况
; 526  : 	else
; 527  : 	{
; 528  : 		if(gy1 == gy2)

	cmp	ecx, edx
	fstp	ST(2)
	je	$LN97@FillLineOb

; 529  : 			return;
; 530  : 
; 531  : 		if(y2 > y1)

	mov	edx, DWORD PTR _y1$[esp+40]
	or	eax, -1
	cmp	DWORD PTR _y2$[esp+40], edx
	lea	ecx, DWORD PTR [eax+2]
	jle	SHORT $LN11@FillLineOb

; 532  : 		{
; 533  : 			gStepY = 1;
; 534  : 			fStepY = LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@42000000
	mov	DWORD PTR _gStepY$[esp+40], ecx

; 535  : 		}
; 536  : 		else

	jmp	SHORT $LN123@FillLineOb
$LN11@FillLineOb:

; 537  : 		{
; 538  : 			gStepY = -1;
; 539  : 			fStepY = -LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@c2000000
	mov	DWORD PTR _gStepY$[esp+40], eax
$LN123@FillLineOb:

; 540  : 		}
; 541  : 		if(x2 > x1)

	cmp	DWORD PTR _x2$[esp+40], ebp
	fstp	DWORD PTR _fStepY$[esp+40]
	jle	SHORT $LN9@FillLineOb

; 542  : 		{
; 543  : 			gStepX = 1;

	mov	DWORD PTR _gStepX$[esp+40], ecx

; 544  : 			fStepX = fdx / fdy * LIGHTING_GRID_SIZEX;

	fdivp	ST(1), ST(0)

; 545  : 		}
; 546  : 		else

	jmp	SHORT $LN124@FillLineOb
$LN9@FillLineOb:

; 547  : 		{
; 548  : 			gStepX = -1;
; 549  : 			fStepX = -fdx / fdy * LIGHTING_GRID_SIZEX;

	fxch	ST(1)
	mov	DWORD PTR _gStepX$[esp+40], eax
	fchs
	fdivrp	ST(1), ST(0)
$LN124@FillLineOb:
	fld	QWORD PTR __real@4040000000000000
	mov	ebx, DWORD PTR _nObstacleID$[esp+40]
	mov	ebp, DWORD PTR _vDir$[esp+48]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _fStepX$[esp+40]
	fld	DWORD PTR _fFlope1$[esp+44]
	fld	DWORD PTR _fStepX$[esp+40]
	jmp	SHORT $LN7@FillLineOb
$LN66@FillLineOb:
	fld	DWORD PTR _fy1$[esp+44]
	fld	DWORD PTR _fx1$[esp+40]
	fxch	ST(4)
	fxch	ST(1)
	fxch	ST(3)
	fxch	ST(1)
$LN7@FillLineOb:

; 550  : 		}
; 551  : 		while(1)
; 552  : 		{
; 553  : 			int nx = (int)fx1;
; 554  : 			int ny = (int)fy1;
; 555  : 
; 556  : 			gx = nx / LIGHTING_GRID_SIZEX;

	fld	ST(4)
	call	__ftol2_sse

; 557  : 			gy = ny / LIGHTING_GRID_SIZEX;

	fld	ST(3)
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
	sar	edi, 5
	call	__ftol2_sse
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx

; 558  : 
; 559  : 			if(gx >0 && gx < LIGHTING_GRID_WIDTH - 1 && gy >0 && gy < LIGHTING_GRID_HEIGHT - 1)

	lea	ecx, DWORD PTR [edi-1]
	sar	eax, 5
	cmp	ecx, 45					; 0000002dH
	ja	$LN3@FillLineOb
	lea	edx, DWORD PTR [eax-1]
	cmp	edx, 93					; 0000005dH
	ja	$LN3@FillLineOb

; 560  : 			{
; 561  : 				nIdx = gy * LIGHTING_GRID_WIDTH + gx;
; 562  : 				pObstacle[nIdx].nObstacle = nObstacleID;
; 563  : 				pObstacle[nIdx].vDir = vDir;

	mov	ebp, DWORD PTR _vDir$[esp+44]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 4
	lea	edx, DWORD PTR [ecx+edi]
	lea	ecx, DWORD PTR [edx+6]
	shl	ecx, 4
	mov	DWORD PTR [ecx+esi], ebx
	mov	ecx, edx
	shl	ecx, 4
	mov	DWORD PTR [ecx+esi+100], ebp
	mov	ebp, DWORD PTR _vDir$[esp+48]
	mov	DWORD PTR [ecx+esi+104], ebp

; 564  : 
; 565  : 				fFlope2 = (float)(fabs((gy + gStepY) * 32.0f - fy1) / fabs((gx + gStepX) * 32.0f - fx1));

	mov	ecx, DWORD PTR _gStepY$[esp+40]
	add	ecx, eax
	mov	eax, DWORD PTR _gStepX$[esp+40]
	mov	DWORD PTR tv574[esp+40], ecx

; 566  : 				if(fFlope2 > fFlope1)

	fild	DWORD PTR tv574[esp+40]
	add	eax, edi
	fmul	ST(0), ST(3)
	fsub	ST(0), ST(4)
	fstp	DWORD PTR tv749[esp+40]
	fld	DWORD PTR tv749[esp+40]
	fabs
	fstp	DWORD PTR tv752[esp+40]
	fld	DWORD PTR tv752[esp+40]
	mov	DWORD PTR tv757[esp+40], eax
	fild	DWORD PTR tv757[esp+40]
	fmul	ST(0), ST(4)
	fsub	ST(0), ST(6)
	fstp	DWORD PTR tv759[esp+40]
	fld	DWORD PTR tv759[esp+40]
	fabs
	fstp	DWORD PTR tv762[esp+40]
	fdiv	DWORD PTR tv762[esp+40]
	fstp	DWORD PTR tv767[esp+40]
	fld	DWORD PTR tv767[esp+40]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@FillLineOb

; 567  : 				{
; 568  : 					nIdx = (gy + gStepY) * LIGHTING_GRID_WIDTH + gx;

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 4
	add	eax, edi

; 569  : 					pObstacle[nIdx].nObstacle = nObstacleID;
; 570  : 					pObstacle[nIdx].vDir = vDir;
; 571  : 				}
; 572  : 				else

	jmp	SHORT $LN125@FillLineOb
$LN4@FillLineOb:

; 573  : 				{
; 574  : 					nIdx = gy * LIGHTING_GRID_WIDTH + gx + gStepX;

	mov	eax, DWORD PTR _gStepX$[esp+40]
	add	eax, edx
$LN125@FillLineOb:

; 575  : 					pObstacle[nIdx].nObstacle = nObstacleID;
; 576  : 					pObstacle[nIdx].vDir = vDir;

	mov	edx, DWORD PTR _vDir$[esp+44]
	lea	ecx, DWORD PTR [eax+6]
	shl	ecx, 4
	shl	eax, 4
	mov	DWORD PTR [eax+esi+104], ebp
	mov	DWORD PTR [eax+esi+100], edx
	mov	DWORD PTR [ecx+esi], ebx
$LN3@FillLineOb:

; 577  : 				}
; 578  : 			}
; 579  : 
; 580  : 			fx1 += fStepX;
; 581  : 			fy1 += fStepY;
; 582  : 			gy1 += gStepY;

	mov	eax, DWORD PTR _gy1$[esp+44]
	fld	ST(0)
	add	eax, DWORD PTR _gStepY$[esp+40]
	faddp	ST(5), ST(0)
	fxch	ST(4)

; 583  : 			if(gy1 == gy2)

	cmp	eax, DWORD PTR _gy2$[esp+44]
	fstp	DWORD PTR _fx1$[esp+40]
	mov	DWORD PTR _gy1$[esp+44], eax
	fld	DWORD PTR _fStepY$[esp+40]
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _fy1$[esp+44]
	jne	$LN66@FillLineOb
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 584  : 			{
; 585  : 				gx = ((int)fx1) / LIGHTING_GRID_SIZEX;

	fld	DWORD PTR _fx1$[esp+40]
	call	__ftol2_sse

; 586  : 				gy = ((int)fy1) / LIGHTING_GRID_SIZEX;

	fld	DWORD PTR _fy1$[esp+44]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
	sar	edi, 5
	call	__ftol2_sse
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx

; 587  : 				if(gx >0 && gx < LIGHTING_GRID_WIDTH - 1 && gy >0 && gy < LIGHTING_GRID_HEIGHT - 1)

	lea	ecx, DWORD PTR [edi-1]
	sar	eax, 5
	cmp	ecx, 45					; 0000002dH
	ja	SHORT $LN68@FillLineOb
	lea	edx, DWORD PTR [eax-1]
	cmp	edx, 93					; 0000005dH
	ja	SHORT $LN68@FillLineOb

; 588  : 				{
; 589  : 					nIdx = gy * LIGHTING_GRID_WIDTH + gx;
; 590  : 					pObstacle[nIdx].nObstacle = nObstacleID;
; 591  : 					pObstacle[nIdx].vDir = vDir;

	mov	edx, DWORD PTR _vDir$[esp+44]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, edi
	lea	ecx, DWORD PTR [eax+6]
	shl	ecx, 4
	shl	eax, 4
	pop	edi
	mov	DWORD PTR [ecx+esi], ebx
	mov	DWORD PTR [eax+esi+104], ebp
	mov	DWORD PTR [eax+esi+100], edx
	pop	esi
	pop	ebp
	pop	ebx

; 592  : 				}
; 593  : 				return;
; 594  : 			}
; 595  : 		}
; 596  : 	}
; 597  : }

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
$LN73@FillLineOb:

; 455  : 	{
; 456  : 		if(gx1 == gx2)

	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(2)
	pop	ebp
	fstp	ST(0)
	pop	ebx

; 520  : 				}
; 521  : 				return;
; 522  : 			}
; 523  : 		}
; 524  : 	}
; 525  : 	// 斜率大于45度的情况
; 526  : 	else
; 527  : 	{
; 528  : 		if(gy1 == gy2)

	fstp	ST(0)

; 592  : 				}
; 593  : 				return;
; 594  : 			}
; 595  : 		}
; 596  : 	}
; 597  : }

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
$LN97@FillLineOb:

; 520  : 				}
; 521  : 				return;
; 522  : 			}
; 523  : 		}
; 524  : 	}
; 525  : 	// 斜率大于45度的情况
; 526  : 	else
; 527  : 	{
; 528  : 		if(gy1 == gy2)

	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
$LN68@FillLineOb:
	pop	edi
$LN1@FillLineOb:
	pop	esi
	pop	ebp
	pop	ebx

; 592  : 				}
; 593  : 				return;
; 594  : 			}
; 595  : 		}
; 596  : 	}
; 597  : }

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
?FillLineObstacle@KIpoTree@@AAEXHHHHH@Z ENDP		; KIpoTree::FillLineObstacle
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@00000000
PUBLIC	?CanLighting@KIpoTree@@AAE_NHHHH@Z		; KIpoTree::CanLighting
;	COMDAT __real@0000000000000000
; File c:\program files\microsoft visual studio 8\vc\include\math.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
CONST	ENDS
;	COMDAT ?CanLighting@KIpoTree@@AAE_NHHHH@Z
_TEXT	SEGMENT
tv398 = -32						; size = 4
tv395 = -32						; size = 4
_fdx$ = -32						; size = 4
_fx$ = -32						; size = 4
tv403 = -28						; size = 4
tv401 = -28						; size = 4
_fy$ = -28						; size = 4
_nObstacle$ = -24					; size = 4
_nGridLightPosY$ = -20					; size = 4
_vDir$ = -16						; size = 8
_vLight$ = -8						; size = 8
_fStepX$ = 8						; size = 4
_x$ = 8							; size = 4
_fStepY$ = 12						; size = 4
_y$ = 12						; size = 4
_nGridStep$ = 16					; size = 4
_nLightPosX$ = 16					; size = 4
tv389 = 20						; size = 4
tv386 = 20						; size = 4
_fdy$ = 20						; size = 4
_nLightPosY$ = 20					; size = 4
?CanLighting@KIpoTree@@AAE_NHHHH@Z PROC			; KIpoTree::CanLighting, COMDAT
; _this$ = ecx

; 1304 : {

	sub	esp, 32					; 00000020H

; 1305 : 	int nGridX, nGridY, nGridLightPosX, nGridLightPosY, nGridStep, nCurrentGridX, nCurrentGridY, nIdx;
; 1306 : 	nGridX = x / LIGHTING_GRID_SIZEX;

	push	ebx
	push	ebp
	push	esi
	push	edi

; 1310 : 	if(nGridX == nGridLightPosX && nGridY == nGridLightPosY)

	mov	ebx, ecx

; 1305 : 	int nGridX, nGridY, nGridLightPosX, nGridLightPosY, nGridStep, nCurrentGridX, nCurrentGridY, nIdx;
; 1306 : 	nGridX = x / LIGHTING_GRID_SIZEX;

	mov	eax, DWORD PTR _x$[esp+44]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax

; 1307 : 	nGridY = y / LIGHTING_GRID_SIZEX;

	mov	eax, DWORD PTR _y$[esp+44]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax

; 1308 : 	nGridLightPosX = nLightPosX / LIGHTING_GRID_SIZEX;

	mov	eax, DWORD PTR _nLightPosX$[esp+44]
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax

; 1309 : 	nGridLightPosY = nLightPosY / LIGHTING_GRID_SIZEX;

	mov	eax, DWORD PTR _nLightPosY$[esp+44]
	cdq
	and	edx, 31					; 0000001fH
	add	edx, eax
	sar	edi, 5
	sar	ebp, 5
	sar	edx, 5
	sar	esi, 5

; 1310 : 	if(nGridX == nGridLightPosX && nGridY == nGridLightPosY)

	cmp	edi, ebp
	mov	DWORD PTR _nGridLightPosY$[esp+48], edx
	jne	SHORT $LN27@CanLightin
	cmp	esi, edx

; 1311 : 		return true;

	je	$LN93@CanLightin
$LN27@CanLightin:

; 1312 : 
; 1313 : 	int nObstacle = pObstacle[nGridY * LIGHTING_GRID_WIDTH + nGridX].nObstacle;

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 4
	add	eax, edi
	lea	ecx, DWORD PTR [eax+6]
	shl	ecx, 4
	mov	ecx, DWORD PTR [ecx+ebx]

; 1314 : 	KVector2 vDir = pObstacle[nGridY * LIGHTING_GRID_WIDTH + nGridX].vDir;

	shl	eax, 4
	mov	DWORD PTR _nObstacle$[esp+48], ecx
	mov	ecx, DWORD PTR [eax+ebx+100]
	mov	eax, DWORD PTR [eax+ebx+104]
	mov	DWORD PTR _vDir$[esp+48], ecx

; 1315 : 	KVector2 vLight;
; 1316 : 	vLight.fX = (float)(x - nLightPosX);

	mov	ecx, DWORD PTR _x$[esp+44]
	sub	ecx, DWORD PTR _nLightPosX$[esp+44]
	mov	DWORD PTR _vDir$[esp+52], eax

; 1317 : 	vLight.fY = (float)(y - nLightPosY);

	mov	eax, DWORD PTR _y$[esp+44]
	mov	DWORD PTR tv403[esp+48], ecx
	mov	ecx, DWORD PTR _nLightPosY$[esp+44]
	fild	DWORD PTR tv403[esp+48]
	sub	eax, ecx
	mov	DWORD PTR tv401[esp+48], eax
	fstp	DWORD PTR _vLight$[esp+48]
	fild	DWORD PTR tv401[esp+48]
	fstp	DWORD PTR _vLight$[esp+52]

; 1318 : 
; 1319 : 	float fx, fy, fLightPosX, fLightPosY, fdx, fdy, fStepX, fStepY;
; 1320 : 	fx = (float)x, fy =(float) y, fLightPosX = (float)nLightPosX, fLightPosY = (float)nLightPosY;

	fild	DWORD PTR _x$[esp+44]
	fstp	DWORD PTR _fx$[esp+48]
	fild	DWORD PTR _y$[esp+44]
	fstp	DWORD PTR _fy$[esp+48]

; 1321 : 	fdx = (float)fabs(fLightPosX - fx);

	fild	DWORD PTR _nLightPosX$[esp+44]
	fld	DWORD PTR _fx$[esp+48]
	fld	ST(0)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv398[esp+48]
	fld	DWORD PTR tv398[esp+48]
	fabs
	fstp	DWORD PTR tv395[esp+48]
	fld	DWORD PTR tv395[esp+48]
	fstp	DWORD PTR _fdx$[esp+48]

; 1322 : 	fdy = (float)fabs(fLightPosY - fy);

	fild	DWORD PTR _nLightPosY$[esp+44]
	fld	DWORD PTR _fy$[esp+48]
	fld	ST(0)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv389[esp+44]
	fld	DWORD PTR tv389[esp+44]
	fabs
	fstp	DWORD PTR tv386[esp+44]
	fld	DWORD PTR tv386[esp+44]
	fstp	DWORD PTR _fdy$[esp+44]

; 1323 : 
; 1324 : 	// 斜率小于45度的情况
; 1325 : 	if(fdx >= fdy)

	fld	DWORD PTR _fdx$[esp+48]
	fld	DWORD PTR _fdy$[esp+44]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN26@CanLightin

; 1326 : 	{
; 1327 : 		// 计算线段前进累加值
; 1328 : 		if(nLightPosX > x)

	mov	edx, DWORD PTR _x$[esp+44]
	cmp	DWORD PTR _nLightPosX$[esp+44], edx
	jle	SHORT $LN25@CanLightin

; 1329 : 		{
; 1330 : 			nGridStep = 1;
; 1331 : 			fStepX = LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@42000000
	mov	DWORD PTR _nGridStep$[esp+44], 1

; 1332 : 		}
; 1333 : 		else

	jmp	SHORT $LN88@CanLightin
$LN25@CanLightin:

; 1334 : 		{
; 1335 : 			nGridStep = -1;
; 1336 : 			fStepX = -LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@c2000000
	mov	DWORD PTR _nGridStep$[esp+44], -1
$LN88@CanLightin:

; 1337 : 		}
; 1338 : 		if(nLightPosY > y)

	cmp	ecx, DWORD PTR _y$[esp+44]
	fstp	DWORD PTR _fStepX$[esp+44]
	jle	SHORT $LN23@CanLightin

; 1339 : 			fStepY = fdy / fdx * LIGHTING_GRID_SIZEX;

	fdivrp	ST(1), ST(0)

; 1340 : 		else

	jmp	SHORT $LN89@CanLightin
$LN23@CanLightin:

; 1341 : 			fStepY = -fdy / fdx * LIGHTING_GRID_SIZEX;

	fchs
	fdivrp	ST(1), ST(0)
$LN89@CanLightin:
	fmul	QWORD PTR __real@4040000000000000

; 1342 : 
; 1343 : 		while(1)
; 1344 : 		{
; 1345 : 			fx += fStepX;
; 1346 : 			fy += fStepY;
; 1347 : 			nGridX += nGridStep;

	add	edi, DWORD PTR _nGridStep$[esp+44]

; 1348 : 			if(nGridX == nGridLightPosX)

	cmp	edi, ebp
	fstp	DWORD PTR _fStepY$[esp+44]
	fld	DWORD PTR _fStepX$[esp+44]
	fld	ST(0)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _fx$[esp+48]
	fld	DWORD PTR _fStepY$[esp+44]
	fld	ST(0)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _fy$[esp+48]
	je	$LN81@CanLightin
$LN21@CanLightin:

; 1349 : 			{
; 1350 : 				// 没有碰到障碍，根据这点本身是否障碍和障碍方向判断是否受光
; 1351 : 				if(nObstacle && vDir.fX != 0.0f)
; 1352 : 				{
; 1353 : 					if(vDir.fX * vLight.fY - vDir.fY * vLight.fX < 0.0f)
; 1354 : 						return true;
; 1355 : 					else
; 1356 : 						return false;
; 1357 : 				}
; 1358 : 				else
; 1359 : 					return true;
; 1360 : 			}
; 1361 : 
; 1362 : 			nCurrentGridX = ((int)fx) / LIGHTING_GRID_SIZEX;
; 1363 : 			nCurrentGridY = ((int)fy) / LIGHTING_GRID_SIZEX;
; 1364 : 			nIdx = nCurrentGridY * LIGHTING_GRID_WIDTH + nCurrentGridX;

	fld	DWORD PTR _fy$[esp+48]
	fld	ST(0)
	call	__ftol2_sse
	fld	DWORD PTR _fx$[esp+48]
	cdq
	fld	ST(0)
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 4
	call	__ftol2_sse
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	add	esi, eax

; 1365 : 			// 检查是否碰到挡光障碍
; 1366 : 			if(pObstacle[nIdx].nObstacle != 0 && pObstacle[nIdx].nObstacle != nObstacle)

	add	esi, 6
	shl	esi, 4
	mov	eax, DWORD PTR [esi+ebx]
	test	eax, eax
	je	SHORT $LN14@CanLightin
	cmp	eax, DWORD PTR _nObstacle$[esp+48]
	jne	$LN80@CanLightin
$LN14@CanLightin:

; 1342 : 
; 1343 : 		while(1)
; 1344 : 		{
; 1345 : 			fx += fStepX;
; 1346 : 			fy += fStepY;
; 1347 : 			nGridX += nGridStep;

	add	edi, DWORD PTR _nGridStep$[esp+44]
	fadd	ST(0), ST(3)

; 1348 : 			if(nGridX == nGridLightPosX)

	cmp	edi, ebp
	fstp	DWORD PTR _fx$[esp+48]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR _fy$[esp+48]
	jne	SHORT $LN21@CanLightin

; 1367 : 				return false;

	jmp	$LN81@CanLightin
$LN26@CanLightin:

; 1368 : 		}
; 1369 : 	}
; 1370 : 	// 斜率大于45度的情况
; 1371 : 	else
; 1372 : 	{
; 1373 : 		if(nLightPosY > y)

	cmp	ecx, DWORD PTR _y$[esp+44]
	jle	SHORT $LN12@CanLightin

; 1374 : 		{
; 1375 : 			nGridStep = 1;
; 1376 : 			fStepY = LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@42000000
	mov	ebp, 1

; 1377 : 		}
; 1378 : 		else

	jmp	SHORT $LN91@CanLightin
$LN12@CanLightin:

; 1379 : 		{
; 1380 : 			nGridStep = -1;
; 1381 : 			fStepY = -LIGHTING_GRID_SIZEX;

	fld	DWORD PTR __real@c2000000
	or	ebp, -1
$LN91@CanLightin:

; 1382 : 		}
; 1383 : 		if(nLightPosX > x)

	mov	eax, DWORD PTR _x$[esp+44]
	fstp	DWORD PTR _fStepY$[esp+44]
	cmp	DWORD PTR _nLightPosX$[esp+44], eax
	jle	SHORT $LN10@CanLightin

; 1384 : 			fStepX = fdx / fdy * LIGHTING_GRID_SIZEX;

	fdivp	ST(1), ST(0)

; 1385 : 		else

	jmp	SHORT $LN92@CanLightin
$LN10@CanLightin:

; 1386 : 			fStepX = -fdx / fdy * LIGHTING_GRID_SIZEX;

	fxch	ST(1)
	fchs
	fdivrp	ST(1), ST(0)
$LN92@CanLightin:
	fmul	QWORD PTR __real@4040000000000000

; 1390 : 			fy += fStepY;
; 1391 : 			nGridY += nGridStep;

	add	esi, ebp

; 1392 : 			if(nGridY == nGridLightPosY)

	cmp	esi, edx
	fstp	DWORD PTR _fStepX$[esp+44]
	fld	DWORD PTR _fStepX$[esp+44]
	fld	ST(0)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR _fx$[esp+48]
	fld	DWORD PTR _fStepY$[esp+44]
	fld	ST(0)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR _fy$[esp+48]
	je	SHORT $LN81@CanLightin
$LN8@CanLightin:

; 1404 : 			}
; 1405 : 
; 1406 : 			nCurrentGridX = ((int)fx) / LIGHTING_GRID_SIZEX;
; 1407 : 			nCurrentGridY = ((int)fy) / LIGHTING_GRID_SIZEX;
; 1408 : 			nIdx = nCurrentGridY * LIGHTING_GRID_WIDTH + nCurrentGridX;

	fld	DWORD PTR _fy$[esp+48]
	fld	ST(0)
	call	__ftol2_sse
	fld	DWORD PTR _fx$[esp+48]
	cdq
	fld	ST(0)
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	lea	edi, DWORD PTR [eax+eax*2]
	shl	edi, 4
	call	__ftol2_sse
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	add	edi, eax

; 1409 : 			// 检查是否碰到挡光障碍
; 1410 : 			if(pObstacle[nIdx].nObstacle != 0 && pObstacle[nIdx].nObstacle != nObstacle)

	add	edi, 6
	shl	edi, 4
	mov	eax, DWORD PTR [edi+ebx]
	test	eax, eax
	je	SHORT $LN1@CanLightin
	cmp	eax, DWORD PTR _nObstacle$[esp+48]
	jne	SHORT $LN80@CanLightin
$LN1@CanLightin:

; 1387 : 		while(1)
; 1388 : 		{
; 1389 : 			fx += fStepX;

	fadd	ST(0), ST(3)

; 1390 : 			fy += fStepY;
; 1391 : 			nGridY += nGridStep;

	add	esi, ebp

; 1392 : 			if(nGridY == nGridLightPosY)

	cmp	esi, DWORD PTR _nGridLightPosY$[esp+48]
	fstp	DWORD PTR _fx$[esp+48]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR _fy$[esp+48]
	jne	SHORT $LN8@CanLightin
$LN81@CanLightin:

; 1393 : 			{
; 1394 : 				// 没有碰到障碍，根据这点本身是否障碍和障碍方向判断是否受光
; 1395 : 				if(nObstacle && vDir.fX != 0.0f)

	cmp	DWORD PTR _nObstacle$[esp+48], 0
	fstp	ST(1)
	fstp	ST(0)
	je	SHORT $LN5@CanLightin
	fldz
	fld	DWORD PTR _vDir$[esp+48]
	fucom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN86@CanLightin

; 1396 : 				{
; 1397 : 					if(vDir.fX * vLight.fY - vDir.fY * vLight.fX < 0.0f)

	fmul	DWORD PTR _vLight$[esp+52]
	fld	DWORD PTR _vDir$[esp+52]
	fmul	DWORD PTR _vLight$[esp+48]
	fsubp	ST(1), ST(0)
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@CanLightin
$LN93@CanLightin:
	pop	edi
	pop	esi
	pop	ebp

; 1398 : 						return true;

	mov	al, 1
	pop	ebx

; 1412 : 		}
; 1413 : 	}
; 1414 : }

	add	esp, 32					; 00000020H
	ret	16					; 00000010H
$LN86@CanLightin:

; 1393 : 			{
; 1394 : 				// 没有碰到障碍，根据这点本身是否障碍和障碍方向判断是否受光
; 1395 : 				if(nObstacle && vDir.fX != 0.0f)

	fstp	ST(0)
$LN5@CanLightin:
	pop	edi
	pop	esi
	pop	ebp

; 1399 : 					else
; 1400 : 						return false;
; 1401 : 				}
; 1402 : 				else
; 1403 : 					return true;

	mov	al, 1
	pop	ebx

; 1412 : 		}
; 1413 : 	}
; 1414 : }

	add	esp, 32					; 00000020H
	ret	16					; 00000010H
$LN80@CanLightin:

; 1409 : 			// 检查是否碰到挡光障碍
; 1410 : 			if(pObstacle[nIdx].nObstacle != 0 && pObstacle[nIdx].nObstacle != nObstacle)

	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
$LN17@CanLightin:
	pop	edi
	pop	esi
	pop	ebp

; 1411 : 				return false;

	xor	al, al
	pop	ebx

; 1412 : 		}
; 1413 : 	}
; 1414 : }

	add	esp, 32					; 00000020H
	ret	16					; 00000010H
?CanLighting@KIpoTree@@AAE_NHHHH@Z ENDP			; KIpoTree::CanLighting
_TEXT	ENDS
PUBLIC	?EnableDynamicLights@KIpoTree@@QAEX_N@Z		; KIpoTree::EnableDynamicLights
; Function compile flags: /Ogtpy
;	COMDAT ?EnableDynamicLights@KIpoTree@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?EnableDynamicLights@KIpoTree@@QAEX_N@Z PROC		; KIpoTree::EnableDynamicLights, COMDAT
; _this$ = ecx

; 1595 : 	m_bDynamicLighting = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	mov	BYTE PTR [ecx+90], al

; 1596 : }

	ret	4
?EnableDynamicLights@KIpoTree@@QAEX_N@Z ENDP		; KIpoTree::EnableDynamicLights
_TEXT	ENDS
PUBLIC	?size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ?size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::size, COMDAT
; _this$ = ecx

; 604  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 605  : 		}

	ret	0
?size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::size
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Nextnode
; Function compile flags: /Ogtpy
;	COMDAT ?_Nextnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Nextnode, COMDAT

; 111  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 112  : 		}

	ret	0
?_Nextnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Prevnode
; Function compile flags: /Ogtpy
;	COMDAT ?_Prevnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Prevnode, COMDAT

; 116  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 117  : 		}

	ret	0
?_Prevnode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Prevnode
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVKLightBase@@@std@@QAE@XZ	; std::allocator<KLightBase *>::allocator<KLightBase *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVKLightBase@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVKLightBase@@@std@@QAE@XZ PROC		; std::allocator<KLightBase *>::allocator<KLightBase *>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	mov	eax, ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	ret	0
??0?$allocator@PAVKLightBase@@@std@@QAE@XZ ENDP		; std::allocator<KLightBase *>::allocator<KLightBase *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 142  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator++
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ??E?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator++, COMDAT
; _this$ = ecx

; 230  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 231  : 
; 232  :  #if _HAS_ITERATOR_DEBUGGING
; 233  : 			if (this->_Mycont == 0
; 234  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 235  : 				{
; 236  : 				_DEBUG_ERROR("list iterator not incrementable");
; 237  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 238  : 				}
; 239  :  #else
; 240  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Mycont != NULL);

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN3@operator
	call	edi
$LN3@operator:

; 241  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Mycont))->_Myhead);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN1@operator
	call	edi
$LN1@operator:

; 242  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 243  : 
; 244  : 			_Ptr = _Nextnode(_Ptr);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax
	pop	edi

; 245  : 			return (*this);

	mov	eax, esi
	pop	esi

; 246  : 			}

	ret	0
??E?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator++
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator==, COMDAT
; _this$ = ecx

; 282  : 			{	// test for iterator equality

	push	esi
	mov	esi, ecx

; 283  : 
; 284  :  #if _HAS_ITERATOR_DEBUGGING
; 285  : 			_Compat(_Right);
; 286  :  #else
; 287  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR __Right$[esp+4]
	je	SHORT $LN1@operator@2
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN2@operator@2
$LN1@operator@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@2:

; 288  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 289  : 
; 290  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edi+4]
	pop	edi
	sete	cl
	mov	al, cl
	pop	esi

; 291  : 			}

	ret	4
??8?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@3@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@3@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Mynode, COMDAT
; _this$ = ecx

; 300  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx+4]

; 301  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@3@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Bidit@PAVKLightBase@@HPBQAV1@ABQAV1@@std@@QAE@XZ ; std::_Bidit<KLightBase *,int,KLightBase * const *,KLightBase * const &>::_Bidit<KLightBase *,int,KLightBase * const *,KLightBase * const &>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Bidit@PAVKLightBase@@HPBQAV1@ABQAV1@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Bidit@PAVKLightBase@@HPBQAV1@ABQAV1@@std@@QAE@XZ PROC ; std::_Bidit<KLightBase *,int,KLightBase * const *,KLightBase * const &>::_Bidit<KLightBase *,int,KLightBase * const *,KLightBase * const &>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Bidit@PAVKLightBase@@HPBQAV1@ABQAV1@@std@@QAE@XZ ENDP ; std::_Bidit<KLightBase *,int,KLightBase * const *,KLightBase * const &>::_Bidit<KLightBase *,int,KLightBase * const *,KLightBase * const &>
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAVKLightBase@@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAVKLightBase@@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAVKLightBase@@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Myval, COMDAT

; 121  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 122  : 		}

	ret	0
?_Myval@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@KAAAPAVKLightBase@@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVKLightBase@@@std@@QAE@ABV01@@Z ; std::allocator<KLightBase *>::allocator<KLightBase *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVKLightBase@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVKLightBase@@@std@@QAE@ABV01@@Z PROC	; std::allocator<KLightBase *>::allocator<KLightBase *>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	ret	4
??0?$allocator@PAVKLightBase@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<KLightBase *>::allocator<KLightBase *>
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Const_iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Const_iterator<1>, COMDAT
; _this$ = ecx

; 172  : 			{	// construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	push	esi
	push	edi

; 173  : 			_SCL_SECURE_TRAITS_VALIDATE(_Plist != NULL);

	mov	edi, DWORD PTR __Plist$[esp+4]
	test	edi, edi
	mov	esi, ecx
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	jne	SHORT $LN9@Const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN9@Const_iter:

; 174  : 			this->_Mycont = _Plist;

	mov	DWORD PTR [esi], edi
	pop	edi

; 175  : 			}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Const_iterator<1>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVKLightBase@@@std@@QBEIXZ ; std::allocator<KLightBase *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVKLightBase@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVKLightBase@@@std@@QBEIXZ PROC	; std::allocator<KLightBase *>::max_size, COMDAT
; _this$ = ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 167  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 168  : 		}

	ret	0
?max_size@?$allocator@PAVKLightBase@@@std@@QBEIXZ ENDP	; std::allocator<KLightBase *>::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>, COMDAT

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);
; 61   : 	}

	ret	0
??$_Destroy@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0PAVKLightBase@@@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *><KLightBase *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0PAVKLightBase@@@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVKLightBase@@@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *><KLightBase *>, COMDAT
; _this$ = ecx

; 129  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 130  : 		{	// construct from a related allocator (do nothing)
; 131  : 		}

	ret	4
??$?0PAVKLightBase@@@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *><KLightBase *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files\microsoft visual studio 8\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T112981 = -12						; size = 12
$T112986 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>, COMDAT

; 38   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 39   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 45   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T112986[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T112981[esp+16]
	mov	DWORD PTR $T112986[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T112981[esp+16]
	push	ecx
	mov	DWORD PTR $T112981[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *,std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *,std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>, COMDAT

; 52   : 	void _FARQ *_Vptr = _Ptr;
; 53   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 54   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *,std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>, COMDAT

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);
; 61   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0PAVKLightBase@@@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node><KLightBase *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0PAVKLightBase@@@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVKLightBase@@@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node><KLightBase *>, COMDAT
; _this$ = ecx

; 129  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 130  : 		{	// construct from a related allocator (do nothing)
; 131  : 		}

	ret	4
??$?0PAVKLightBase@@@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVKLightBase@@@1@@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node><KLightBase *>
_TEXT	ENDS
PUBLIC	??$_Construct@PAVKLightBase@@PAV1@@std@@YAXPAPAVKLightBase@@ABQAV1@@Z ; std::_Construct<KLightBase *,KLightBase *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAVKLightBase@@PAV1@@std@@YAXPAPAVKLightBase@@ABQAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAVKLightBase@@PAV1@@std@@YAXPAPAVKLightBase@@ABQAV1@@Z PROC ; std::_Construct<KLightBase *,KLightBase *>, COMDAT

; 52   : 	void _FARQ *_Vptr = _Ptr;
; 53   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 54   : 	}

	ret	0
??$_Construct@PAVKLightBase@@PAV1@@std@@YAXPAPAVKLightBase@@ABQAV1@@Z ENDP ; std::_Construct<KLightBase *,KLightBase *>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??_7KSelfBreathLight@@6B@			; KSelfBreathLight::`vftable'
PUBLIC	??0KSelfBreathLight@@QAE@XZ			; KSelfBreathLight::KSelfBreathLight
PUBLIC	??_R4KSelfBreathLight@@6B@			; KSelfBreathLight::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKSelfBreathLight@@@8			; KSelfBreathLight `RTTI Type Descriptor'
PUBLIC	??_R3KSelfBreathLight@@8			; KSelfBreathLight::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KSelfBreathLight@@8			; KSelfBreathLight::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KSelfBreathLight@@8		; KSelfBreathLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@KSelfBreathLight@@8
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@KSelfBreathLight@@8 DD FLAT:??_R0?AVKSelfBreathLight@@@8 ; KSelfBreathLight::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KSelfBreathLight@@8
rdata$r	ENDS
;	COMDAT ??_R2KSelfBreathLight@@8
rdata$r	SEGMENT
??_R2KSelfBreathLight@@8 DD FLAT:??_R1A@?0A@EA@KSelfBreathLight@@8 ; KSelfBreathLight::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@KLightBase@@8
rdata$r	ENDS
;	COMDAT ??_R3KSelfBreathLight@@8
rdata$r	SEGMENT
??_R3KSelfBreathLight@@8 DD 00H				; KSelfBreathLight::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2KSelfBreathLight@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKSelfBreathLight@@@8
_DATA	SEGMENT
??_R0?AVKSelfBreathLight@@@8 DD FLAT:??_7type_info@@6B@	; KSelfBreathLight `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKSelfBreathLight@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KSelfBreathLight@@6B@
rdata$r	SEGMENT
??_R4KSelfBreathLight@@6B@ DD 00H			; KSelfBreathLight::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKSelfBreathLight@@@8
	DD	FLAT:??_R3KSelfBreathLight@@8
rdata$r	ENDS
;	COMDAT ??_7KSelfBreathLight@@6B@
CONST	SEGMENT
??_7KSelfBreathLight@@6B@ DD FLAT:??_R4KSelfBreathLight@@6B@ ; KSelfBreathLight::`vftable'
	DD	FLAT:?Breath@KSelfBreathLight@@UAEXXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0KSelfBreathLight@@QAE@XZ
_TEXT	SEGMENT
??0KSelfBreathLight@@QAE@XZ PROC			; KSelfBreathLight::KSelfBreathLight, COMDAT
; _this$ = ecx

; 25   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7KSelfBreathLight@@6B@

; 26   : 	nDir = 1;

	mov	DWORD PTR [esi+44], 1

; 27   : 	dwLastBreathTime = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR [esi+48], eax

; 28   : }

	mov	eax, esi
	pop	esi
	ret	0
??0KSelfBreathLight@@QAE@XZ ENDP			; KSelfBreathLight::KSelfBreathLight
_TEXT	ENDS
PUBLIC	?ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z ; KIpoTree::ObjectsCallback
;	COMDAT ?nObstacleID@?1??ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z@4HA
_DATA	SEGMENT
?nObstacleID@?1??ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z@4HA DD 01H ; `KIpoTree::ObjectsCallback'::`2'::nObstacleID
; Function compile flags: /Ogtpy
_DATA	ENDS
;	COMDAT ?ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pLeaf$ = 12						; size = 4
?ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z PROC	; KIpoTree::ObjectsCallback, COMDAT

; 391  : 	_ASSERT(p);
; 392  : 	_ASSERT(pLeaf);
; 393  : 	static int nObstacleID = 1;
; 394  : 	nObstacleID++;
; 395  : 
; 396  : 	if(pLeaf->eLeafType == KIpotLeaf::IPOTL_T_RUNTIME_OBJ)

	mov	eax, DWORD PTR _pLeaf$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ?nObstacleID@?1??ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z@4HA
	add	ebp, 1
	cmp	DWORD PTR [eax], 1
	mov	DWORD PTR ?nObstacleID@?1??ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z@4HA, ebp
	je	$LN2@ObjectsCal

; 397  : 		return;
; 398  : 
; 399  : 	KIpoTree *pTree = (KIpoTree*)p;
; 400  : 	KIpotBuildinObj* pObj = (KIpotBuildinObj*)pLeaf;
; 401  : 	KBuildinObj* pBio = ((KIpotBuildinObj*)pLeaf)->pBio;

	mov	ecx, DWORD PTR [eax+48]

; 402  : 	if((pBio->Props & SPBIO_P_BLOCK_LIGHT_MASK) == SPBIO_P_BLOCK_LIGHT_NONE)

	mov	ecx, DWORD PTR [ecx]
	and	ecx, 48					; 00000030H
	je	$LN2@ObjectsCal

; 403  : 		return;
; 404  : 
; 405  : 	if((pBio->Props & SPBIO_P_BLOCK_LIGHT_MASK) == SPBIO_P_BLOCK_LIGHT_BOTTOM)

	cmp	ecx, 16					; 00000010H
	push	esi
	push	edi
	jne	SHORT $LN6@ObjectsCal

; 406  : 	{
; 407  : 		// 按线段处理遮挡
; 408  : 		pTree->FillLineObstacle(pObj->oPosition.x - pTree->m_nLeftTopX, pObj->oPosition.y - pTree->m_nLeftTopY, 
; 409  : 								pObj->oEndPos.x - pTree->m_nLeftTopX, pObj->oEndPos.y - pTree->m_nLeftTopY, nObstacleID);

	mov	ecx, DWORD PTR _p$[esp+8]
	mov	edi, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [ecx+80]
	mov	esi, DWORD PTR [ecx+76]
	sub	edi, edx
	push	ebp
	push	edi
	mov	edi, DWORD PTR [eax+28]
	sub	edi, esi
	push	edi
	mov	edi, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+16]
	sub	edi, edx
	push	edi
	sub	eax, esi
	push	eax
	call	?FillLineObstacle@KIpoTree@@AAEXHHHHH@Z	; KIpoTree::FillLineObstacle
	pop	edi
	pop	esi
	pop	ebp

; 428  : 		}
; 429  : 	}
; 430  : }

	ret	0
$LN6@ObjectsCal:

; 410  : 	}
; 411  : 	else if((pBio->Props & SPBIO_P_BLOCK_LIGHT_MASK) == SPBIO_P_BLOCK_LIGHT_CIRCLE)

	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN11@ObjectsCal

; 412  : 	{
; 413  : 		// 按圆处理光线遮挡，忽略半径，都按一个格子处理
; 414  : 		int nX = pObj->oPosition.x;
; 415  : 		int nY = pObj->oPosition.y;
; 416  : 		int nIdx;
; 417  : 		if(nX < pTree->m_nLeftTopX || nY < pTree->m_nLeftTopY ||
; 418  : 				nX >= pTree->m_nLeftTopX + AREGION_WIDTH * 3 || nY >= pTree->m_nLeftTopY + AREGION_HEIGHT * 3)

	mov	esi, DWORD PTR _p$[esp+8]
	mov	edi, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	push	ebx
	mov	ebx, DWORD PTR [esi+76]
	cmp	edi, ebx
	jl	SHORT $LN13@ObjectsCal
	mov	ecx, DWORD PTR [esi+80]
	cmp	eax, ecx
	jl	SHORT $LN13@ObjectsCal
	lea	edx, DWORD PTR [ebx+1536]
	cmp	edi, edx
	jge	SHORT $LN13@ObjectsCal
	lea	edx, DWORD PTR [ecx+3072]
	cmp	eax, edx
	jge	SHORT $LN13@ObjectsCal

; 419  : 			return;
; 420  : 		else
; 421  : 		{
; 422  : 			nX = (nX - pTree->m_nLeftTopX) / LIGHTING_GRID_SIZEX;
; 423  : 			nY = (nY - pTree->m_nLeftTopY) / LIGHTING_GRID_SIZEY;

	sub	eax, ecx

; 424  : 			nIdx = nY * LIGHTING_GRID_WIDTH + nX;
; 425  : 			pTree->pObstacle[nIdx].nObstacle = nObstacleID;
; 426  : 			// 将方向的x分量设为0，表示不考虑方向
; 427  : 			pTree->pObstacle[nIdx].vDir.fX = 0.0f;

	fldz
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, edi
	sub	eax, ebx
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	sar	eax, 5
	shl	ecx, 4
	add	ecx, eax
	lea	eax, DWORD PTR [ecx+6]
	shl	eax, 4
	shl	ecx, 4
	mov	DWORD PTR [eax+esi], ebp
	fstp	DWORD PTR [ecx+esi+100]
$LN13@ObjectsCal:
	pop	ebx
$LN11@ObjectsCal:
	pop	edi
	pop	esi
$LN2@ObjectsCal:
	pop	ebp

; 428  : 		}
; 429  : 	}
; 430  : }

	ret	0
?ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z ENDP	; KIpoTree::ObjectsCallback
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator++, COMDAT
; _this$ = ecx

; 397  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 398  : 			++(*(_Mybase_iter *)this);

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN5@operator@3
	call	edi
$LN5@operator@3:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@3
	call	edi
$LN3@operator@3:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax
	pop	edi

; 399  : 			return (*this);

	mov	eax, esi
	pop	esi

; 400  : 			}

	ret	0
??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator++
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator!=, COMDAT
; _this$ = ecx

; 294  : 			{	// test for iterator inequality

	push	esi
	mov	esi, ecx

; 295  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR __Right$[esp+4]
	je	SHORT $LN3@operator@4
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN4@operator@4
$LN3@operator@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@4:
	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edi+4]
	pop	edi
	setne	cl
	mov	al, cl
	pop	esi

; 296  : 			}

	ret	4
??9?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator!=
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 161  : 		_Destroy(_Ptr);
; 162  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::_Iterator<1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::_Iterator<1>, COMDAT
; _this$ = ecx

; 355  : 			{	// construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Plist$[esp+4]
	test	edi, edi
	mov	esi, ecx
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], eax
	jne	SHORT $LN11@Iterator
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN11@Iterator:
	mov	DWORD PTR [esi], edi
	pop	edi

; 356  : 			}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PBV12@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::_Iterator<1>
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV012@H@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV012@H@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator++, COMDAT
; _this$ = ecx

; 403  : 			{	// postincrement

	push	ebx

; 404  : 			_Myt_iter _Tmp = *this;
; 405  : 			++*this;

	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx
	jne	SHORT $LN7@operator@5
	call	ebx
$LN7@operator@5:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN5@operator@5
	call	ebx
$LN5@operator@5:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]

; 406  : 			return (_Tmp);

	mov	eax, edi
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi
	pop	ebx

; 407  : 			}

	ret	8
??E?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator++
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Const_iterator<1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Const_iterator<1>, COMDAT
; _this$ = ecx

; 159  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 160  : 			}

	ret	0
??0?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::_Const_iterator<1>
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEABQAVKLightBase@@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEABQAVKLightBase@@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEABQAVKLightBase@@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator*, COMDAT
; _this$ = ecx

; 207  : 			{	// return designated value

	push	esi
	mov	esi, ecx

; 208  : 
; 209  :  #if _HAS_ITERATOR_DEBUGGING
; 210  : 			if (this->_Mycont == 0
; 211  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 212  : 				{
; 213  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 214  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 215  : 				}
; 216  :  #else
; 217  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Mycont != NULL);

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN3@operator@6
	call	edi
$LN3@operator@6:

; 218  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Mycont))->_Myhead);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN1@operator@6
	call	edi
$LN1@operator@6:

; 219  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 220  : 
; 221  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	add	eax, 8
	pop	esi

; 222  : 			}

	ret	0
??D?$_Const_iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEABQAVKLightBase@@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Const_iterator<1>::operator*
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>
	add	esp, 8

; 147  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 157  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z PROC ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 161  : 		_Destroy(_Ptr);
; 162  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ?max_size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::max_size, COMDAT
; _this$ = ecx

; 609  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 610  : 		}

	ret	0
?max_size@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEIXZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z ; std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_List_nod<KLightBase *,std::allocator<KLightBase *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z PROC ; std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_List_nod<KLightBase *,std::allocator<KLightBase *> >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct allocator from _Al

	mov	eax, ecx

; 48   : 		}

	ret	4
??0?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z ENDP ; std::_List_nod<KLightBase *,std::allocator<KLightBase *> >::_List_nod<KLightBase *,std::allocator<KLightBase *> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVKLightBase@@@std@@QAEXPAPAVKLightBase@@ABQAV3@@Z ; std::allocator<KLightBase *>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?construct@?$allocator@PAVKLightBase@@@std@@QAEXPAPAVKLightBase@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVKLightBase@@@std@@QAEXPAPAVKLightBase@@ABQAV3@@Z PROC ; std::allocator<KLightBase *>::construct, COMDAT
; _this$ = ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 157  : 		}

	ret	8
?construct@?$allocator@PAVKLightBase@@@std@@QAEXPAPAVKLightBase@@ABQAV3@@Z ENDP ; std::allocator<KLightBase *>::construct
_TEXT	ENDS
PUBLIC	?begin@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ?begin@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::begin, COMDAT
; _this$ = ecx

; 528  : 		return (iterator(_Nextnode(_Myhead), this));

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 529  : 		}

	ret	4
?begin@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::end, COMDAT
; _this$ = ecx

; 538  : 		return (iterator(_Myhead, this));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx

; 539  : 		}

	ret	4
?end@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::end
_TEXT	ENDS
PUBLIC	?erase@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@V312@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@V312@@Z
_TEXT	SEGMENT
$T113258 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@V312@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::erase, COMDAT
; _this$ = ecx

; 772  : 		{	// erase element at _Where

	sub	esp, 8
	push	ebx

; 773  : 
; 774  :  #if _HAS_ITERATOR_DEBUGGING
; 775  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 776  : 			_DEBUG_ERROR("list erase iterator outside range");
; 777  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 778  : 		_Orphan_ptr(*this, _Pnode);
; 779  : 
; 780  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 781  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	ebx, DWORD PTR __Where$[esp+8]
	test	ebx, ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Where$[esp+20]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T113258[esp+24], ebx
	jne	SHORT $LN10@erase
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN10@erase:
	cmp	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN8@erase
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN8@erase:

; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 
; 784  : 		if (_Pnode != _Myhead)

	cmp	esi, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [esi]
	je	SHORT $LN1@erase

; 785  : 			{	// not list head, safe to erase
; 786  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, ebp
	mov	DWORD PTR [eax], ecx

; 787  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]

; 788  : 			this->_Alnod.destroy(_Pnode);
; 789  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	esi
	mov	DWORD PTR [edx+4], eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 790  : 			--_Mysize;

	add	DWORD PTR [edi+8], -1
$LN1@erase:

; 791  : 			}
; 792  : 		return (_Where);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+4], ebp
	pop	ebp
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 793  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?erase@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE?AV?$_Iterator@$00@12@V312@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::erase
_TEXT	ENDS
PUBLIC	?clear@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXXZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXXZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::clear, COMDAT
; _this$ = ecx

; 811  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 812  : 
; 813  :  #if _HAS_ITERATOR_DEBUGGING
; 814  : 		this->_Orphan_ptr(*this, 0);
; 815  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 816  : 
; 817  : 		_Nodeptr _Pnext;
; 818  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]

; 819  : 		_Nextnode(_Myhead) = _Myhead;

	mov	DWORD PTR [ecx], ecx

; 820  : 		_Prevnode(_Myhead) = _Myhead;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx

; 821  : 		_Mysize = 0;
; 822  : 
; 823  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	cmp	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	je	SHORT $LN1@clear
	push	edi
	npad	3
$LL3@clear:

; 824  : 			{	// delete an element
; 825  : 			_Pnext = _Nextnode(_Pnode);

	mov	edi, DWORD PTR [eax]

; 826  : 			this->_Alnod.destroy(_Pnode);
; 827  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	edi, DWORD PTR [esi+4]
	mov	eax, edi
	jne	SHORT $LL3@clear
	pop	edi
$LN1@clear:
	pop	esi

; 828  : 			}
; 829  : 		}

	ret	0
?clear@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXXZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::clear
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::_Iterator<1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::_Iterator<1>, COMDAT
; _this$ = ecx

; 342  : 		_Iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 343  : 			{	// construct with null node
; 344  : 			}

	ret	0
??0?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::_Iterator<1>
_TEXT	ENDS
PUBLIC	??D?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEAAPAVKLightBase@@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEAAPAVKLightBase@@XZ
_TEXT	SEGMENT
??D?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEAAPAVKLightBase@@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator*, COMDAT
; _this$ = ecx

; 387  : 			{	// return designated value

	push	esi
	mov	esi, ecx

; 388  : 			return ((reference)**(_Mybase_iter *)this);

	cmp	DWORD PTR [esi], 0
	push	edi
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN5@operator@7
	call	edi
$LN5@operator@7:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@7
	call	edi
$LN3@operator@7:
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	add	eax, 8
	pop	esi

; 389  : 			}

	ret	0
??D?$_Iterator@$00@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QBEAAPAVKLightBase@@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Iterator<1>::operator*
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode, COMDAT
; _this$ = ecx

; 1143 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1144 : 		int _Linkcnt = 0;
; 1145 : 
; 1146 : 		_TRY_BEGIN
; 1147 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode
	mov	DWORD PTR [eax], eax
$LN26@Buynode:

; 1148 : 		++_Linkcnt;
; 1149 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode
	mov	DWORD PTR [ecx], eax
$LN36@Buynode:

; 1150 : 		_CATCH_ALL
; 1151 : 		if (0 < _Linkcnt)
; 1152 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1153 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1154 : 		_RERAISE;
; 1155 : 		_CATCH_END
; 1156 : 		return (_Pnode);
; 1157 : 		}

	ret	0
?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXXZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXXZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Tidy, COMDAT
; _this$ = ecx

; 1183 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1184 : 		clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	cmp	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	je	SHORT $LN3@Tidy
	push	edi
	npad	3
$LL5@Tidy:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	edi, DWORD PTR [esi+4]
	mov	eax, edi
	jne	SHORT $LL5@Tidy
	pop	edi
$LN3@Tidy:

; 1185 : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 1186 : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 1187 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1188 : 		_Myhead = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1189 : 		}

	ret	0
?_Tidy@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXXZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode, COMDAT
; _this$ = ecx

; 1162 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1163 : 		int _Linkcnt = 0;
; 1164 : 
; 1165 : 		_TRY_BEGIN
; 1166 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	eax, eax
	je	SHORT $LN27@Buynode@2
	mov	ecx, DWORD PTR __Next$[esp-4]
	mov	DWORD PTR [eax], ecx
$LN27@Buynode@2:

; 1167 : 		++_Linkcnt;
; 1168 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@2
	mov	edx, DWORD PTR __Prev$[esp-4]
	mov	DWORD PTR [ecx], edx
$LN37@Buynode@2:

; 1169 : 		++_Linkcnt;
; 1170 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx
$LN47@Buynode@2:

; 1171 : 		_CATCH_ALL
; 1172 : 		if (1 < _Linkcnt)
; 1173 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1174 : 		if (0 < _Linkcnt)
; 1175 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1176 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1177 : 		_RERAISE;
; 1178 : 		_CATCH_END
; 1179 : 		return (_Pnode);
; 1180 : 		}

	ret	12					; 0000000cH
?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Incsize
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z$0
__ehfuncinfo$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T113676 = -80						; size = 28
$T113675 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Incsize, COMDAT
; _this$ = ecx

; 1210 : 		{	// alter element count, with checking

	push	-1
	push	__ehhandler$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, eax

; 1211 : 		if (max_size() - _Mysize < _Count)

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Count$[esp+84]
	mov	esi, 1073741823				; 3fffffffH
	sub	esi, eax
	cmp	esi, edx
	jae	SHORT $LN1@Incsize

; 1212 : 			_THROW(length_error, "list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T113676[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T113676[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T113675[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T113675[esp+92]
	push	ecx
	mov	DWORD PTR $T113675[esp+96], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN16@Incsize:
$LN1@Incsize:

; 1213 : 		_Mysize += _Count;

	add	eax, edx
	mov	DWORD PTR [ecx+8], eax

; 1214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 80					; 00000050H
	ret	4
$LN15@Incsize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T113676[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-72]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Incsize
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$_List_ptr@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z ; std::_List_ptr<KLightBase *,std::allocator<KLightBase *> >::_List_ptr<KLightBase *,std::allocator<KLightBase *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_ptr@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z PROC ; std::_List_ptr<KLightBase *,std::allocator<KLightBase *> >::_List_ptr<KLightBase *,std::allocator<KLightBase *> >, COMDAT
; _this$ = ecx

; 67   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 68   : 		}

	ret	4
??0?$_List_ptr@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAE@V?$allocator@PAVKLightBase@@@1@@Z ENDP ; std::_List_ptr<KLightBase *,std::allocator<KLightBase *> >::_List_ptr<KLightBase *,std::allocator<KLightBase *> >
_TEXT	ENDS
PUBLIC	?Breathe@KIpoTree@@QAEXXZ			; KIpoTree::Breathe
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
;	COMDAT ?Breathe@KIpoTree@@QAEXXZ
_TEXT	SEGMENT
?Breathe@KIpoTree@@QAEXXZ PROC				; KIpoTree::Breathe, COMDAT
; _this$ = ecx

; 122  : 	list<KLightBase*>::iterator i;
; 123  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	mov	eax, DWORD PTR [ecx+92276]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	lea	esi, DWORD PTR [ecx+92272]
	push	edi
	mov	edi, DWORD PTR [eax]
$LL35@Breathe:
	test	esi, esi
	mov	ebx, DWORD PTR [esi+4]
	je	SHORT $LN53@Breathe
	cmp	esi, esi
	je	SHORT $LN54@Breathe
$LN53@Breathe:
	call	ebp
	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
$LN54@Breathe:
	cmp	edi, ebx
	je	SHORT $LN2@Breathe

; 124  : 	{
; 125  : 		if((*i)->m_pParent == NULL)

	test	esi, esi
	jne	SHORT $LN62@Breathe
	call	ebp
$LN62@Breathe:
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN60@Breathe
	call	ebp
$LN60@Breathe:
	mov	ecx, DWORD PTR [edi+8]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@Breathe

; 126  : 			(*i)->Breath();

	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN70@Breathe
	call	ebp
$LN70@Breathe:
	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	call	eax
$LN3@Breathe:

; 122  : 	list<KLightBase*>::iterator i;
; 123  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN31@Breathe
	call	ebp
$LN31@Breathe:
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LL35@Breathe
$LN2@Breathe:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 127  : 	}
; 128  : }

	ret	0
?Breathe@KIpoTree@@QAEXXZ ENDP				; KIpoTree::Breathe
_TEXT	ENDS
PUBLIC	?Clear@KIpoTree@@QAEXXZ				; KIpoTree::Clear
EXTRN	?Clear@KIpotBranch@@QAEXXZ:PROC			; KIpotBranch::Clear
; Function compile flags: /Ogtpy
;	COMDAT ?Clear@KIpoTree@@QAEXXZ
_TEXT	SEGMENT
?Clear@KIpoTree@@QAEXXZ PROC				; KIpoTree::Clear, COMDAT
; _this$ = ecx

; 132  : {

	push	esi
	mov	esi, ecx
	push	edi

; 133  : 	if (m_pMainBranch)

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN4@Clear

; 134  : 	{
; 135  : 		delete (m_pMainBranch);

	mov	ecx, edi
	call	??1KIpotBranch@@QAE@XZ			; KIpotBranch::~KIpotBranch
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 136  : 		m_pMainBranch = NULL;

	mov	DWORD PTR [esi], 0
$LN4@Clear:
	push	ebx
	push	ebp

; 137  : 	}
; 138  : 	m_DefaultBranch.Clear();

	lea	ecx, DWORD PTR [esi+4]
	call	?Clear@KIpotBranch@@QAEXXZ		; KIpotBranch::Clear

; 139  : 	RemoveRtoGroupWithPermanentLeaf();

	mov	ecx, esi
	call	?RemoveRtoGroupWithPermanentLeaf@KIpoTree@@AAEXXZ ; KIpoTree::RemoveRtoGroupWithPermanentLeaf

; 140  : 	
; 141  : 	//clear all dyna light
; 142  : 	list<KLightBase*>::iterator i;
; 143  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	mov	eax, DWORD PTR [esi+92276]
	mov	edi, DWORD PTR [eax]
	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	add	esi, 92272				; 00016870H
$LL40@Clear:
	test	esi, esi
	mov	ebx, DWORD PTR [esi+4]
	je	SHORT $LN58@Clear
	cmp	esi, esi
	je	SHORT $LN59@Clear
$LN58@Clear:
	call	ebp
$LN59@Clear:
	cmp	edi, ebx
	je	SHORT $LN1@Clear

; 144  : 	{
; 145  : 		delete (*i);

	test	esi, esi
	jne	SHORT $LN67@Clear
	call	ebp
$LN67@Clear:
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN65@Clear
	call	ebp
$LN65@Clear:
	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN36@Clear

; 140  : 	
; 141  : 	//clear all dyna light
; 142  : 	list<KLightBase*>::iterator i;
; 143  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	call	ebp
$LN36@Clear:
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LL40@Clear
$LN1@Clear:

; 146  : 	}
; 147  : 	m_LightList.clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	cmp	eax, DWORD PTR [esi+4]
	pop	ebp
	mov	DWORD PTR [esi+8], 0
	pop	ebx
	je	SHORT $LN73@Clear
$LL75@Clear:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	edi, DWORD PTR [esi+4]
	mov	eax, edi
	jne	SHORT $LL75@Clear
$LN73@Clear:
	pop	edi
	pop	esi

; 148  : }

	ret	0
?Clear@KIpoTree@@QAEXXZ ENDP				; KIpoTree::Clear
_TEXT	ENDS
PUBLIC	?Fell@KIpoTree@@QAEXXZ				; KIpoTree::Fell
EXTRN	?RemoveAllRtoLeafs@KIpotBranch@@QAEXPAUKIpotLeaf@@@Z:PROC ; KIpotBranch::RemoveAllRtoLeafs
; Function compile flags: /Ogtpy
;	COMDAT ?Fell@KIpoTree@@QAEXXZ
_TEXT	SEGMENT
$T114468 = -8						; size = 8
?Fell@KIpoTree@@QAEXXZ PROC				; KIpoTree::Fell, COMDAT
; _this$ = ecx

; 184  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 185  : 	if (m_pMainBranch)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	push	edi
	je	SHORT $LN4@Fell

; 186  : 	{
; 187  : 		m_pMainBranch->RemoveAllRtoLeafs(&m_PermanentLeaf);

	lea	eax, DWORD PTR [esi+52]
	push	eax
	call	?RemoveAllRtoLeafs@KIpotBranch@@QAEXPAUKIpotLeaf@@@Z ; KIpotBranch::RemoveAllRtoLeafs

; 188  : 		delete(m_pMainBranch);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN7@Fell
	mov	ecx, edi
	call	??1KIpotBranch@@QAE@XZ			; KIpotBranch::~KIpotBranch
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Fell:

; 189  : 		m_pMainBranch = NULL;

	mov	DWORD PTR [esi], 0
$LN4@Fell:

; 190  : 	}
; 191  : 	m_DefaultBranch.RemoveAllRtoLeafs(&m_PermanentLeaf);

	lea	ecx, DWORD PTR [esi+52]
	lea	edi, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?RemoveAllRtoLeafs@KIpotBranch@@QAEXPAUKIpotLeaf@@@Z ; KIpotBranch::RemoveAllRtoLeafs

; 192  : 	m_DefaultBranch.Clear();

	mov	ecx, edi
	call	?Clear@KIpotBranch@@QAEXXZ		; KIpotBranch::Clear

; 193  : 
; 194  : 	//清除所有内建对象的光源
; 195  : 	list<KLightBase*>::iterator i;
; 196  : 	for (i = m_LightList.begin(); i != m_LightList.end(); )

	mov	edx, DWORD PTR [esi+92276]
	lea	ebx, DWORD PTR [esi+92272]
	mov	esi, DWORD PTR [edx]
	mov	edi, ebx
	npad	7
$LL3@Fell:
	test	edi, edi
	mov	ebp, DWORD PTR [ebx+4]
	je	SHORT $LN48@Fell
	cmp	edi, ebx
	je	SHORT $LN116@Fell
$LN48@Fell:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN116@Fell:
	cmp	esi, ebp
	je	SHORT $LN2@Fell

; 197  : 	{
; 198  : 		if((*i)->m_pParent == NULL)

	test	edi, edi
	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN57@Fell
	call	ebp
$LN57@Fell:
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN55@Fell
	call	ebp
$LN55@Fell:
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Fell

; 199  : 		{
; 200  : 			delete (*i);

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN65@Fell
	call	ebp
$LN65@Fell:
	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 			i = m_LightList.erase(i);

	cmp	esi, DWORD PTR [edi+4]
	mov	DWORD PTR $T114468[esp+28], esi
	jne	SHORT $LN80@Fell
	call	ebp
$LN80@Fell:
	cmp	esi, DWORD PTR [ebx+4]
	mov	ebp, DWORD PTR [esi]
	je	SHORT $LN73@Fell
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], ebp
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	mov	DWORD PTR [eax+4], ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	add	DWORD PTR [ebx+8], -1
$LN73@Fell:
	mov	esi, ebp

; 202  : 			continue;

	jmp	SHORT $LL3@Fell
$LN1@Fell:

; 203  : 		}
; 204  : 		++i;

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN106@Fell
	call	ebp
$LN106@Fell:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LL3@Fell
$LN2@Fell:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 205  : 	}
; 206  : }

	add	esp, 8
	ret	0
?Fell@KIpoTree@@QAEXXZ ENDP				; KIpoTree::Fell
_TEXT	ENDS
PUBLIC	?PluckRto@KIpoTree@@QAEXPAUKIpotRuntimeObj@@@Z	; KIpoTree::PluckRto
EXTRN	?Pluck@KIpotRuntimeObj@@QAEXXZ:PROC		; KIpotRuntimeObj::Pluck
; Function compile flags: /Ogtpy
;	COMDAT ?PluckRto@KIpoTree@@QAEXPAUKIpotRuntimeObj@@@Z
_TEXT	SEGMENT
_pLeaf$ = 8						; size = 4
?PluckRto@KIpoTree@@QAEXPAUKIpotRuntimeObj@@@Z PROC	; KIpoTree::PluckRto, COMDAT
; _this$ = ecx

; 308  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 309  : 	pLeaf->Pluck();

	mov	ecx, DWORD PTR _pLeaf$[esp+8]
	push	edi
	call	?Pluck@KIpotRuntimeObj@@QAEXXZ		; KIpotRuntimeObj::Pluck

; 310  : 	list<KLightBase*>::iterator i;
; 311  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	mov	eax, DWORD PTR [esi+92276]
	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	lea	edi, DWORD PTR [esi+92272]
	mov	esi, DWORD PTR [eax]
$LL35@PluckRto:
	test	edi, edi
	mov	ebx, DWORD PTR [edi+4]
	je	SHORT $LN53@PluckRto
	cmp	edi, edi
	je	SHORT $LN54@PluckRto
$LN53@PluckRto:
	call	ebp
$LN54@PluckRto:
	cmp	esi, ebx
	je	SHORT $LN78@PluckRto

; 312  : 	{
; 313  : 		if((*i)->m_pParent == pLeaf)

	test	edi, edi
	jne	SHORT $LN62@PluckRto
	call	ebp
$LN62@PluckRto:
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN60@PluckRto
	call	ebp
$LN60@PluckRto:
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _pLeaf$[esp+12]
	cmp	DWORD PTR [ecx+4], edx
	je	SHORT $LN110@PluckRto

; 310  : 	list<KLightBase*>::iterator i;
; 311  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN31@PluckRto
	call	ebp
$LN31@PluckRto:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LL35@PluckRto
$LN110@PluckRto:

; 314  : 		{
; 315  : 			delete (*i);

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN70@PluckRto
	call	ebp
$LN70@PluckRto:
	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 316  : 			m_LightList.erase(i);

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN112@PluckRto
	call	ebp
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN78@PluckRto
$LN112@PluckRto:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	mov	DWORD PTR [eax+4], ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	add	DWORD PTR [edi+8], -1
$LN78@PluckRto:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 317  : 			break;
; 318  : 		}
; 319  : 	}
; 320  : }

	ret	4
?PluckRto@KIpoTree@@QAEXPAUKIpotRuntimeObj@@@Z ENDP	; KIpoTree::PluckRto
_TEXT	ENDS
PUBLIC	?StrewRtoLeafs@KIpoTree@@QAEXAAUtagRECT@@@Z	; KIpoTree::StrewRtoLeafs
EXTRN	?EnumerateObjects@KIpotBranch@@QAEXPAXP6AX0PAUKIpotLeaf@@@Z@Z:PROC ; KIpotBranch::EnumerateObjects
EXTRN	?AddLeafPoint@KIpotBranch@@QAEXPAUKIpotLeaf@@@Z:PROC ; KIpotBranch::AddLeafPoint
; Function compile flags: /Ogtpy
;	COMDAT ?StrewRtoLeafs@KIpoTree@@QAEXAAUtagRECT@@@Z
_TEXT	SEGMENT
_KeepRtoArea$ = 8					; size = 4
?StrewRtoLeafs@KIpoTree@@QAEXAAUtagRECT@@@Z PROC	; KIpoTree::StrewRtoLeafs, COMDAT
; _this$ = ecx

; 345  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 346  : 	KIpotBranch* pBranch;
; 347  : 	if (m_pMainBranch)

	mov	eax, DWORD PTR [esi]
	xor	ebx, ebx
	cmp	eax, ebx

; 348  : 		pBranch = m_pMainBranch;

	mov	ebp, eax
	jne	SHORT $LN16@StrewRtoLe

; 349  : 	else
; 350  : 		pBranch = &m_DefaultBranch;

	lea	ebp, DWORD PTR [esi+4]
$LN16@StrewRtoLe:

; 351  : 
; 352  : 	KIpotRuntimeObj* pRto;
; 353  : 	while(pRto = (KIpotRuntimeObj*)m_PermanentLeaf.pBrother)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, ebx
	je	SHORT $LN10@StrewRtoLe
	push	edi
	mov	edi, DWORD PTR _KeepRtoArea$[esp+12]
	npad	2
$LL11@StrewRtoLe:

; 354  : 	{
; 355  : 		m_PermanentLeaf.pBrother = pRto->pBrother;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+56], ecx

; 356  : 		pRto->pAheadBrother = NULL;
; 357  : 		pRto->pBrother = NULL;
; 358  : 
; 359  : 		if (pRto->oPosition.x >= KeepRtoArea.left  ||
; 360  : 			pRto->oPosition.x <  KeepRtoArea.right ||
; 361  : 			pRto->oPosition.y >= KeepRtoArea.top   ||
; 362  : 			pRto->oPosition.y <  KeepRtoArea.bottom)

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+48], ebx
	mov	DWORD PTR [eax+4], ebx
	cmp	ecx, DWORD PTR [edi]
	jge	SHORT $LN8@StrewRtoLe
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LN8@StrewRtoLe
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR [edi+4]
	jge	SHORT $LN8@StrewRtoLe
	cmp	ecx, DWORD PTR [edi+12]
	jl	SHORT $LN8@StrewRtoLe

; 365  : 		}
; 366  : 		else
; 367  : 		{
; 368  : 			PluckRto(pRto);				

	push	eax
	mov	ecx, esi
	call	?PluckRto@KIpoTree@@QAEXPAUKIpotRuntimeObj@@@Z ; KIpoTree::PluckRto
	jmp	SHORT $LN7@StrewRtoLe
$LN8@StrewRtoLe:

; 363  : 		{
; 364  : 			pBranch->AddLeafPoint(pRto);

	push	eax
	mov	ecx, ebp
	call	?AddLeafPoint@KIpotBranch@@QAEXPAUKIpotLeaf@@@Z ; KIpotBranch::AddLeafPoint
$LN7@StrewRtoLe:
	mov	eax, DWORD PTR [esi+56]
	cmp	eax, ebx
	jne	SHORT $LL11@StrewRtoLe
	pop	edi
$LN10@StrewRtoLe:

; 369  : 		}
; 370  : 	}
; 371  : 
; 372  : 	if(m_bDynamicLighting)

	cmp	BYTE PTR [esi+90], bl
	je	SHORT $LN1@StrewRtoLe

; 373  : 	{
; 374  : 		// 清空遮挡信息
; 375  : 		for(int j=0; j<LIGHTING_GRID_WIDTH*LIGHTING_GRID_HEIGHT; j++)

	lea	eax, DWORD PTR [esi+96]
	mov	ecx, 4608				; 00001200H
	npad	4
$LL5@StrewRtoLe:

; 376  : 		{
; 377  : 			pObstacle[j].nObstacle = 0;

	mov	DWORD PTR [eax], ebx
	add	eax, 16					; 00000010H
	sub	ecx, 1
	jne	SHORT $LL5@StrewRtoLe

; 378  : 		}
; 379  : 
; 380  : 		// 遍历树，计算遮挡信息
; 381  : 		if (m_pMainBranch)

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, ebx

; 382  : 			m_pMainBranch->EnumerateObjects(this, ObjectsCallback);

	push	OFFSET ?ObjectsCallback@KIpoTree@@CAXPAXPAUKIpotLeaf@@@Z ; KIpoTree::ObjectsCallback
	push	esi

; 383  : 		else

	jne	SHORT $LN19@StrewRtoLe

; 384  : 			m_DefaultBranch.EnumerateObjects(this, ObjectsCallback);

	lea	ecx, DWORD PTR [esi+4]
$LN19@StrewRtoLe:
	call	?EnumerateObjects@KIpotBranch@@QAEXPAXP6AX0PAUKIpotLeaf@@@Z@Z ; KIpotBranch::EnumerateObjects
$LN1@StrewRtoLe:
	pop	esi
	pop	ebp
	pop	ebx

; 385  : 	}
; 386  : }

	ret	4
?StrewRtoLeafs@KIpoTree@@QAEXAAUtagRECT@@@Z ENDP	; KIpoTree::StrewRtoLeafs
_TEXT	ENDS
PUBLIC	__real@40f0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?RenderLightMap@KIpoTree@@QAEXXZ		; KIpoTree::RenderLightMap
EXTRN	__CIsqrt:PROC
;	COMDAT __real@40f0000000000000
; File c:\program files\microsoft visual studio 8\vc\include\list
CONST	SEGMENT
__real@40f0000000000000 DQ 040f0000000000000r	; 65536
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
CONST	ENDS
;	COMDAT ?RenderLightMap@KIpoTree@@QAEXXZ
_TEXT	SEGMENT
tv4945 = -132						; size = 4
tv4938 = -132						; size = 4
tv4934 = -132						; size = 4
tv4933 = -132						; size = 2
tv4904 = -132						; size = 2
tv4876 = -132						; size = 2
tv4847 = -132						; size = 2
tv4917 = -128						; size = 4
tv4909 = -128						; size = 4
tv4905 = -128						; size = 4
tv4901 = -128						; size = 4
tv4899 = -128						; size = 8
tv4892 = -128						; size = 4
tv4888 = -128						; size = 4
tv4881 = -128						; size = 4
tv4877 = -128						; size = 4
tv4872 = -128						; size = 4
tv4870 = -128						; size = 8
tv4863 = -128						; size = 4
tv4859 = -128						; size = 4
tv4852 = -128						; size = 4
tv4848 = -128						; size = 4
tv4844 = -128						; size = 4
tv4842 = -128						; size = 8
tv2529 = -128						; size = 4
_this$ = -120						; size = 4
_gx$111138 = -116					; size = 4
_gy$111139 = -116					; size = 4
tv2226 = -112						; size = 4
tv584 = -112						; size = 4
tv2386 = -108						; size = 4
tv576 = -108						; size = 4
tv4754 = -104						; size = 4
tv1954 = -104						; size = 4
tv1895 = -104						; size = 4
tv2234 = -100						; size = 4
tv1251 = -100						; size = 4
_pdwLight$ = -100					; size = 4
tv2222 = -96						; size = 4
tv4779 = -92						; size = 4
tv2332 = -92						; size = 4
tv2230 = -88						; size = 4
tv4874 = -84						; size = 4
_r$111145 = -84						; size = 4
tv2662 = -80						; size = 4
tv2330 = -80						; size = 4
_nLightPosX$111124 = -76				; size = 4
_nLightPosY$111125 = -72				; size = 4
tv2288 = -68						; size = 4
tv2290 = -64						; size = 4
tv2328 = -60						; size = 4
_y$111137 = -56						; size = 4
tv1521 = -52						; size = 4
tv1440 = -52						; size = 4
_nGridRadius$111140 = -52				; size = 4
_ur$111132 = -48					; size = 4
_ug$111133 = -44					; size = 4
tv2140 = -40						; size = 4
_ub$111134 = -36					; size = 4
_fLightRadiusDenom$111141 = -32				; size = 4
tv2533 = -28						; size = 4
tv4929 = -24						; size = 4
tv4927 = -24						; size = 8
tv2398 = -12						; size = 4
_i$ = -8						; size = 8
?RenderLightMap@KIpoTree@@QAEXXZ PROC			; KIpoTree::RenderLightMap, COMDAT
; _this$ = ecx

; 934  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 136				; 00000088H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 935  : 	int nn = m_LightList.size();
; 936  : 	int j, nLightID=1;
; 937  : 
; 938  : 	m_dwAmbient = 0xff101010;
; 939  : 
; 940  : 	// 按环境光清空光照图
; 941  : 	DWORD dwR, dwG, dwB;
; 942  : 	dwR = (m_dwAmbient & 0x00ff0000) >>16;
; 943  : 	dwG = (m_dwAmbient & 0x0000ff00) >>8;
; 944  : 	dwB = m_dwAmbient & 0x000000ff;
; 945  :     KLColor *pTempColor = pLColor;

	mov	eax, DWORD PTR [esi+73824]
	mov	DWORD PTR [esi+92], -15724528		; ff101010H
	movzx	ecx, BYTE PTR [esi+94]
	movzx	edx, BYTE PTR [esi+93]
	push	edi
	mov	DWORD PTR _this$[esp+152], esi
	mov	ebx, 1152				; 00000480H
	mov	edi, 16					; 00000010H
$LL52@RenderLigh:

; 946  :     
; 947  :     // 如果每一个颜色分量是2个字节,可以考虑多一个项,然后用一个MMX的寄存器存放
; 948  :     // 正好8个字节
; 949  : 	for(j=0; j < LIGHTING_GRID_WIDTH * LIGHTING_GRID_HEIGHT / 4; j++)
; 950  : 	{
; 951  : 			pTempColor[0].r = dwR;

	mov	WORD PTR [eax], cx

; 952  : 			pTempColor[1].r = dwR;

	mov	WORD PTR [eax+8], cx

; 953  : 			pTempColor[2].r = dwR;

	mov	WORD PTR [eax+16], cx

; 954  : 			pTempColor[3].r = dwR;

	mov	WORD PTR [eax+24], cx

; 955  : 
; 956  : 			pTempColor[0].g = dwG;

	mov	WORD PTR [eax+2], dx

; 957  : 			pTempColor[1].g = dwG;

	mov	WORD PTR [eax+10], dx

; 958  : 			pTempColor[2].g = dwG;

	mov	WORD PTR [eax+18], dx

; 959  : 			pTempColor[3].g = dwG;

	mov	WORD PTR [eax+26], dx

; 960  : 
; 961  : 
; 962  : 			pTempColor[0].b = dwB;

	mov	WORD PTR [eax+4], di

; 963  : 			pTempColor[1].b = dwB;

	mov	WORD PTR [eax+12], di

; 964  : 			pTempColor[2].b = dwB;

	mov	WORD PTR [eax+20], di

; 965  : 			pTempColor[3].b = dwB;

	mov	WORD PTR [eax+28], di

; 966  :             
; 967  :             pTempColor += 4;

	add	eax, 32					; 00000020H
	sub	ebx, 1
	jne	SHORT $LL52@RenderLigh

; 968  : 	}
; 969  : 
; 970  : 	list<KLightBase*>::iterator i;
; 971  : 	// 计算每一个光源的光照结果
; 972  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	mov	eax, DWORD PTR [esi+92276]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _i$[esp+156], ebx
	npad	5
$LL91@RenderLigh:
	mov	ebp, DWORD PTR [esi+92276]
	lea	eax, DWORD PTR [esi+92272]
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN109@RenderLigh
	cmp	edi, eax
	je	SHORT $LN110@RenderLigh
$LN109@RenderLigh:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN110@RenderLigh:
	cmp	ebx, ebp
	je	$LN47@RenderLigh

; 973  : 	{
; 974  : 		nLightID++;
; 975  : 		KLightBase *pLight = *i;

	test	edi, edi
	jne	SHORT $LN118@RenderLigh
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN118@RenderLigh:
	cmp	ebx, DWORD PTR [edi+4]
	jne	SHORT $LN116@RenderLigh
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN116@RenderLigh:
	mov	ebp, DWORD PTR [ebx+8]

; 976  : 		// 光源相对于九区域左上角的坐标
; 977  : 		int nLightPosX = pLight->m_oPosition.nX - m_nLeftTopX;

	mov	eax, DWORD PTR [ebp+8]
	sub	eax, DWORD PTR [esi+76]

; 978  : 		int nLightPosY = pLight->m_oPosition.nY - m_nLeftTopY;

	mov	ecx, DWORD PTR [ebp+12]
	sub	ecx, DWORD PTR [esi+80]
	mov	DWORD PTR _nLightPosX$111124[esp+152], eax

; 979  : 		// 光源的格子坐标
; 980  : 		int nLightGridX = nLightPosX / LIGHTING_GRID_SIZEX;

	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax

; 981  : 		int nLightGridY = nLightPosY / LIGHTING_GRID_SIZEY;

	mov	eax, ecx
	cdq
	and	edx, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
	sar	ebx, 5
	sar	esi, 5

; 982  : 		if(nLightGridX < 0 || nLightGridX >= LIGHTING_GRID_WIDTH || 
; 983  : 			nLightGridY < 0 || nLightGridY >= LIGHTING_GRID_HEIGHT)

	cmp	ebx, 47					; 0000002fH
	mov	DWORD PTR _nLightPosY$111125[esp+152], ecx
	ja	$LN48@RenderLigh
	cmp	esi, 95					; 0000005fH
	ja	$LN48@RenderLigh

; 984  : 			continue;
; 985  : 
; 986  : 		// 光源所在格子中心的坐标
; 987  : 		int nLightGridCenterX = nLightGridX * LIGHTING_GRID_SIZEX + LIGHTING_GRID_SIZEX / 2;
; 988  : 		int nLightGridCenterY = nLightGridY * LIGHTING_GRID_SIZEY + LIGHTING_GRID_SIZEY / 2;
; 989  : 
; 990  : 		// 获取光源的r，g，b分量
; 991  : 		unsigned int ur, ug, ub;
; 992  : 
; 993  : 		ur = (pLight->m_dwColor & 0x00ff0000) >> 18;

	mov	eax, DWORD PTR [ebp+20]

; 994  : 		ug = (pLight->m_dwColor & 0x0000ff00) >> 10;
; 995  : 		ub = (pLight->m_dwColor & 0x000000ff) >> 2;
; 996  : 
; 997  : 		//float fr = (float)pLight->m_nRadius * (float)pLight->m_nRadius;
; 998  : 
; 999  : 		int j, x, y, gx, gy;
; 1000 : 		int nGridRadius = pLight->m_nRadius / LIGHTING_GRID_SIZEX;

	mov	ebp, DWORD PTR [ebp+24]
	mov	DWORD PTR tv1251[esp+152], ebp

; 1001 :         float fLightRadiusDenom =  1.0 / ((float)pLight->m_nRadius);

	fild	DWORD PTR tv1251[esp+152]
	mov	edx, eax
	fld1
	shr	edx, 18					; 00000012H
	fdivrp	ST(1), ST(0)
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _ur$111132[esp+152], edx
	mov	edx, eax
	shr	eax, 2
	and	eax, 63					; 0000003fH
	shr	edx, 10					; 0000000aH
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _ub$111134[esp+152], eax
	mov	DWORD PTR _ug$111133[esp+152], edx
	mov	eax, ebp
	cdq
	and	edx, 31					; 0000001fH
	mov	ecx, ebx
	mov	edi, esi
	add	eax, edx
	shl	ecx, 5
	shl	edi, 5
	sar	eax, 5
	add	ecx, 16					; 00000010H
	add	edi, 16					; 00000010H

; 1002 :         //fLightRadiusDenom *= fLightRadiusDenom;
; 1003 :         unsigned int uDistance65536 = 0;
; 1004 :         KLColor *pCurPos = NULL;
; 1005 : 
; 1006 : 		
; 1007 : 		gy = nLightGridY - (nGridRadius - 1);
; 1008 : 		// 从中心点向外扩展计算光照强度
; 1009 : 		for(int r = 0; r < nGridRadius; r++)

	test	eax, eax
	mov	DWORD PTR _nGridRadius$111140[esp+152], eax
	mov	DWORD PTR _r$111145[esp+152], 0
	fstp	DWORD PTR _fLightRadiusDenom$111141[esp+152]
	jle	$LN48@RenderLigh
	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 4
	mov	DWORD PTR tv2234[esp+152], eax
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv2328[esp+152], eax
	lea	eax, DWORD PTR [edi+32]
	mov	DWORD PTR tv2330[esp+152], eax
	mov	eax, ecx
	sub	eax, DWORD PTR _nLightPosX$111124[esp+152]
	lea	ebp, DWORD PTR [esi+1]
	mov	DWORD PTR tv2332[esp+152], eax
	mov	DWORD PTR tv2288[esp+152], ebp
	mov	ebp, DWORD PTR _nLightPosY$111125[esp+152]
	mov	eax, edi
	sub	eax, ebp
	add	eax, 32					; 00000020H
	sub	edi, ecx
	mov	edx, ebx
	sub	esi, ebx
	mov	DWORD PTR tv2140[esp+152], ebx
	mov	DWORD PTR tv2222[esp+152], -1
	mov	DWORD PTR tv2226[esp+152], ecx
	mov	DWORD PTR tv2230[esp+152], edx
	mov	DWORD PTR tv2290[esp+152], ecx
	mov	DWORD PTR tv2386[esp+152], eax
	mov	DWORD PTR tv2398[esp+152], edi
	mov	DWORD PTR tv2533[esp+152], esi
	jmp	SHORT $LN44@RenderLigh
$LL160@RenderLigh:
	mov	ebp, DWORD PTR _nLightPosY$111125[esp+152]
	mov	edx, DWORD PTR tv2230[esp+152]
	mov	eax, DWORD PTR tv2386[esp+152]
$LN44@RenderLigh:

; 1010 : 		{
; 1011 : 			gx = nLightGridX - r;
; 1012 : 			gy = nLightGridY - r;
; 1013 : 			if (!
; 1014 : 				((gx < 0) || (gy < 0))
; 1015 : 			)

	test	edx, edx
	mov	DWORD PTR _gx$111138[esp+152], edx
	jl	$LN135@RenderLigh
	mov	ecx, DWORD PTR tv2288[esp+152]
	add	ecx, -1
	js	$LN135@RenderLigh

; 1016 : 			{
; 1017 : 				x = nLightGridCenterX - r * LIGHTING_GRID_SIZEX;
; 1018 : 				y = nLightGridCenterY - r * LIGHTING_GRID_SIZEY;
; 1019 : 				pCurPos = &pLColor[gy * LIGHTING_GRID_WIDTH + gx];

	mov	ecx, DWORD PTR tv2328[esp+152]
	mov	edi, DWORD PTR tv2290[esp+152]
	lea	eax, DWORD PTR [eax+ebp-32]
	add	ecx, edx
	mov	edx, DWORD PTR _this$[esp+152]
	mov	DWORD PTR _y$111137[esp+152], eax
	mov	eax, DWORD PTR [edx+73824]
	lea	esi, DWORD PTR [eax+ecx*8-384]
	mov	eax, DWORD PTR tv2222[esp+152]
	add	eax, 2

; 1020 : 				for(j=0; j<(r * 2 + 1); j++)

	xor	ebx, ebx
	test	eax, eax
	mov	DWORD PTR tv2529[esp+152], eax
	jle	$LN135@RenderLigh
	mov	ecx, DWORD PTR tv2332[esp+152]
	mov	DWORD PTR tv1895[esp+152], ecx
	npad	7
$LL40@RenderLigh:

; 1021 : 				{
; 1022 : 					if(CanLighting(x, y, nLightPosX, nLightPosY))

	mov	edx, DWORD PTR _nLightPosX$111124[esp+152]
	mov	eax, DWORD PTR _y$111137[esp+152]
	mov	ecx, DWORD PTR _this$[esp+152]
	push	ebp
	push	edx
	push	eax
	push	edi
	call	?CanLighting@KIpoTree@@AAE_NHHHH@Z	; KIpoTree::CanLighting
	test	al, al
	je	$LN36@RenderLigh

; 1023 : 					{
; 1024 : 						//float f = 65536.0 - ((float)(
; 1025 : 						//    (
; 1026 : 						//        ((float)(x - nLightPosX)) * ((float)(x - nLightPosX)) + 
; 1027 : 						//        ((float)(y - nLightPosY)) * ((float)(y - nLightPosY))
; 1028 : 						//    ) * 
; 1029 : 						//    fLightRadiusDenom *
; 1030 : 						//    65536.0
; 1031 : 						//));
; 1032 : 						float f = 65536.0 - ((float)(
; 1033 : 							sqrt(double // Fixed By MrChuCong@gmail.com
; 1034 : 								(x - nLightPosX) * (x - nLightPosX) + 
; 1035 : 								(y - nLightPosY) * (y - nLightPosY)
; 1036 : 							) * 
; 1037 : 							fLightRadiusDenom * 
; 1038 : 							65536.0
; 1039 : 						));

	mov	eax, DWORD PTR _y$111137[esp+152]

; 1040 : 
; 1041 : 						uDistance65536 = (int)(f);

	fild	DWORD PTR tv1895[esp+152]
	sub	eax, ebp
	mov	ecx, eax
	imul	ecx, eax
	mov	DWORD PTR tv4945[esp+152], ecx
	fild	DWORD PTR tv4945[esp+152]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fmul	DWORD PTR _fLightRadiusDenom$111141[esp+152]
	fld	QWORD PTR __real@40f0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv4938[esp+152]
	fsub	DWORD PTR tv4938[esp+152]
	fstp	DWORD PTR tv4934[esp+152]
	fld	DWORD PTR tv4934[esp+152]
	fnstcw	WORD PTR tv4933[esp+152]
	movzx	eax, WORD PTR tv4933[esp+152]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv4929[esp+152], eax
	fldcw	WORD PTR tv4929[esp+152]
	fistp	QWORD PTR tv4927[esp+152]
	mov	eax, DWORD PTR tv4927[esp+152]

; 1042 : 
; 1043 : 						if (((int)uDistance65536) > 0)

	test	eax, eax
	fldcw	WORD PTR tv4933[esp+152]
	jle	SHORT $LN36@RenderLigh

; 1044 : 						{
; 1045 : 							pCurPos->r += (ur * uDistance65536 / 65536);

	mov	edx, eax
	imul	edx, DWORD PTR _ur$111132[esp+152]

; 1046 : 							pCurPos->g += (ug * uDistance65536 / 65536);

	mov	ecx, eax

; 1047 : 							pCurPos->b += (ub * uDistance65536 / 65536);

	imul	eax, DWORD PTR _ub$111134[esp+152]
	imul	ecx, DWORD PTR _ug$111133[esp+152]
	shr	edx, 16					; 00000010H
	add	WORD PTR [esi], dx
	shr	ecx, 16					; 00000010H
	add	WORD PTR [esi+2], cx
	shr	eax, 16					; 00000010H
	add	WORD PTR [esi+4], ax
$LN36@RenderLigh:

; 1048 : 						}
; 1049 : 					}
; 1050 : 
; 1051 : 					gx++;

	mov	eax, DWORD PTR _gx$111138[esp+152]
	add	eax, 1

; 1052 :                     if (gx >= LIGHTING_GRID_WIDTH)

	cmp	eax, 48					; 00000030H
	mov	DWORD PTR _gx$111138[esp+152], eax
	jge	SHORT $LN135@RenderLigh

; 1053 :                         break;
; 1054 : 
; 1055 : 					x += LIGHTING_GRID_SIZEX;

	add	DWORD PTR tv1895[esp+152], 32		; 00000020H
	add	ebx, 1
	add	edi, 32					; 00000020H

; 1056 : 					pCurPos++;

	add	esi, 8
	cmp	ebx, DWORD PTR tv2529[esp+152]
	jl	$LL40@RenderLigh
$LN135@RenderLigh:

; 1057 : 				}
; 1058 : 			}
; 1059 : 
; 1060 : 			if(r == 0)

	cmp	DWORD PTR _r$111145[esp+152], 0
	je	$LN43@RenderLigh

; 1061 : 				continue;
; 1062 : 
; 1063 : 			gx = nLightGridX - r;

	mov	eax, DWORD PTR tv2230[esp+152]

; 1064 : 			gy = nLightGridY + r;
; 1065 : 			if (!
; 1066 : 					((gx < 0) || (gy >= LIGHTING_GRID_HEIGHT))
; 1067 : 			)

	test	eax, eax
	mov	DWORD PTR _gx$111138[esp+152], eax
	jl	$LN136@RenderLigh
	mov	edx, DWORD PTR tv2533[esp+152]
	mov	eax, DWORD PTR tv2140[esp+152]
	add	edx, eax
	cmp	edx, 96					; 00000060H
	jge	$LN136@RenderLigh

; 1068 : 			{
; 1069 : 				x = nLightGridCenterX - r * LIGHTING_GRID_SIZEX;
; 1070 : 				y = nLightGridCenterY + r * LIGHTING_GRID_SIZEY;

	mov	edx, DWORD PTR tv2226[esp+152]
	mov	ecx, DWORD PTR tv2398[esp+152]

; 1071 : 				pCurPos = &pLColor[gy * LIGHTING_GRID_WIDTH + gx];

	mov	eax, DWORD PTR tv2234[esp+152]

; 1072 : 				for(j=0; j<(r * 2 + 1); j++)

	mov	ebp, DWORD PTR tv2222[esp+152]
	mov	edi, DWORD PTR tv2290[esp+152]
	add	ecx, edx
	mov	edx, DWORD PTR _this$[esp+152]
	mov	DWORD PTR _y$111137[esp+152], ecx
	mov	ecx, DWORD PTR tv2230[esp+152]
	add	eax, ecx
	mov	ecx, DWORD PTR [edx+73824]
	add	ebp, 2
	xor	ebx, ebx
	test	ebp, ebp
	lea	esi, DWORD PTR [ecx+eax*8]
	jle	$LN136@RenderLigh
	mov	edx, DWORD PTR tv2332[esp+152]
	mov	DWORD PTR tv1954[esp+152], edx
$LL32@RenderLigh:

; 1073 : 				{
; 1074 : 					if(CanLighting(x, y, nLightPosX, nLightPosY))

	mov	eax, DWORD PTR _nLightPosY$111125[esp+152]
	mov	ecx, DWORD PTR _nLightPosX$111124[esp+152]
	mov	edx, DWORD PTR _y$111137[esp+152]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+160]
	push	edx
	push	edi
	call	?CanLighting@KIpoTree@@AAE_NHHHH@Z	; KIpoTree::CanLighting
	test	al, al
	je	$LN28@RenderLigh

; 1075 : 					{
; 1076 : 						//float f = 65536.0 - ((float)(
; 1077 : 						//    (
; 1078 : 						//        ((float)(x - nLightPosX)) * ((float)(x - nLightPosX)) + 
; 1079 : 						//        ((float)(y - nLightPosY)) * ((float)(y - nLightPosY))
; 1080 : 						//    ) * 
; 1081 : 						//    fLightRadiusDenom *
; 1082 : 						//    65536.0
; 1083 : 						//));
; 1084 : 						float f = 65536.0 - ((float)(
; 1085 : 							sqrt(double // Fixed By MrChuCong@gmail.com
; 1086 : 								(x - nLightPosX) * (x - nLightPosX) + 
; 1087 : 								(y - nLightPosY) * (y - nLightPosY)
; 1088 : 							) * 
; 1089 : 							fLightRadiusDenom * 
; 1090 : 							65536.0
; 1091 : 						));

	mov	eax, DWORD PTR _y$111137[esp+152]

; 1092 : 
; 1093 : 						uDistance65536 = (int)(f);

	fild	DWORD PTR tv1954[esp+152]
	sub	eax, DWORD PTR _nLightPosY$111125[esp+152]
	mov	ecx, eax
	imul	ecx, eax
	mov	DWORD PTR tv4917[esp+152], ecx
	fild	DWORD PTR tv4917[esp+152]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fmul	DWORD PTR _fLightRadiusDenom$111141[esp+152]
	fld	QWORD PTR __real@40f0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fnstcw	WORD PTR tv4904[esp+152]
	movzx	eax, WORD PTR tv4904[esp+152]
	fstp	DWORD PTR tv4909[esp+152]
	fsub	DWORD PTR tv4909[esp+152]
	or	eax, 3072				; 00000c00H
	fstp	DWORD PTR tv4905[esp+152]
	fld	DWORD PTR tv4905[esp+152]
	mov	DWORD PTR tv4901[esp+152], eax
	fldcw	WORD PTR tv4901[esp+152]
	fistp	QWORD PTR tv4899[esp+152]
	mov	eax, DWORD PTR tv4899[esp+152]

; 1094 : 
; 1095 : 						if (((int)uDistance65536) > 0)

	test	eax, eax
	fldcw	WORD PTR tv4904[esp+152]
	jle	SHORT $LN28@RenderLigh

; 1096 : 						{
; 1097 : 							pCurPos->r += (ur * uDistance65536 / 65536);

	mov	edx, eax
	imul	edx, DWORD PTR _ur$111132[esp+152]

; 1098 : 							pCurPos->g += (ug * uDistance65536 / 65536);

	mov	ecx, eax

; 1099 : 							pCurPos->b += (ub * uDistance65536 / 65536);

	imul	eax, DWORD PTR _ub$111134[esp+152]
	imul	ecx, DWORD PTR _ug$111133[esp+152]
	shr	edx, 16					; 00000010H
	add	WORD PTR [esi], dx
	shr	ecx, 16					; 00000010H
	add	WORD PTR [esi+2], cx
	shr	eax, 16					; 00000010H
	add	WORD PTR [esi+4], ax
$LN28@RenderLigh:

; 1100 : 						}
; 1101 : 					}
; 1102 : 
; 1103 : 					gx++;

	mov	eax, DWORD PTR _gx$111138[esp+152]
	add	eax, 1

; 1104 :                     if (gx >= LIGHTING_GRID_WIDTH)

	cmp	eax, 48					; 00000030H
	mov	DWORD PTR _gx$111138[esp+152], eax
	jge	SHORT $LN136@RenderLigh

; 1105 :                         break;
; 1106 : 
; 1107 : 					x += LIGHTING_GRID_SIZEX;

	add	DWORD PTR tv1954[esp+152], 32		; 00000020H
	add	ebx, 1
	add	edi, 32					; 00000020H

; 1108 : 					pCurPos++;

	add	esi, 8
	cmp	ebx, ebp
	jl	$LL32@RenderLigh
$LN136@RenderLigh:

; 1109 : 				}
; 1110 : 			}
; 1111 : 
; 1112 : 			gx = nLightGridX - r;
; 1113 : 			gy = nLightGridY - (r - 1);
; 1114 : 			if (!
; 1115 : 				((gx < 0) || (gy < 0))
; 1116 : 			)

	cmp	DWORD PTR tv2230[esp+152], 0
	mov	edx, DWORD PTR tv2288[esp+152]
	mov	DWORD PTR _gy$111139[esp+152], edx
	jl	$LN137@RenderLigh
	test	edx, edx
	jl	$LN137@RenderLigh

; 1119 : 				y = nLightGridCenterY - (r - 1) * LIGHTING_GRID_SIZEY;
; 1120 : 				pCurPos = &pLColor[gy * LIGHTING_GRID_WIDTH + gx];

	mov	ecx, DWORD PTR tv2230[esp+152]
	mov	eax, DWORD PTR tv2328[esp+152]
	mov	edx, DWORD PTR _this$[esp+152]
	mov	ebp, DWORD PTR tv2330[esp+152]
	add	eax, ecx
	mov	ecx, DWORD PTR [edx+73824]

; 1121 : 				for(j=0; j<(r * 2 - 1); j++)

	xor	edi, edi
	cmp	DWORD PTR tv2222[esp+152], edi
	lea	esi, DWORD PTR [ecx+eax*8]
	jle	$LN137@RenderLigh

; 1117 : 			{
; 1118 : 				x = nLightGridCenterX - r * LIGHTING_GRID_SIZEX;

	mov	ebx, DWORD PTR tv2386[esp+152]
	npad	3
$LL25@RenderLigh:

; 1122 : 				{
; 1123 : 					if(CanLighting(x, y, nLightPosX, nLightPosY))

	mov	edx, DWORD PTR _nLightPosY$111125[esp+152]
	mov	eax, DWORD PTR _nLightPosX$111124[esp+152]
	mov	ecx, DWORD PTR tv2290[esp+152]
	push	edx
	push	eax
	push	ebp
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+168]
	call	?CanLighting@KIpoTree@@AAE_NHHHH@Z	; KIpoTree::CanLighting
	test	al, al
	je	$LN21@RenderLigh

; 1124 : 					{
; 1125 : 						//float f = 65536.0 - ((float)(
; 1126 : 						//    (
; 1127 : 						//        ((float)(x - nLightPosX)) * ((float)(x - nLightPosX)) + 
; 1128 : 						//        ((float)(y - nLightPosY)) * ((float)(y - nLightPosY))
; 1129 : 						//    ) * 
; 1130 : 						//    fLightRadiusDenom *
; 1131 : 						//    65536.0
; 1132 : 						//));
; 1133 : 						float f = 65536.0 - ((float)(
; 1134 : 							sqrt(double // Fixed By MrChuCong@gmail.com
; 1135 : 								(x - nLightPosX) * (x - nLightPosX) + 
; 1136 : 								(y - nLightPosY) * (y - nLightPosY)
; 1137 : 							) * 
; 1138 : 							fLightRadiusDenom * 
; 1139 : 							65536.0
; 1140 : 						));

	mov	edx, DWORD PTR tv2290[esp+152]
	sub	edx, DWORD PTR _nLightPosX$111124[esp+152]
	mov	eax, ebx
	imul	eax, ebx

; 1141 : 
; 1142 : 						uDistance65536 = (int)(f);

	mov	DWORD PTR tv4892[esp+152], edx
	fild	DWORD PTR tv4892[esp+152]
	mov	DWORD PTR tv4888[esp+152], eax
	fild	DWORD PTR tv4888[esp+152]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fmul	DWORD PTR _fLightRadiusDenom$111141[esp+152]
	fld	QWORD PTR __real@40f0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fnstcw	WORD PTR tv4876[esp+152]
	movzx	eax, WORD PTR tv4876[esp+152]
	fstp	DWORD PTR tv4881[esp+152]
	fsub	DWORD PTR tv4881[esp+152]
	or	eax, 3072				; 00000c00H
	fstp	DWORD PTR tv4877[esp+152]
	fld	DWORD PTR tv4877[esp+152]
	mov	DWORD PTR tv4872[esp+152], eax
	fldcw	WORD PTR tv4872[esp+152]
	fistp	QWORD PTR tv4870[esp+152]
	mov	eax, DWORD PTR tv4870[esp+152]

; 1143 : 
; 1144 : 						if (((int)uDistance65536) > 0)

	test	eax, eax
	fldcw	WORD PTR tv4876[esp+152]
	jle	SHORT $LN21@RenderLigh

; 1145 : 						{
; 1146 : 							pCurPos->r += (ur * uDistance65536 / 65536);

	mov	ecx, eax
	imul	ecx, DWORD PTR _ur$111132[esp+152]

; 1147 : 							pCurPos->g += (ug * uDistance65536 / 65536);

	mov	edx, eax

; 1148 : 							pCurPos->b += (ub * uDistance65536 / 65536);

	imul	eax, DWORD PTR _ub$111134[esp+152]
	imul	edx, DWORD PTR _ug$111133[esp+152]
	shr	ecx, 16					; 00000010H
	add	WORD PTR [esi], cx
	shr	edx, 16					; 00000010H
	add	WORD PTR [esi+2], dx
	shr	eax, 16					; 00000010H
	add	WORD PTR [esi+4], ax
$LN21@RenderLigh:

; 1149 : 						}
; 1150 : 					}
; 1151 : 
; 1152 : 					gy++;

	mov	eax, DWORD PTR _gy$111139[esp+152]
	add	eax, 1

; 1153 :                     if (gy >= LIGHTING_GRID_HEIGHT)

	cmp	eax, 96					; 00000060H
	mov	DWORD PTR _gy$111139[esp+152], eax
	jge	SHORT $LN137@RenderLigh
	add	edi, 1

; 1154 :                         break;
; 1155 : 
; 1156 : 					y += LIGHTING_GRID_SIZEX;

	add	ebp, 32					; 00000020H
	add	ebx, 32					; 00000020H

; 1157 : 					pCurPos += LIGHTING_GRID_WIDTH;

	add	esi, 384				; 00000180H
	cmp	edi, DWORD PTR tv2222[esp+152]
	jl	$LL25@RenderLigh
$LN137@RenderLigh:

; 1158 : 				}
; 1159 : 			}
; 1160 : 
; 1161 : 			
; 1162 : 			gx = nLightGridX + r;
; 1163 : 			gy = nLightGridY - (r - 1);
; 1164 : 			if (!
; 1165 : 				((gx >= LIGHTING_GRID_WIDTH ) || (gy < 0))
; 1166 : 			)

	mov	eax, DWORD PTR tv2140[esp+152]
	cmp	eax, 48					; 00000030H
	mov	ecx, DWORD PTR tv2288[esp+152]
	mov	DWORD PTR _gy$111139[esp+152], ecx
	jge	$LN43@RenderLigh
	test	ecx, ecx
	jl	$LN43@RenderLigh

; 1169 : 				y = nLightGridCenterY - (r - 1) * LIGHTING_GRID_SIZEY;
; 1170 : 				pCurPos = &pLColor[gy * LIGHTING_GRID_WIDTH + gx];

	mov	ecx, DWORD PTR tv2328[esp+152]
	mov	edx, DWORD PTR _this$[esp+152]
	mov	ebp, DWORD PTR tv2330[esp+152]
	add	ecx, eax
	mov	eax, DWORD PTR [edx+73824]

; 1171 : 				for(j=0; j<(r * 2 - 1); j++)

	xor	edi, edi
	cmp	DWORD PTR tv2222[esp+152], edi
	lea	esi, DWORD PTR [eax+ecx*8]
	jle	$LN43@RenderLigh

; 1167 : 			{
; 1168 : 				x = nLightGridCenterX + r * LIGHTING_GRID_SIZEX;

	mov	ebx, DWORD PTR tv2386[esp+152]
$LL18@RenderLigh:

; 1172 : 				{
; 1173 : 					if(CanLighting(x, y, nLightPosX, nLightPosY))

	mov	ecx, DWORD PTR _nLightPosY$111125[esp+152]
	mov	edx, DWORD PTR _nLightPosX$111124[esp+152]
	mov	eax, DWORD PTR tv2226[esp+152]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+156]
	push	edx
	push	ebp
	push	eax
	call	?CanLighting@KIpoTree@@AAE_NHHHH@Z	; KIpoTree::CanLighting
	test	al, al
	je	$LN14@RenderLigh

; 1174 : 					{
; 1175 : 						//float f = 65536.0 - ((float)(
; 1176 : 						//    (
; 1177 : 						//        ((float)(x - nLightPosX)) * ((float)(x - nLightPosX)) + 
; 1178 : 						//        ((float)(y - nLightPosY)) * ((float)(y - nLightPosY))
; 1179 : 						//    ) * 
; 1180 : 						//    fLightRadiusDenom *
; 1181 : 						//    65536.0
; 1182 : 						//));
; 1183 : 						float f = 65536.0 - ((float)(
; 1184 : 							sqrt(double // Fixed By MrChuCong@gmail.com
; 1185 : 								(x - nLightPosX) * (x - nLightPosX) + 
; 1186 : 								(y - nLightPosY) * (y - nLightPosY)
; 1187 : 							) * 
; 1188 : 							fLightRadiusDenom * 
; 1189 : 							65536.0
; 1190 : 						));

	mov	ecx, DWORD PTR tv2226[esp+152]
	sub	ecx, DWORD PTR _nLightPosX$111124[esp+152]
	mov	edx, ebx
	imul	edx, ebx

; 1191 : 
; 1192 : 						uDistance65536 = (int)(f);

	mov	DWORD PTR tv4863[esp+152], ecx
	fild	DWORD PTR tv4863[esp+152]
	mov	DWORD PTR tv4859[esp+152], edx
	fild	DWORD PTR tv4859[esp+152]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fmul	DWORD PTR _fLightRadiusDenom$111141[esp+152]
	fld	QWORD PTR __real@40f0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fnstcw	WORD PTR tv4847[esp+152]
	movzx	eax, WORD PTR tv4847[esp+152]
	fstp	DWORD PTR tv4852[esp+152]
	fsub	DWORD PTR tv4852[esp+152]
	or	eax, 3072				; 00000c00H
	fstp	DWORD PTR tv4848[esp+152]
	fld	DWORD PTR tv4848[esp+152]
	mov	DWORD PTR tv4844[esp+152], eax
	fldcw	WORD PTR tv4844[esp+152]
	fistp	QWORD PTR tv4842[esp+152]
	mov	eax, DWORD PTR tv4842[esp+152]

; 1193 : 
; 1194 : 						if (((int)uDistance65536) > 0)

	test	eax, eax
	fldcw	WORD PTR tv4847[esp+152]
	jle	SHORT $LN14@RenderLigh

; 1195 : 						{
; 1196 : 							pCurPos->r += (ur * uDistance65536 / 65536);

	mov	ecx, eax
	imul	ecx, DWORD PTR _ur$111132[esp+152]

; 1197 : 							pCurPos->g += (ug * uDistance65536 / 65536);

	mov	edx, eax

; 1198 : 							pCurPos->b += (ub * uDistance65536 / 65536);

	imul	eax, DWORD PTR _ub$111134[esp+152]
	imul	edx, DWORD PTR _ug$111133[esp+152]
	shr	ecx, 16					; 00000010H
	add	WORD PTR [esi], cx
	shr	edx, 16					; 00000010H
	add	WORD PTR [esi+2], dx
	shr	eax, 16					; 00000010H
	add	WORD PTR [esi+4], ax
$LN14@RenderLigh:

; 1199 : 						}
; 1200 : 					}
; 1201 : 
; 1202 : 					gy++;

	mov	eax, DWORD PTR _gy$111139[esp+152]
	add	eax, 1

; 1203 :                     if (gy >= LIGHTING_GRID_HEIGHT)

	cmp	eax, 96					; 00000060H
	mov	DWORD PTR _gy$111139[esp+152], eax
	jge	SHORT $LN43@RenderLigh
	add	edi, 1

; 1204 :                         break;
; 1205 : 
; 1206 : 					y += LIGHTING_GRID_SIZEX;

	add	ebp, 32					; 00000020H
	add	ebx, 32					; 00000020H

; 1207 : 					pCurPos += LIGHTING_GRID_WIDTH;

	add	esi, 384				; 00000180H
	cmp	edi, DWORD PTR tv2222[esp+152]
	jl	$LL18@RenderLigh
$LN43@RenderLigh:

; 1002 :         //fLightRadiusDenom *= fLightRadiusDenom;
; 1003 :         unsigned int uDistance65536 = 0;
; 1004 :         KLColor *pCurPos = NULL;
; 1005 : 
; 1006 : 		
; 1007 : 		gy = nLightGridY - (nGridRadius - 1);
; 1008 : 		// 从中心点向外扩展计算光照强度
; 1009 : 		for(int r = 0; r < nGridRadius; r++)

	mov	eax, DWORD PTR _r$111145[esp+152]
	add	DWORD PTR tv2222[esp+152], 2
	mov	ecx, 48					; 00000030H
	add	DWORD PTR tv2234[esp+152], ecx
	sub	DWORD PTR tv2328[esp+152], ecx
	mov	edx, 1
	add	DWORD PTR tv2140[esp+152], edx
	sub	DWORD PTR tv2230[esp+152], edx
	sub	DWORD PTR tv2288[esp+152], edx
	mov	ecx, 32					; 00000020H
	add	DWORD PTR tv2226[esp+152], ecx
	sub	DWORD PTR tv2290[esp+152], ecx
	sub	DWORD PTR tv2332[esp+152], ecx
	sub	DWORD PTR tv2330[esp+152], ecx
	sub	DWORD PTR tv2386[esp+152], ecx
	add	eax, edx
	cmp	eax, DWORD PTR _nGridRadius$111140[esp+152]
	mov	DWORD PTR _r$111145[esp+152], eax
	jl	$LL160@RenderLigh
$LN48@RenderLigh:

; 968  : 	}
; 969  : 
; 970  : 	list<KLightBase*>::iterator i;
; 971  : 	// 计算每一个光源的光照结果
; 972  : 	for (i = m_LightList.begin(); i != m_LightList.end(); ++i)

	mov	eax, DWORD PTR _this$[esp+152]
	mov	esi, DWORD PTR _i$[esp+156]
	add	eax, 92272				; 00016870H
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LN87@RenderLigh
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN87@RenderLigh:
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR _this$[esp+152]
	mov	DWORD PTR _i$[esp+156], eax
	mov	ebx, eax
	jmp	$LL91@RenderLigh
$LN47@RenderLigh:

; 1208 : 				}
; 1209 : 			}
; 1210 : 		}
; 1211 : 	}
; 1212 : 
; 1213 :     //memcpy(ptp, pLColor, sizeof(ptp));
; 1214 : 
; 1215 :     
; 1216 : 	// 对光照图进行过滤，使阴影边沿平滑
; 1217 :     
; 1218 : 
; 1219 : 	int m;
; 1220 :     int n;
; 1221 :     DWORD   *pdwLight;
; 1222 :     KLColor *pO, *pL, *pR, *pU, *pD, *pDest;
; 1223 :     int nIdx = 1 * LIGHTING_GRID_WIDTH + 1;

	add	esi, 74036				; 00012134H
	mov	DWORD PTR tv4754[esp+152], 392		; 00000188H
	mov	DWORD PTR tv4874[esp+152], esi
	mov	DWORD PTR tv4779[esp+152], 94		; 0000005eH
	npad	9
$LL12@RenderLigh:

; 1224 : 	for(m=1; m<LIGHTING_GRID_HEIGHT-1;m++)
; 1225 : 	{
; 1226 : 		pDest = ptp + nIdx;

	mov	edx, DWORD PTR _this$[esp+152]

; 1227 :         pdwLight = pLightingArray + nIdx;

	mov	esi, DWORD PTR tv4874[esp+152]
	mov	eax, DWORD PTR tv4754[esp+152]
	mov	ecx, DWORD PTR [edx+73832]
	mov	DWORD PTR _pdwLight$[esp+152], esi

; 1228 : 		pO = pLColor + nIdx;

	mov	esi, DWORD PTR [edx+73824]
	add	ecx, eax
	add	esi, eax

; 1229 : 		pL = pO - 1;

	lea	edi, DWORD PTR [esi-8]

; 1230 : 		pR = pO + 1;
; 1231 : 		pU = pO - LIGHTING_GRID_WIDTH;

	lea	ebx, DWORD PTR [esi-384]

; 1232 : 		pD = pO + LIGHTING_GRID_WIDTH;

	lea	ebp, DWORD PTR [esi+384]
	mov	DWORD PTR tv2662[esp+152], 23		; 00000017H
$LL9@RenderLigh:

; 1233 : 		for(n=1; n<LIGHTING_GRID_WIDTH-1;n++)
; 1234 : 		{
; 1235 : 			//pDest->r = (pO->r + pR->r + pL->r + pU->r + pD->r) / 5;
; 1236 : 			//pDest->g = (pO->g + pR->g + pL->g + pU->g + pD->g) / 5;
; 1237 : 			//pDest->b = (pO->b + pR->b + pL->b + pU->b + pD->b) / 5;
; 1238 : 			//pDest->r = (pO->r + pR->r + pL->r + (pU->r + pD->r) / 2) / 4;
; 1239 : 			//pDest->g = (pO->g + pR->g + pL->g + (pU->g + pD->g) / 2) / 4;
; 1240 : 			//pDest->b = (pO->b + pR->b + pL->b + (pU->b + pD->b) / 2) / 4;
; 1241 : 			//pDest->r = (pO->r + (pR->r + pL->r) / 2 + pU->r + pD->r) / 4;
; 1242 : 			//pDest->g = (pO->g + (pR->g + pL->g) / 2 + pU->g + pD->g) / 4;
; 1243 : 			//pDest->b = (pO->b + (pR->b + pL->b) / 2 + pU->b + pD->b) / 4;
; 1244 : 			
; 1245 :             pDest->r = (pO->r + pL->r + pU->r + pD->r) / 4;

	movzx	edx, WORD PTR [ebx]
	movzx	eax, WORD PTR [ebp]
	add	eax, edx
	movzx	edx, WORD PTR [edi]
	add	eax, edx
	movzx	edx, WORD PTR [esi]
	add	eax, edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	WORD PTR [ecx], ax

; 1246 : 		    pDest->g = (pO->g + pL->g + pU->g + pD->g) / 4;

	movzx	edx, WORD PTR [ebx+2]
	movzx	eax, WORD PTR [ebp+2]
	add	eax, edx
	movzx	edx, WORD PTR [edi+2]
	add	eax, edx
	movzx	edx, WORD PTR [esi+2]
	add	eax, edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	WORD PTR [ecx+2], ax

; 1247 : 			pDest->b = (pO->b + pL->b + pU->b + pD->b) / 4;

	movzx	edx, WORD PTR [ebx+4]
	movzx	eax, WORD PTR [ebp+4]
	add	eax, edx
	movzx	edx, WORD PTR [edi+4]
	add	eax, edx
	movzx	edx, WORD PTR [esi+4]
	add	eax, edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv1440[esp+152], eax
	mov	WORD PTR [ecx+4], ax

; 1248 : 
; 1249 :             *pdwLight = 0xff000000 |
; 1250 :                 (((pDest->r > 0xff) ? 0xff : pDest->r) << 16) |
; 1251 :                 (((pDest->g > 0xff) ? 0xff : pDest->g) << 8) |
; 1252 :                 (((pDest->b > 0xff) ? 0xff : pDest->b));

	movzx	eax, WORD PTR [ecx]
	cmp	ax, 255					; 000000ffH
	mov	edx, 255				; 000000ffH
	ja	SHORT $LN56@RenderLigh
	movzx	edx, ax
$LN56@RenderLigh:
	movzx	eax, WORD PTR [ecx+2]
	cmp	ax, 255					; 000000ffH
	jbe	SHORT $LN57@RenderLigh
	mov	DWORD PTR tv576[esp+152], 255		; 000000ffH
	jmp	SHORT $LN58@RenderLigh
$LN57@RenderLigh:
	movzx	eax, ax
	mov	DWORD PTR tv576[esp+152], eax
$LN58@RenderLigh:
	mov	eax, DWORD PTR tv1440[esp+152]
	cmp	ax, 255					; 000000ffH
	jbe	SHORT $LN59@RenderLigh
	mov	DWORD PTR tv584[esp+152], 255		; 000000ffH
	jmp	SHORT $LN60@RenderLigh
$LN59@RenderLigh:
	movzx	eax, ax
	mov	DWORD PTR tv584[esp+152], eax
$LN60@RenderLigh:
	mov	eax, DWORD PTR _pdwLight$[esp+152]
	or	edx, -256				; ffffff00H
	shl	edx, 8
	or	edx, DWORD PTR tv576[esp+152]
	shl	edx, 8
	or	edx, DWORD PTR tv584[esp+152]
	mov	DWORD PTR [eax], edx
	movzx	edx, WORD PTR [ebx+8]
	movzx	eax, WORD PTR [ebp+8]
	add	eax, edx
	movzx	edx, WORD PTR [edi+8]
	add	eax, edx
	movzx	edx, WORD PTR [esi+8]
	add	eax, edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	WORD PTR [ecx+8], ax
	movzx	edx, WORD PTR [ebx+10]
	movzx	eax, WORD PTR [ebp+10]
	add	eax, edx
	movzx	edx, WORD PTR [edi+10]
	add	eax, edx
	movzx	edx, WORD PTR [esi+10]
	add	eax, edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	WORD PTR [ecx+10], ax
	movzx	edx, WORD PTR [ebx+12]
	movzx	eax, WORD PTR [ebp+12]
	add	eax, edx
	movzx	edx, WORD PTR [edi+12]
	add	eax, edx
	movzx	edx, WORD PTR [esi+12]
	add	eax, edx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR tv1521[esp+152], eax
	mov	WORD PTR [ecx+12], ax
	movzx	eax, WORD PTR [ecx+8]
	cmp	ax, 255					; 000000ffH
	mov	edx, 255				; 000000ffH
	ja	SHORT $LN151@RenderLigh
	movzx	edx, ax
$LN151@RenderLigh:
	movzx	eax, WORD PTR [ecx+10]
	cmp	ax, 255					; 000000ffH
	jbe	SHORT $LN152@RenderLigh
	mov	DWORD PTR tv576[esp+152], 255		; 000000ffH
	jmp	SHORT $LN153@RenderLigh
$LN152@RenderLigh:
	movzx	eax, ax
	mov	DWORD PTR tv576[esp+152], eax
$LN153@RenderLigh:
	mov	eax, DWORD PTR tv1521[esp+152]
	cmp	ax, 255					; 000000ffH
	jbe	SHORT $LN154@RenderLigh
	mov	DWORD PTR tv584[esp+152], 255		; 000000ffH
	jmp	SHORT $LN155@RenderLigh
$LN154@RenderLigh:
	movzx	eax, ax
	mov	DWORD PTR tv584[esp+152], eax
$LN155@RenderLigh:
	mov	eax, DWORD PTR _pdwLight$[esp+152]
	or	edx, -256				; ffffff00H
	shl	edx, 8
	or	edx, DWORD PTR tv576[esp+152]
	add	eax, 8
	shl	edx, 8
	or	edx, DWORD PTR tv584[esp+152]
	mov	DWORD PTR _pdwLight$[esp+152], eax
	mov	DWORD PTR [eax-4], edx
	mov	eax, 1
	add	ecx, 16					; 00000010H
	add	esi, 16					; 00000010H
	add	edi, 16					; 00000010H
	add	ebx, 16					; 00000010H
	add	ebp, 16					; 00000010H
	sub	DWORD PTR tv2662[esp+152], eax
	jne	$LL9@RenderLigh

; 1253 : 
; 1254 : 
; 1255 :             //pDest->r = pO->r;
; 1256 : 		    //pDest->g = pO->g;
; 1257 : 			//pDest->b = pO->b;
; 1258 : 
; 1259 : 			pDest++, pO++, pL++, pR++, pU++, pD++, pdwLight++;
; 1260 : 		}
; 1261 : 		nIdx += LIGHTING_GRID_WIDTH;

	add	DWORD PTR tv4874[esp+152], 192		; 000000c0H
	add	DWORD PTR tv4754[esp+152], 384		; 00000180H
	sub	DWORD PTR tv4779[esp+152], eax
	jne	$LL12@RenderLigh

; 1262 : 	}
; 1263 :     
; 1264 : 
; 1265 : 	// 将r，g，b的值限制在0xff之内，防止色彩错误
; 1266 : //	for(j = 0; j < LIGHTING_GRID_WIDTH * LIGHTING_GRID_HEIGHT; j++)
; 1267 : //	{
; 1268 : //        //pLightingArray[j] = 0xff000000 |
; 1269 : //        //    ((((-(ptp[j].r > 0xff)) | ptp[j].r) & 0xff) << 16) |
; 1270 : //        //    ((((-(ptp[j].g > 0xff)) | ptp[j].g) & 0xff) << 8) |
; 1271 : //        //    ((((-(ptp[j].b > 0xff)) | ptp[j].b) & 0xff));
; 1272 : //
; 1273 : //		//if(ptp[j].r > 0xff)
; 1274 : //		//	ptp[j].r = 0xff;
; 1275 : //        
; 1276 : //		//if(ptp[j].g > 0xff)
; 1277 : //		//	ptp[j].g = 0xff;
; 1278 : //		//if(ptp[j].b > 0xff)
; 1279 : //		//	ptp[j].b = 0xff;
; 1280 : //		//pLightingArray[j] = 0xff000000 | (ptp[j].r<<16) | (ptp[j].g<<8) | ptp[j].b;
; 1281 : //
; 1282 : //        pLightingArray[j] = 0xff000000 |
; 1283 : //            (((ptp[j].r > 0xff) ? 0xff : ptp[j].r) << 16) |
; 1284 : //            (((ptp[j].g > 0xff) ? 0xff : ptp[j].g) << 8) |
; 1285 : //            (((ptp[j].b > 0xff) ? 0xff : ptp[j].b));
; 1286 : //
; 1287 : //	}
; 1288 :     for (m = 0; m < LIGHTING_GRID_HEIGHT; m++)

	mov	eax, DWORD PTR _this$[esp+152]
	lea	ecx, DWORD PTR [eax+74028]
	mov	edx, 96					; 00000060H
	npad	1
$LL6@RenderLigh:

; 1289 :     {
; 1290 :         pLightingArray[m * LIGHTING_GRID_WIDTH + 0] = m_dwAmbient | 0xff000000;

	mov	esi, DWORD PTR [eax+92]
	or	esi, -16777216				; ff000000H
	mov	DWORD PTR [ecx-188], esi

; 1291 :         pLightingArray[m * LIGHTING_GRID_WIDTH + LIGHTING_GRID_WIDTH - 1] = m_dwAmbient | 0xff000000;

	mov	esi, DWORD PTR [eax+92]
	or	esi, -16777216				; ff000000H
	mov	DWORD PTR [ecx], esi
	add	ecx, 192				; 000000c0H
	sub	edx, 1
	jne	SHORT $LL6@RenderLigh

; 1292 :     }
; 1293 : 
; 1294 :     for (n = 0; n < LIGHTING_GRID_WIDTH; n++)

	lea	ecx, DWORD PTR [eax+92080]
	mov	edx, 48					; 00000030H
$LL3@RenderLigh:

; 1295 :     {
; 1296 :         pLightingArray[n] = m_dwAmbient | 0xff000000;

	mov	esi, DWORD PTR [eax+92]
	or	esi, -16777216				; ff000000H
	mov	DWORD PTR [ecx-18240], esi

; 1297 :         pLightingArray[(LIGHTING_GRID_HEIGHT - 1) * LIGHTING_GRID_WIDTH + n] = m_dwAmbient | 0xff000000;

	mov	esi, DWORD PTR [eax+92]
	or	esi, -16777216				; ff000000H
	mov	DWORD PTR [ecx], esi
	add	ecx, 4
	sub	edx, 1
	jne	SHORT $LL3@RenderLigh

; 1298 :     }
; 1299 :     //pLightingArray[0] = m_dwAmbient;    // 设置环境光
; 1300 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderLightMap@KIpoTree@@QAEXXZ ENDP			; KIpoTree::RenderLightMap
_TEXT	ENDS
PUBLIC	?EnableBioLights@KIpoTree@@QAEX_N@Z		; KIpoTree::EnableBioLights
; Function compile flags: /Ogtpy
;	COMDAT ?EnableBioLights@KIpoTree@@QAEX_N@Z
_TEXT	SEGMENT
$T115337 = -8						; size = 8
_bEnable$ = 8						; size = 1
?EnableBioLights@KIpoTree@@QAEX_N@Z PROC		; KIpoTree::EnableBioLights, COMDAT
; _this$ = ecx

; 1574 : 	m_bProcessBioLights = bEnable;

	mov	al, BYTE PTR _bEnable$[esp-4]
	sub	esp, 8

; 1575 : 
; 1576 : 	if(!bEnable)

	test	al, al
	mov	BYTE PTR [ecx+89], al
	jne	$LN2@EnableBioL

; 1577 : 	{
; 1578 : 		//清除所有内建对象的光源
; 1579 : 		list<KLightBase*>::iterator i;
; 1580 : 		for (i = m_LightList.begin(); i != m_LightList.end(); )

	mov	eax, DWORD PTR [ecx+92276]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [eax]
	lea	ebp, DWORD PTR [ecx+92272]
	push	edi
	mov	edi, ebp
	push	ebx
$LL3@EnableBioL:
	test	edi, edi
	mov	ebx, DWORD PTR [ebp+4]
	je	SHORT $LN43@EnableBioL
	cmp	edi, ebp
	je	SHORT $LN111@EnableBioL
$LN43@EnableBioL:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN111@EnableBioL:
	cmp	esi, ebx
	je	SHORT $LN116@EnableBioL

; 1581 : 		{
; 1582 : 			if((*i)->m_pParent == NULL)

	test	edi, edi
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	jne	SHORT $LN52@EnableBioL
	call	ebx
$LN52@EnableBioL:
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN50@EnableBioL
	call	ebx
$LN50@EnableBioL:
	mov	ecx, DWORD PTR [esi+8]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@EnableBioL

; 1583 : 			{
; 1584 : 				delete (*i);

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN60@EnableBioL
	call	ebx
$LN60@EnableBioL:
	mov	edx, DWORD PTR [esi+8]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1585 : 				i = m_LightList.erase(i);

	cmp	esi, DWORD PTR [edi+4]
	mov	DWORD PTR $T115337[esp+28], esi
	jne	SHORT $LN75@EnableBioL
	call	ebx
$LN75@EnableBioL:
	cmp	esi, DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR [esi]
	je	SHORT $LN68@EnableBioL
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ebx
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	push	esi
	mov	DWORD PTR [ecx+4], edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	add	DWORD PTR [ebp+8], -1
$LN68@EnableBioL:
	mov	esi, ebx

; 1586 : 				continue;

	jmp	SHORT $LL3@EnableBioL
$LN1@EnableBioL:

; 1587 : 			}
; 1588 : 			++i;

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN101@EnableBioL
	call	ebx
$LN101@EnableBioL:
	mov	esi, DWORD PTR [esi]

; 1589 : 		}

	jmp	SHORT $LL3@EnableBioL
$LN116@EnableBioL:
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp
$LN2@EnableBioL:

; 1590 : 	}
; 1591 : }

	add	esp, 8
	ret	4
?EnableBioLights@KIpoTree@@QAEX_N@Z ENDP		; KIpoTree::EnableBioLights
_TEXT	ENDS
PUBLIC	??1?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::~list<KLightBase *,std::allocator<KLightBase *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ??1?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::~list<KLightBase *,std::allocator<KLightBase *> >, COMDAT
; _this$ = ecx

; 515  : 		_Tidy();

	jmp	?_Tidy@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXXZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Tidy
??1?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::~list<KLightBase *,std::allocator<KLightBase *> >
_TEXT	ENDS
PUBLIC	?_Insert@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXV?$_Iterator@$00@12@ABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXV?$_Iterator@$00@12@ABQAVKLightBase@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
__Val$ = 16						; size = 4
?_Insert@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXV?$_Iterator@$00@12@ABQAVKLightBase@@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Insert, COMDAT
; _this$ = ecx

; 695  : 
; 696  :  #if _HAS_ITERATOR_DEBUGGING
; 697  : 		if (_Where._Mycont != this)
; 698  : 			_DEBUG_ERROR("list insert iterator outside range");
; 699  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 700  : 
; 701  : 		_Nodeptr _Pnode = _Where._Mynode();
; 702  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode

; 703  : 		_Incsize(1);

	push	1
	mov	ecx, edi
	mov	esi, eax
	call	?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Incsize

; 704  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [ebx+4], esi

; 705  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	edx, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [edx], esi
	pop	esi
	pop	ebx

; 706  : 		}

	ret	12					; 0000000cH
?_Insert@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXV?$_Iterator@$00@12@ABQAVKLightBase@@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Insert
_TEXT	ENDS
PUBLIC	??0?$_List_val@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@V?$allocator@PAVKLightBase@@@1@@Z ; std::_List_val<KLightBase *,std::allocator<KLightBase *> >::_List_val<KLightBase *,std::allocator<KLightBase *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_val@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@V?$allocator@PAVKLightBase@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@V?$allocator@PAVKLightBase@@@1@@Z PROC ; std::_List_val<KLightBase *,std::allocator<KLightBase *> >::_List_val<KLightBase *,std::allocator<KLightBase *> >, COMDAT
; _this$ = ecx

; 85   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 86   : 		}

	ret	4
??0?$_List_val@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@V?$allocator@PAVKLightBase@@@1@@Z ENDP ; std::_List_val<KLightBase *,std::allocator<KLightBase *> >::_List_val<KLightBase *,std::allocator<KLightBase *> >
_TEXT	ENDS
PUBLIC	??1KIpoTree@@QAE@XZ				; KIpoTree::~KIpoTree
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1KIpoTree@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1KIpoTree@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1KIpoTree@@QAE@XZ$1
__ehfuncinfo$??1KIpoTree@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1KIpoTree@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
xdata$x	ENDS
;	COMDAT ??1KIpoTree@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1KIpoTree@@QAE@XZ PROC				; KIpoTree::~KIpoTree, COMDAT
; _this$ = ecx

; 77   : {

	push	-1
	push	__ehhandler$??1KIpoTree@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR __$EHRec$[esp+36], 1

; 78   : 	Clear();

	call	?Clear@KIpoTree@@QAEXXZ			; KIpoTree::Clear

; 79   : 
; 80   :     if (m_pby_ptpBase)

	mov	eax, DWORD PTR [esi+73836]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN2@KIpoTree

; 81   :     {
; 82   :         delete []m_pby_ptpBase;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 83   :         m_pby_ptpBase = NULL;

	mov	DWORD PTR [esi+73836], edi

; 84   :         ptp = NULL;

	mov	DWORD PTR [esi+73832], edi
$LN2@KIpoTree:

; 85   :     }
; 86   : 
; 87   :     if (m_pbyLColorBase)

	mov	eax, DWORD PTR [esi+73828]
	cmp	eax, edi
	je	SHORT $LN1@KIpoTree

; 88   :     {
; 89   :         delete []m_pbyLColorBase;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 90   :         m_pbyLColorBase = NULL;

	mov	DWORD PTR [esi+73828], edi

; 91   : 
; 92   :         pLColor = NULL;

	mov	DWORD PTR [esi+73824], edi
$LN1@KIpoTree:

; 93   :     }
; 94   : }

	lea	ecx, DWORD PTR [esi+92272]
	call	?_Tidy@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXXZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Tidy
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1KIpotBranch@@QAE@XZ			; KIpotBranch::~KIpotBranch
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1KIpoTree@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1KIpotBranch@@QAE@XZ			; KIpotBranch::~KIpotBranch
__unwindfunclet$??1KIpoTree@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92272				; 00016870H
	jmp	??1?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::~list<KLightBase *,std::allocator<KLightBase *> >
__ehhandler$??1KIpoTree@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1KIpoTree@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1KIpoTree@@QAE@XZ ENDP				; KIpoTree::~KIpoTree
PUBLIC	?Paint@KIpoTree@@QAEXPAUtagRECT@@W4IPOT_RENDER_LAYER@@@Z ; KIpoTree::Paint
EXTRN	?PaintObjectLayer@KIpotBranch@@QAEXPAUtagRECT@@@Z:PROC ; KIpotBranch::PaintObjectLayer
EXTRN	?PaintNoneObjectLayer@KIpotBranch@@QAEXPAUtagRECT@@H@Z:PROC ; KIpotBranch::PaintNoneObjectLayer
EXTRN	?g_pRepresent@@3PAUiRepresentShell@@A:DWORD	; g_pRepresent
; Function compile flags: /Ogtpy
;	COMDAT ?Paint@KIpoTree@@QAEXPAUtagRECT@@W4IPOT_RENDER_LAYER@@@Z
_TEXT	SEGMENT
_pRepresentArea$ = 8					; size = 4
_eLayer$ = 12						; size = 4
?Paint@KIpoTree@@QAEXPAUtagRECT@@W4IPOT_RENDER_LAYER@@@Z PROC ; KIpoTree::Paint, COMDAT
; _this$ = ecx

; 98   : {

	push	esi
	push	edi

; 99   : 	if(eLayer == IPOT_RL_COVER_GROUND && m_bDynamicLighting)

	mov	edi, DWORD PTR _eLayer$[esp+4]
	cmp	edi, 1
	mov	esi, ecx
	jne	SHORT $LN7@Paint
	cmp	BYTE PTR [esi+90], 0
	je	SHORT $LN6@Paint

; 100  : 	{
; 101  : 		// 渲染光照图
; 102  : 		RenderLightMap();

	call	?RenderLightMap@KIpoTree@@QAEXXZ	; KIpoTree::RenderLightMap

; 103  : 		// 设置表现模块的光照信息
; 104  : 		g_pRepresent->SetLightInfo(m_nLeftTopX, m_nLeftTopY, (unsigned int*)pLightingArray);

	mov	ecx, DWORD PTR ?g_pRepresent@@3PAUiRepresentShell@@A ; g_pRepresent
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+104]
	lea	edx, DWORD PTR [esi+73840]
	push	edx
	mov	edx, DWORD PTR [esi+80]
	push	edx
	mov	edx, DWORD PTR [esi+76]
	push	edx
	call	eax
$LN6@Paint:

; 113  : 	}
; 114  : 	else if (m_pMainBranch)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx

; 115  : 		m_pMainBranch->PaintNoneObjectLayer(pRepresentArea, eLayer);

	push	edi
	je	SHORT $LN2@Paint
	mov	edx, DWORD PTR _pRepresentArea$[esp+8]
	push	edx

; 116  : 	else
; 117  : 		m_DefaultBranch.PaintNoneObjectLayer(pRepresentArea, eLayer);

	call	?PaintNoneObjectLayer@KIpotBranch@@QAEXPAUtagRECT@@H@Z ; KIpotBranch::PaintNoneObjectLayer
	pop	edi
	pop	esi

; 118  : }

	ret	8
$LN7@Paint:

; 105  : 	}
; 106  : 	
; 107  : 	if (eLayer == IPOT_RL_OBJECT)

	cmp	edi, 2
	jne	SHORT $LN6@Paint

; 108  : 	{
; 109  : 		if (m_pMainBranch)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@Paint

; 110  : 			m_pMainBranch->PaintObjectLayer(pRepresentArea);

	mov	edx, DWORD PTR _pRepresentArea$[esp+4]
	push	edx
	call	?PaintObjectLayer@KIpotBranch@@QAEXPAUtagRECT@@@Z ; KIpotBranch::PaintObjectLayer
	pop	edi
	pop	esi

; 118  : }

	ret	8
$LN5@Paint:

; 111  : 		else
; 112  : 			m_DefaultBranch.PaintObjectLayer(pRepresentArea);

	mov	eax, DWORD PTR _pRepresentArea$[esp+4]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?PaintObjectLayer@KIpotBranch@@QAEXPAUtagRECT@@@Z ; KIpotBranch::PaintObjectLayer
	pop	edi
	pop	esi

; 118  : }

	ret	8
$LN2@Paint:

; 116  : 	else
; 117  : 		m_DefaultBranch.PaintNoneObjectLayer(pRepresentArea, eLayer);

	mov	eax, DWORD PTR _pRepresentArea$[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?PaintNoneObjectLayer@KIpotBranch@@QAEXPAUtagRECT@@H@Z ; KIpotBranch::PaintNoneObjectLayer
	pop	edi
	pop	esi

; 118  : }

	ret	8
?Paint@KIpoTree@@QAEXPAUtagRECT@@W4IPOT_RENDER_LAYER@@@Z ENDP ; KIpoTree::Paint
_TEXT	ENDS
PUBLIC	??0?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::list<KLightBase *,std::allocator<KLightBase *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\list
;	COMDAT ??0?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::list<KLightBase *,std::allocator<KLightBase *> >, COMDAT
; _this$ = ecx

; 430  : 		{	// construct empty list

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0

; 431  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::list<KLightBase *,std::allocator<KLightBase *> >
_TEXT	ENDS
PUBLIC	?push_back@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXABQAVKLightBase@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXABQAVKLightBase@@@Z PROC ; std::list<KLightBase *,std::allocator<KLightBase *> >::push_back, COMDAT
; _this$ = ecx

; 654  : 		_Insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Incsize
	mov	DWORD PTR [edi+4], ebx
	mov	edx, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ebx
	pop	ebx

; 655  : 		}

	ret	4
?push_back@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXABQAVKLightBase@@@Z ENDP ; std::list<KLightBase *,std::allocator<KLightBase *> >::push_back
_TEXT	ENDS
PUBLIC	??0KIpoTree@@QAE@XZ				; KIpoTree::KIpoTree
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0KIpoTree@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0KIpoTree@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0KIpoTree@@QAE@XZ$1
__ehfuncinfo$??0KIpoTree@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0KIpoTree@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
xdata$x	ENDS
;	COMDAT ??0KIpoTree@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0KIpoTree@@QAE@XZ PROC				; KIpoTree::KIpoTree, COMDAT
; _this$ = ecx

; 51   : {

	push	-1
	push	__ehhandler$??0KIpoTree@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+32], esi
	lea	ecx, DWORD PTR [esi+4]
	call	??0KIpotBranch@@QAE@XZ			; KIpotBranch::KIpotBranch
	lea	edi, DWORD PTR [esi+92272]
	xor	ebx, ebx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	call	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], ebx
	mov	al, 1

; 52   : 	m_pMainBranch = NULL;
; 53   : 	m_bProcessBioLights = true;

	mov	BYTE PTR [esi+89], al

; 54   : 	m_bDynamicLighting = true;

	mov	BYTE PTR [esi+90], al
	mov	DWORD PTR [esi], ebx

; 55   : 	m_nCurrentTime = 0;

	mov	DWORD PTR [esi+84], ebx

; 56   : 	m_bIsIndoor = false;

	mov	BYTE PTR [esi+88], bl

; 57   : 	m_dwAmbient = 0xff000000;

	mov	DWORD PTR [esi+92], -16777216		; ff000000H
	mov	BYTE PTR __$EHRec$[esp+40], al

; 58   : 	memset(&m_PermanentLeaf, 0, sizeof(m_PermanentLeaf));

	xor	eax, eax
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], eax
	mov	DWORD PTR [esi+64], eax
	mov	DWORD PTR [esi+68], eax

; 59   : 
; 60   :     ptrdiff_t ulAddress;
; 61   : 
; 62   :     m_pbyLColorBase = new unsigned char [(sizeof(KLColor) * LIGHTING_GRID_WIDTH * LIGHTING_GRID_HEIGHT) + 255];

	push	37119					; 000090ffH
	mov	DWORD PTR [esi+72], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+73828], eax

; 63   :     _ASSERT(m_pbyLColorBase);
; 64   :     ulAddress = (ptrdiff_t)m_pbyLColorBase;
; 65   :     ulAddress = (ulAddress + 255) / 256 * 256;

	add	eax, 255				; 000000ffH
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	shl	eax, 8

; 66   :     pLColor = (KLColor *)ulAddress;
; 67   : 
; 68   :     m_pby_ptpBase = new unsigned char [(sizeof(KLColor) * LIGHTING_GRID_WIDTH * LIGHTING_GRID_HEIGHT) + 255];

	push	37119					; 000090ffH
	mov	DWORD PTR [esi+73824], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+73836], eax

; 69   :     _ASSERT(m_pby_ptpBase);
; 70   :     ulAddress = (ptrdiff_t)m_pby_ptpBase;
; 71   :     ulAddress = (ulAddress + 255) / 256 * 256;

	add	eax, 255				; 000000ffH
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	add	esp, 8
	shl	eax, 8

; 72   :     ptp = (KLColor *)ulAddress;

	mov	DWORD PTR [esi+73832], eax

; 73   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0KIpoTree@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1KIpotBranch@@QAE@XZ			; KIpotBranch::~KIpotBranch
__unwindfunclet$??0KIpoTree@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92272				; 00016870H
	jmp	??1?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAE@XZ ; std::list<KLightBase *,std::allocator<KLightBase *> >::~list<KLightBase *,std::allocator<KLightBase *> >
__ehhandler$??0KIpoTree@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-16]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0KIpoTree@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0KIpoTree@@QAE@XZ ENDP				; KIpoTree::KIpoTree
PUBLIC	__real@4076800000000000
PUBLIC	?AddLeafPoint@KIpoTree@@QAEXPAUKIpotLeaf@@@Z	; KIpoTree::AddLeafPoint
EXTRN	?IsPlayer@KNpc@@QAEHXZ:PROC			; KNpc::IsPlayer
EXTRN	?Npc@@3PAVKNpc@@A:BYTE				; Npc
EXTRN	?CoreGetGameObjLightInfo@@YAXIIPAUKLightInfo@@@Z:PROC ; CoreGetGameObjLightInfo
;	COMDAT __real@4076800000000000
; File e:\x-project\#2.jx\source\sources\core\src\scene\scenedatadef.h
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
CONST	ENDS
;	COMDAT ?AddLeafPoint@KIpoTree@@QAEXPAUKIpotLeaf@@@Z
_TEXT	SEGMENT
_pLight$110926 = -32					; size = 4
_color$110943 = -28					; size = 8
_lightInfo$110930 = -20					; size = 20
tv351 = 8						; size = 4
_f$110942 = 8						; size = 4
_n$110936 = 8						; size = 4
_pLeaf$ = 8						; size = 4
?AddLeafPoint@KIpoTree@@QAEXPAUKIpotLeaf@@@Z PROC	; KIpoTree::AddLeafPoint, COMDAT
; _this$ = ecx

; 230  : {

	sub	esp, 32					; 00000020H
	push	ebp
	mov	ebp, ecx

; 231  : 	if (m_pMainBranch)

	mov	ecx, DWORD PTR [ebp]
	test	ecx, ecx
	push	edi

; 232  : 		m_pMainBranch->AddLeafPoint(pLeaf);

	mov	edi, DWORD PTR _pLeaf$[esp+36]
	push	edi

; 233  : 	else

	jne	SHORT $LN28@AddLeafPoi

; 234  : 		m_DefaultBranch.AddLeafPoint(pLeaf);

	lea	ecx, DWORD PTR [ebp+4]
$LN28@AddLeafPoi:
	call	?AddLeafPoint@KIpotBranch@@QAEXPAUKIpotLeaf@@@Z ; KIpotBranch::AddLeafPoint

; 235  : 	// 
; 236  : 	if (pLeaf->eLeafType == KIpotLeaf::IPOTL_T_RUNTIME_OBJ)

	cmp	DWORD PTR [edi], 1
	jne	$LN1@AddLeafPoi

; 237  : 	{
; 238  : 		KIpotRuntimeObj* pRtoLeaf = (KIpotRuntimeObj*)pLeaf;
; 239  : 		if (pRtoLeaf->eLayerParam & IPOT_RL_LIGHT_PROP)

	test	BYTE PTR [edi+36], 8
	je	$LN1@AddLeafPoi
	push	esi

; 240  : 		{
; 241  : 			// 增加一个光源
; 242  : 			KLightBase *pLight = new KLightBase;

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	$LN27@AddLeafPoi
	mov	DWORD PTR [esi], OFFSET ??_7KLightBase@@6B@

; 243  : 			if(pLight)
; 244  : 			{
; 245  : 				KLightInfo lightInfo;
; 246  : 				CoreGetGameObjLightInfo(pRtoLeaf->uGenre, pRtoLeaf->nId, &lightInfo);

	mov	ecx, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR _lightInfo$110930[esp+44]
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR _pLight$110926[esp+56], esi
	call	?CoreGetGameObjLightInfo@@YAXIIPAUKLightInfo@@@Z ; CoreGetGameObjLightInfo

; 247  : 				pLight->m_dwColor = lightInfo.dwColor;

	mov	eax, DWORD PTR _lightInfo$110930[esp+68]
	mov	DWORD PTR [esi+20], eax

; 248  : 				pLight->m_oPosition = lightInfo.oPosition;

	mov	ecx, DWORD PTR _lightInfo$110930[esp+56]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR _lightInfo$110930[esp+60]
	mov	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR _lightInfo$110930[esp+64]
	mov	DWORD PTR [esi+16], eax

; 249  : 				pLight->m_nRadius = lightInfo.nRadius;

	mov	ecx, DWORD PTR _lightInfo$110930[esp+72]
	mov	DWORD PTR [esi+24], ecx
	add	esp, 12					; 0000000cH

; 250  : 				pLight->m_pParent = pLeaf;

	mov	DWORD PTR [esi+4], edi

; 251  : 				
; 252  : 				if (pRtoLeaf->uGenre == CGOG_NPC && Npc[pRtoLeaf->nId].IsPlayer())

	cmp	DWORD PTR [edi+24], 6
	jne	$LN26@AddLeafPoi
	mov	ecx, DWORD PTR [edi+28]
	imul	ecx, 30432				; 000076e0H
	add	ecx, OFFSET ?Npc@@3PAVKNpc@@A		; Npc
	call	?IsPlayer@KNpc@@QAEHXZ			; KNpc::IsPlayer
	test	eax, eax
	je	$LN26@AddLeafPoi

; 253  : 				{
; 254  : 					pLight->m_dwColor = 0xffffffff;

	mov	DWORD PTR [esi+20], -1

; 255  : 					if(m_bIsIndoor)

	cmp	BYTE PTR [ebp+88], 0
	je	SHORT $LN11@AddLeafPoi

; 256  : 					{
; 257  : 						if(m_dwAmbient == 0xff404040)

	mov	edx, DWORD PTR [ebp+92]
	sub	edx, -12566464				; ff404040H
	neg	edx
	sbb	edx, edx
	and	edx, 320				; 00000140H
	mov	DWORD PTR [esi+24], edx

; 258  : 							pLight->m_nRadius = 0;
; 259  : 						else
; 260  : 							pLight->m_nRadius = MAIN_PLAYER_LIGHT_RADIUS;
; 261  : 					}
; 262  : 					else

	jmp	$LN26@AddLeafPoi
$LN11@AddLeafPoi:

; 263  : 					{
; 264  : 						// 是主角，按时间调整光源亮度
; 265  : 						int n = 0;
; 266  : 						if(m_nCurrentTime >= 480 && m_nCurrentTime <= 960)

	mov	ecx, DWORD PTR [ebp+84]
	xor	eax, eax
	cmp	ecx, 480				; 000001e0H
	mov	DWORD PTR _n$110936[esp+40], eax
	jl	SHORT $LN30@AddLeafPoi
	cmp	ecx, 960				; 000003c0H
	jg	SHORT $LN7@AddLeafPoi

; 267  : 							pLight->m_nRadius = 0;

	mov	DWORD PTR [esi+24], eax
	jmp	SHORT $LN3@AddLeafPoi
$LN7@AddLeafPoi:

; 268  : 						else if(m_nCurrentTime < 480)

	cmp	ecx, 480				; 000001e0H
	jge	SHORT $LN5@AddLeafPoi
$LN30@AddLeafPoi:

; 269  : 						{
; 270  : 							n = 480 - m_nCurrentTime;

	mov	eax, 480				; 000001e0H
	sub	eax, ecx

; 271  : 							pLight->m_nRadius = MAIN_PLAYER_LIGHT_RADIUS;
; 272  : 						}
; 273  : 						else

	jmp	SHORT $LN31@AddLeafPoi
$LN5@AddLeafPoi:

; 274  : 						{
; 275  : 							n = m_nCurrentTime - 960;

	lea	eax, DWORD PTR [ecx-960]
$LN31@AddLeafPoi:

; 276  : 							pLight->m_nRadius = MAIN_PLAYER_LIGHT_RADIUS;
; 277  : 						}
; 278  : 
; 279  : 						if(n > 360)

	cmp	eax, 360				; 00000168H
	mov	DWORD PTR [esi+24], 320			; 00000140H
	mov	DWORD PTR _n$110936[esp+40], eax
	jle	SHORT $LN3@AddLeafPoi

; 280  : 							n = 360;

	mov	DWORD PTR _n$110936[esp+40], 360	; 00000168H
$LN3@AddLeafPoi:

; 281  : 						float f = n / 360.0f;

	fild	DWORD PTR _n$110936[esp+40]

; 282  : 						f = f * f;
; 283  : 						KLColor color;
; 284  : 						color.SetColor(pLight->m_dwColor);

	mov	eax, DWORD PTR [esi+20]
	push	eax
	lea	ecx, DWORD PTR _color$110943[esp+48]
	fdiv	QWORD PTR __real@4076800000000000
	fstp	DWORD PTR _f$110942[esp+44]
	call	?SetColor@KLColor@@QAEXK@Z		; KLColor::SetColor
	fld	DWORD PTR _f$110942[esp+40]
	fmul	ST(0), ST(0)

; 285  : 						color.Scale(f);

	push	ecx
	lea	ecx, DWORD PTR _color$110943[esp+48]
	fstp	DWORD PTR tv351[esp+44]
	fld	DWORD PTR tv351[esp+44]
	fstp	DWORD PTR [esp]
	call	?Scale@KLColor@@QAEXM@Z			; KLColor::Scale

; 286  : 						pLight->m_dwColor = color.GetColor();

	movzx	ecx, WORD PTR _color$110943[esp+44]
	movzx	edx, WORD PTR _color$110943[esp+46]
	movzx	eax, WORD PTR _color$110943[esp+48]
	or	ecx, -256				; ffffff00H
	shl	ecx, 8
	or	ecx, edx
	shl	ecx, 8
	or	ecx, eax
	mov	DWORD PTR [esi+20], ecx
$LN26@AddLeafPoi:

; 287  : 					}
; 288  : 				}
; 289  : 
; 290  : 				pLight->m_nRadius = MAIN_PLAYER_LIGHT_RADIUS;

	mov	DWORD PTR [esi+24], 320			; 00000140H

; 291  : 				pLight->m_dwColor = 0xff808080;

	mov	DWORD PTR [esi+20], -8355712		; ff808080H

; 292  : 
; 293  : 				if(pLight->m_nRadius)

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN2@AddLeafPoi

; 294  :                 {
; 295  : 					m_LightList.push_back(pLight);

	lea	ecx, DWORD PTR _pLight$110926[esp+44]
	push	ecx
	lea	ecx, DWORD PTR [ebp+92272]
	call	?push_back@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@QAEXABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::push_back
	pop	esi
	pop	edi
	pop	ebp

; 300  :                     pLight = NULL;
; 301  :                 }
; 302  : 			}
; 303  : 		}
; 304  : 	}
; 305  : }

	add	esp, 32					; 00000020H
	ret	4
$LN2@AddLeafPoi:

; 296  :                 }
; 297  :                 else
; 298  :                 {
; 299  :                     delete pLight;

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@AddLeafPoi:
	pop	esi
$LN1@AddLeafPoi:
	pop	edi
	pop	ebp

; 300  :                     pLight = NULL;
; 301  :                 }
; 302  : 			}
; 303  : 		}
; 304  : 	}
; 305  : }

	add	esp, 32					; 00000020H
	ret	4
?AddLeafPoint@KIpoTree@@QAEXPAUKIpotLeaf@@@Z ENDP	; KIpoTree::AddLeafPoint
_TEXT	ENDS
PUBLIC	__real@4055e00000000000
PUBLIC	?AddBuildinLight@KIpoTree@@QAEXPAUKBuildInLightInfo@@H@Z ; KIpoTree::AddBuildinLight
EXTRN	__imp_?g_Random@@YAII@Z:PROC
;	COMDAT __real@4055e00000000000
; File c:\program files\microsoft visual studio 8\vc\include\list
CONST	SEGMENT
__real@4055e00000000000 DQ 04055e00000000000r	; 87.5
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\scene\kipotree.cpp
CONST	ENDS
;	COMDAT ?AddBuildinLight@KIpoTree@@QAEXPAUKBuildInLightInfo@@H@Z
_TEXT	SEGMENT
tv262 = -12						; size = 4
_nMinRange$ = -8					; size = 4
_this$ = -4						; size = 4
tv549 = 8						; size = 4
_pLights$ = 8						; size = 4
tv611 = 12						; size = 4
$T115727 = 12						; size = 4
_nMaxRange$ = 12					; size = 4
_nCount$ = 12						; size = 4
?AddBuildinLight@KIpoTree@@QAEXPAUKBuildInLightInfo@@H@Z PROC ; KIpoTree::AddBuildinLight, COMDAT
; _this$ = ecx

; 1531 : {

	sub	esp, 12					; 0000000cH

; 1532 : 	if(!m_bProcessBioLights)

	cmp	BYTE PTR [ecx+89], 0
	mov	DWORD PTR _this$[esp+12], ecx
	je	$LN5@AddBuildin

; 1533 : 		return;
; 1534 : 
; 1535 : 	int nMinRange, nMaxRange;
; 1536 : 
; 1537 : 	for(int i=0; i<nCount; i++)

	mov	eax, DWORD PTR _nCount$[esp+8]
	test	eax, eax
	jle	$LN5@AddBuildin
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _pLights$[esp+24]
	add	edi, 20					; 00000014H
	mov	DWORD PTR tv549[esp+24], eax
	npad	4
$LL42@AddBuildin:

; 1538 : 	{
; 1539 : 		// 增加一个光源
; 1540 : 		KSelfBreathLight *pLight = new KSelfBreathLight;

	push	52					; 00000034H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	$LN6@AddBuildin
	mov	ecx, eax
	call	??0KSelfBreathLight@@QAE@XZ		; KSelfBreathLight::KSelfBreathLight
	mov	esi, eax

; 1541 : 		if(pLight)

	test	esi, esi
	je	$LN6@AddBuildin

; 1542 : 		{
; 1543 : 			// 保证nMaxRange大于nMinRange
; 1544 : 			if(pLights[i].nMaxRange >= pLights[i].nMinRange)

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi-4]
	cmp	ecx, edx
	jl	SHORT $LN3@AddBuildin

; 1545 : 				nMaxRange = pLights[i].nMaxRange, nMinRange = pLights[i].nMinRange;

	mov	eax, ecx
	mov	DWORD PTR _nMaxRange$[esp+24], eax
	mov	ecx, edx

; 1546 : 			else

	jmp	SHORT $LN2@AddBuildin
$LN3@AddBuildin:

; 1547 : 				nMaxRange = pLights[i].nMinRange, nMinRange = pLights[i].nMaxRange;

	mov	eax, edx
	mov	DWORD PTR _nMaxRange$[esp+24], edx
$LN2@AddBuildin:

; 1548 : 			// 半径为负值，忽略这个光源
; 1549 : 			if(nMinRange < 0)

	test	ecx, ecx
	jl	$LN6@AddBuildin

; 1550 : 			{
; 1551 : 				_ASSERT(0);
; 1552 : 				continue;
; 1553 : 			}
; 1554 : 
; 1555 : 			nMinRange = nMaxRange - 8;
; 1556 : 
; 1557 : 			pLight->m_dwColor = pLights[i].dwColor;

	mov	ecx, DWORD PTR [edi-8]

; 1558 : 			pLight->m_oPosition.nX = pLights[i].oPos.x;
; 1559 : 			pLight->m_oPosition.nY = pLights[i].oPos.y;
; 1560 : 			pLight->m_oPosition.nZ = pLights[i].oPos.z;
; 1561 : 			pLight->m_nRadius = nMinRange + g_Random(nMaxRange - nMinRange);

	mov	ebp, DWORD PTR __imp_?g_Random@@YAII@Z
	mov	DWORD PTR [esi+20], ecx
	mov	edx, DWORD PTR [edi-20]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [edi-16]
	lea	ebx, DWORD PTR [eax-8]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [edi-12]
	sub	eax, ebx
	push	eax
	mov	DWORD PTR _nMinRange$[esp+32], ebx
	mov	DWORD PTR [esi+16], edx
	call	ebp
	add	eax, ebx
	mov	DWORD PTR tv262[esp+32], eax

; 1562 : 			pLight->fRadius = (float)(pLight->m_nRadius);

	fild	DWORD PTR tv262[esp+32]

; 1563 : 			pLight->m_pParent = NULL;
; 1564 : 			pLight->fMaxRange = (float)nMaxRange;
; 1565 : 			pLight->fMinRange = (float)nMinRange;
; 1566 : 			pLight->fCycle = 100 * 0.875f + g_Random(60 / 4);

	push	15					; 0000000fH
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+4], 0
	fstp	DWORD PTR [esi+36]
	fild	DWORD PTR _nMaxRange$[esp+32]
	fstp	DWORD PTR [esi+32]
	fild	DWORD PTR _nMinRange$[esp+36]
	fstp	DWORD PTR [esi+28]
	call	ebp
	add	esp, 8
	test	eax, eax
	mov	DWORD PTR tv611[esp+24], eax
	fild	DWORD PTR tv611[esp+24]
	jge	SHORT $LN43@AddBuildin
	fadd	DWORD PTR __real@4f800000
$LN43@AddBuildin:
	fadd	QWORD PTR __real@4055e00000000000

; 1567 : 			m_LightList.push_back(pLight);

	mov	DWORD PTR $T115727[esp+24], esi
	lea	eax, DWORD PTR $T115727[esp+24]
	push	eax
	fstp	DWORD PTR [esi+40]
	mov	esi, DWORD PTR _this$[esp+32]
	mov	ebp, DWORD PTR [esi+92276]
	mov	ecx, DWORD PTR [ebp+4]
	add	esi, 92272				; 00016870H
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?_Buynode@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@2@PAU342@0ABQAVKLightBase@@@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@PAVKLightBase@@V?$allocator@PAVKLightBase@@@std@@@std@@IAEXI@Z ; std::list<KLightBase *,std::allocator<KLightBase *> >::_Incsize
	mov	DWORD PTR [ebp+4], ebx
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx], ebx
$LN6@AddBuildin:
	add	edi, 28					; 0000001cH
	sub	DWORD PTR tv549[esp+24], 1
	jne	$LL42@AddBuildin
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN5@AddBuildin:

; 1568 : 		}
; 1569 : 	}
; 1570 : }

	add	esp, 12					; 0000000cH
	ret	8
?AddBuildinLight@KIpoTree@@QAEXPAUKBuildInLightInfo@@H@Z ENDP ; KIpoTree::AddBuildinLight
_TEXT	ENDS
END
