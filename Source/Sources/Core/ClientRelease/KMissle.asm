; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	e:\X-Project\#2.JX\Source\Sources\Core\Src\KMissle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?g_CollisionMatrix@@3PAUTCollisionMatrix@@A	; g_CollisionMatrix
PUBLIC	?g_nRandMissleTab@@3PAHA			; g_nRandMissleTab
_BSS	SEGMENT
?g_nRandMissleTab@@3PAHA DD 064H DUP (?)		; g_nRandMissleTab
_BSS	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
	ORG $+4
?g_CollisionMatrix@@3PAUTCollisionMatrix@@A DD 00H	; g_CollisionMatrix
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	??4KMapMusic@@QAEAAV0@ABV0@@Z			; KMapMusic::operator=
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4KMapMusic@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4KMapMusic@@QAEAAV0@ABV0@@Z PROC			; KMapMusic::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	49404					; 0000c0fcH
	mov	esi, ecx
	push	eax
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	4
??4KMapMusic@@QAEAAV0@ABV0@@Z ENDP			; KMapMusic::operator=
_TEXT	ENDS
PUBLIC	?GetGameTime@KSubWorldSet@@QAEHXZ		; KSubWorldSet::GetGameTime
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\ksubworldset.h
;	COMDAT ?GetGameTime@KSubWorldSet@@QAEHXZ
_TEXT	SEGMENT
?GetGameTime@KSubWorldSet@@QAEHXZ PROC			; KSubWorldSet::GetGameTime, COMDAT
; _this$ = ecx

; 33   : 	int		GetGameTime(){return m_nLoopRate;};

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetGameTime@KSubWorldSet@@QAEHXZ ENDP			; KSubWorldSet::GetGameTime
_TEXT	ENDS
PUBLIC	?GetGameVersion@KSubWorldSet@@QAEHXZ		; KSubWorldSet::GetGameVersion
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameVersion@KSubWorldSet@@QAEHXZ
_TEXT	SEGMENT
?GetGameVersion@KSubWorldSet@@QAEHXZ PROC		; KSubWorldSet::GetGameVersion, COMDAT
; _this$ = ecx

; 34   : 	int		GetGameVersion() { return m_nGameVersion; }

	mov	eax, DWORD PTR [ecx+49440]
	ret	0
?GetGameVersion@KSubWorldSet@@QAEHXZ ENDP		; KSubWorldSet::GetGameVersion
_TEXT	ENDS
PUBLIC	?SetPing@KSubWorldSet@@QAEXK@Z			; KSubWorldSet::SetPing
; Function compile flags: /Ogtpy
;	COMDAT ?SetPing@KSubWorldSet@@QAEXK@Z
_TEXT	SEGMENT
_dwTimer$ = 8						; size = 4
?SetPing@KSubWorldSet@@QAEXK@Z PROC			; KSubWorldSet::SetPing, COMDAT
; _this$ = ecx

; 42   : 	void	SetPing(DWORD dwTimer) { m_dwPing = dwTimer; }

	mov	eax, DWORD PTR _dwTimer$[esp-4]
	mov	DWORD PTR [ecx+49444], eax
	ret	4
?SetPing@KSubWorldSet@@QAEXK@Z ENDP			; KSubWorldSet::SetPing
_TEXT	ENDS
PUBLIC	?GetPing@KSubWorldSet@@QAEKXZ			; KSubWorldSet::GetPing
; Function compile flags: /Ogtpy
;	COMDAT ?GetPing@KSubWorldSet@@QAEKXZ
_TEXT	SEGMENT
?GetPing@KSubWorldSet@@QAEKXZ PROC			; KSubWorldSet::GetPing, COMDAT
; _this$ = ecx

; 43   : 	DWORD	GetPing() { return m_dwPing; }

	mov	eax, DWORD PTR [ecx+49444]
	ret	0
?GetPing@KSubWorldSet@@QAEKXZ ENDP			; KSubWorldSet::GetPing
_TEXT	ENDS
PUBLIC	??1KSubWorldSet@@QAE@XZ				; KSubWorldSet::~KSubWorldSet
EXTRN	??1KMapMusic@@QAE@XZ:PROC			; KMapMusic::~KMapMusic
; Function compile flags: /Ogtpy
;	COMDAT ??1KSubWorldSet@@QAE@XZ
_TEXT	SEGMENT
??1KSubWorldSet@@QAE@XZ PROC				; KSubWorldSet::~KSubWorldSet, COMDAT
; _this$ = ecx
	add	ecx, 4
	jmp	??1KMapMusic@@QAE@XZ			; KMapMusic::~KMapMusic
??1KSubWorldSet@@QAE@XZ ENDP				; KSubWorldSet::~KSubWorldSet
_TEXT	ENDS
PUBLIC	??4KSubWorldSet@@QAEAAV0@ABV0@@Z		; KSubWorldSet::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4KSubWorldSet@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4KSubWorldSet@@QAEAAV0@ABV0@@Z PROC			; KSubWorldSet::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	49448					; 0000c128H
	mov	esi, ecx
	push	eax
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	4
??4KSubWorldSet@@QAEAAV0@ABV0@@Z ENDP			; KSubWorldSet::operator=
_TEXT	ENDS
PUBLIC	??_7KNode@@6B@					; KNode::`vftable'
PUBLIC	??1KNode@@UAE@XZ				; KNode::~KNode
PUBLIC	??_R4KNode@@6B@					; KNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKNode@@@8				; KNode `RTTI Type Descriptor'
PUBLIC	??_R3KNode@@8					; KNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KNode@@8					; KNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KNode@@8				; KNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EKNode@@UAEPAXI@Z:PROC			; KNode::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@KNode@@8
; File e:\x-project\#2.jx\source\sources\engine\src\knode.h
rdata$r	SEGMENT
??_R1A@?0A@EA@KNode@@8 DD FLAT:??_R0?AVKNode@@@8	; KNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KNode@@8
rdata$r	ENDS
;	COMDAT ??_R2KNode@@8
rdata$r	SEGMENT
??_R2KNode@@8 DD FLAT:??_R1A@?0A@EA@KNode@@8		; KNode::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3KNode@@8
rdata$r	SEGMENT
??_R3KNode@@8 DD 00H					; KNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2KNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKNode@@@8
_DATA	SEGMENT
??_R0?AVKNode@@@8 DD FLAT:??_7type_info@@6B@		; KNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KNode@@6B@
rdata$r	SEGMENT
??_R4KNode@@6B@ DD 00H					; KNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKNode@@@8
	DD	FLAT:??_R3KNode@@8
rdata$r	ENDS
;	COMDAT ??_7KNode@@6B@
CONST	SEGMENT
??_7KNode@@6B@ DD FLAT:??_R4KNode@@6B@			; KNode::`vftable'
	DD	FLAT:??_EKNode@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??1KNode@@UAE@XZ
_TEXT	SEGMENT
??1KNode@@UAE@XZ PROC					; KNode::~KNode, COMDAT
; _this$ = ecx

; 26   : 	virtual ~KNode(){};

	mov	DWORD PTR [ecx], OFFSET ??_7KNode@@6B@
	ret	0
??1KNode@@UAE@XZ ENDP					; KNode::~KNode
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_GKNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GKNode@@UAEPAXI@Z PROC				; KNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7KNode@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GKNode@@UAEPAXI@Z ENDP				; KNode::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0KNode@@QAE@XZ				; KNode::KNode
; Function compile flags: /Ogtpy
;	COMDAT ??0KNode@@QAE@XZ
_TEXT	SEGMENT
??0KNode@@QAE@XZ PROC					; KNode::KNode, COMDAT
; _this$ = ecx

; 43   : {

	mov	eax, ecx

; 44   : 	m_pNext = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7KNode@@6B@
	mov	DWORD PTR [eax+4], ecx

; 45   : 	m_pPrev = NULL;

	mov	DWORD PTR [eax+8], ecx

; 46   : }

	ret	0
??0KNode@@QAE@XZ ENDP					; KNode::KNode
_TEXT	ENDS
PUBLIC	?GetNext@KNode@@QAEPAV1@XZ			; KNode::GetNext
; Function compile flags: /Ogtpy
;	COMDAT ?GetNext@KNode@@QAEPAV1@XZ
_TEXT	SEGMENT
?GetNext@KNode@@QAEPAV1@XZ PROC				; KNode::GetNext, COMDAT
; _this$ = ecx

; 55   : 	if (m_pNext->m_pNext)

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	neg	eax
	sbb	eax, eax
	and	eax, ecx

; 56   : 		return m_pNext;
; 57   : 	return NULL;
; 58   : }

	ret	0
?GetNext@KNode@@QAEPAV1@XZ ENDP				; KNode::GetNext
_TEXT	ENDS
PUBLIC	?InsertBefore@KNode@@QAEXPAV1@@Z		; KNode::InsertBefore
; Function compile flags: /Ogtpy
;	COMDAT ?InsertBefore@KNode@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?InsertBefore@KNode@@QAEXPAV1@@Z PROC			; KNode::InsertBefore, COMDAT
; _this$ = ecx

; 79   : 	KASSERT(m_pPrev);
; 80   : 	if (!pNode || !m_pPrev)

	mov	eax, DWORD PTR _pNode$[esp-4]
	test	eax, eax
	je	SHORT $LN1@InsertBefo
	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $LN1@InsertBefo

; 81   : 		return;
; 82   : 
; 83   : 	pNode->m_pPrev = m_pPrev;

	mov	DWORD PTR [eax+8], edx

; 84   : 	pNode->m_pNext = this;

	mov	DWORD PTR [eax+4], ecx

; 85   : 	m_pPrev->m_pNext = pNode;

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+4], eax

; 86   : 	m_pPrev = pNode;

	mov	DWORD PTR [ecx+8], eax
$LN1@InsertBefo:

; 87   : }

	ret	4
?InsertBefore@KNode@@QAEXPAV1@@Z ENDP			; KNode::InsertBefore
_TEXT	ENDS
PUBLIC	?GetHead@KList@@QAEPAVKNode@@XZ			; KList::GetHead
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\engine\src\klist.h
;	COMDAT ?GetHead@KList@@QAEPAVKNode@@XZ
_TEXT	SEGMENT
?GetHead@KList@@QAEPAVKNode@@XZ PROC			; KList::GetHead, COMDAT
; _this$ = ecx

; 63   : 	return m_ListHead.GetNext();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	neg	eax
	sbb	eax, eax
	and	eax, ecx

; 64   : }

	ret	0
?GetHead@KList@@QAEPAVKNode@@XZ ENDP			; KList::GetHead
_TEXT	ENDS
PUBLIC	?AddTail@KList@@QAEXPAVKNode@@@Z		; KList::AddTail
; Function compile flags: /Ogtpy
;	COMDAT ?AddTail@KList@@QAEXPAVKNode@@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?AddTail@KList@@QAEXPAVKNode@@@Z PROC			; KList::AddTail, COMDAT
; _this$ = ecx

; 93   : 	m_ListTail.InsertBefore(pNode);

	lea	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _pNode$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@AddTail
	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	je	SHORT $LN3@AddTail
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [eax+8], ecx
$LN3@AddTail:

; 94   : }

	ret	4
?AddTail@KList@@QAEXPAVKNode@@@Z ENDP			; KList::AddTail
_TEXT	ENDS
PUBLIC	?g_DirSin@@YAHHH@Z				; g_DirSin
EXTRN	?g_InternalDirSinCosCode@@3PAEA:DWORD		; g_InternalDirSinCosCode
EXTRN	?g_nSin@@3PAHA:DWORD				; g_nSin
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmath.h
;	COMDAT ?g_DirSin@@YAHHH@Z
_TEXT	SEGMENT
_nDir$ = 8						; size = 4
_nMaxDir$ = 12						; size = 4
?g_DirSin@@YAHHH@Z PROC					; g_DirSin, COMDAT

; 30   :     return (*(g_InternalDirSinCosFunction *)(&(g_InternalDirSinCosCode[0])))(g_nSin, nDir, nMaxDir);

	mov	eax, DWORD PTR _nMaxDir$[esp-4]
	mov	ecx, DWORD PTR _nDir$[esp-4]
	mov	edx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	push	eax
	push	ecx
	push	edx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	add	esp, 12					; 0000000cH

; 31   : }

	ret	0
?g_DirSin@@YAHHH@Z ENDP					; g_DirSin
_TEXT	ENDS
PUBLIC	?g_DirCos@@YAHHH@Z				; g_DirCos
EXTRN	?g_nCos@@3PAHA:DWORD				; g_nCos
; Function compile flags: /Ogtpy
;	COMDAT ?g_DirCos@@YAHHH@Z
_TEXT	SEGMENT
_nDir$ = 8						; size = 4
_nMaxDir$ = 12						; size = 4
?g_DirCos@@YAHHH@Z PROC					; g_DirCos, COMDAT

; 36   :     return (*(g_InternalDirSinCosFunction *)(&(g_InternalDirSinCosCode[0])))(g_nCos, nDir, nMaxDir);

	mov	eax, DWORD PTR _nMaxDir$[esp-4]
	mov	ecx, DWORD PTR _nDir$[esp-4]
	mov	edx, DWORD PTR ?g_nCos@@3PAHA		; g_nCos
	push	eax
	push	ecx
	push	edx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	add	esp, 12					; 0000000cH

; 37   : }

	ret	0
?g_DirCos@@YAHHH@Z ENDP					; g_DirCos
_TEXT	ENDS
PUBLIC	?g_GetDistance@@YAHHHHH@Z			; g_GetDistance
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?g_GetDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
tv65 = 8						; size = 4
_nX1$ = 8						; size = 4
_nY1$ = 12						; size = 4
_nX2$ = 16						; size = 4
_nY2$ = 20						; size = 4
?g_GetDistance@@YAHHHHH@Z PROC				; g_GetDistance, COMDAT

; 63   : 	//Fixed By MrChuCong@gmail.com
; 64   : 	return (int)sqrt(double(nX1 - nX2) * (nX1 - nX2) + (nY1 - nY2) * (nY1 - nY2));

	mov	eax, DWORD PTR _nX1$[esp-4]
	sub	eax, DWORD PTR _nX2$[esp-4]
	mov	DWORD PTR tv130[esp-4], eax
	mov	eax, DWORD PTR _nY1$[esp-4]
	fild	DWORD PTR tv130[esp-4]
	sub	eax, DWORD PTR _nY2$[esp-4]
	mov	ecx, eax
	imul	ecx, eax
	mov	DWORD PTR tv65[esp-4], ecx
	fild	DWORD PTR tv65[esp-4]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	jmp	__ftol2_sse
?g_GetDistance@@YAHHHHH@Z ENDP				; g_GetDistance
_TEXT	ENDS
PUBLIC	?g_GetDirIndex@@YAHHHHH@Z			; g_GetDirIndex
; Function compile flags: /Ogtpy
;	COMDAT ?g_GetDirIndex@@YAHHHHH@Z
_TEXT	SEGMENT
_nX1$ = 8						; size = 4
_nY1$ = 12						; size = 4
tv404 = 16						; size = 4
tv399 = 16						; size = 4
_nX2$ = 16						; size = 4
_nY2$ = 20						; size = 4
?g_GetDirIndex@@YAHHHHH@Z PROC				; g_GetDirIndex, COMDAT

; 70   : 	int		nRet = -1;
; 71   : 
; 72   : 	if (nX1 == nX2 && nY1 == nY2)

	mov	eax, DWORD PTR _nX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nY1$[esp]
	push	ebp
	mov	ebp, DWORD PTR _nX2$[esp+4]
	push	esi
	or	esi, -1
	cmp	eax, ebp
	push	edi
	mov	edi, DWORD PTR _nY2$[esp+12]
	jne	SHORT $LN7@g_GetDirIn
	cmp	ebx, edi
	jne	SHORT $LN7@g_GetDirIn
$LN18@g_GetDirIn:
	pop	edi
	pop	esi
	pop	ebp

; 73   : 		return -1;

	or	eax, -1
	pop	ebx

; 97   : }

	ret	0
$LN7@g_GetDirIn:

; 74   : 
; 75   : //	int		nDistance = g_GetDistance(nX1, nY1 * 2, nX2, nY2 * 2);
; 76   : 	int		nDistance = g_GetDistance(nX1, nY1, nX2, nY2);

	sub	eax, ebp
	mov	DWORD PTR tv404[esp+12], eax
	fild	DWORD PTR tv404[esp+12]
	mov	eax, ebx
	sub	eax, edi
	mov	ecx, eax
	imul	ecx, eax
	mov	DWORD PTR tv399[esp+12], ecx
	fild	DWORD PTR tv399[esp+12]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	call	__ftol2_sse
	mov	ecx, eax

; 77   : 	
; 78   : 	if (nDistance == 0 ) return -1;

	test	ecx, ecx
	je	SHORT $LN18@g_GetDirIn

; 79   : 	
; 80   : //	int		nYLength = (nY2 - nY1) * 2;
; 81   : 	int		nYLength = nY2 - nY1;
; 82   : 	int		nSin = (nYLength << 10) / nDistance;	// 放大1024倍

	mov	eax, edi
	sub	eax, ebx
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ecx
	mov	edx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	mov	ecx, 2
	add	edx, 8
$LL5@g_GetDirIn:

; 83   : 	
; 84   : 
; 85   : 	for (int i = 0; i < 32; i++)		// 顺时针方向 从270度到90度，sin值递减
; 86   : 	{
; 87   : 		if (nSin > g_nSin[i])

	cmp	eax, DWORD PTR [edx-8]
	jg	SHORT $LN15@g_GetDirIn
	cmp	eax, DWORD PTR [edx-4]

; 88   : 			break;
; 89   : 		nRet = i;

	lea	esi, DWORD PTR [ecx-2]
	jg	SHORT $LN15@g_GetDirIn
	cmp	eax, DWORD PTR [edx]
	lea	esi, DWORD PTR [ecx-1]
	jg	SHORT $LN15@g_GetDirIn
	cmp	eax, DWORD PTR [edx+4]
	mov	esi, ecx
	jg	SHORT $LN15@g_GetDirIn
	lea	esi, DWORD PTR [ecx+1]
	add	ecx, 4
	lea	edi, DWORD PTR [ecx-2]
	add	edx, 16					; 00000010H
	cmp	edi, 32					; 00000020H
	jl	SHORT $LL5@g_GetDirIn
$LN15@g_GetDirIn:

; 90   : 	}
; 91   : 
; 92   : 	if ((nX2 - nX1) > 0)

	sub	ebp, DWORD PTR _nX1$[esp+12]
	test	ebp, ebp
	jle	SHORT $LN1@g_GetDirIn

; 93   : 	{
; 94   : 		nRet = 63 - nRet;

	mov	edx, 63					; 0000003fH
	sub	edx, esi
	mov	esi, edx
$LN1@g_GetDirIn:
	pop	edi

; 95   : 	}
; 96   : 	return nRet;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 97   : }

	ret	0
?g_GetDirIndex@@YAHHHHH@Z ENDP				; g_GetDirIndex
_TEXT	ENDS
PUBLIC	?g_Dir2DirIndex@@YAHHH@Z			; g_Dir2DirIndex
; Function compile flags: /Ogtpy
;	COMDAT ?g_Dir2DirIndex@@YAHHH@Z
_TEXT	SEGMENT
_nDir$ = 8						; size = 4
_nMaxDir$ = 12						; size = 4
?g_Dir2DirIndex@@YAHHH@Z PROC				; g_Dir2DirIndex, COMDAT

; 101  : 	int nRet = -1;
; 102  : 
; 103  : 	if (nMaxDir <= 0)

	mov	ecx, DWORD PTR _nMaxDir$[esp-4]
	test	ecx, ecx
	jg	SHORT $LN1@g_Dir2DirI

; 104  : 		return nRet;

	or	eax, -1

; 107  : 	return nRet;
; 108  : }

	ret	0
$LN1@g_Dir2DirI:

; 105  : 
; 106  : 	nRet = (nDir << 6) / nMaxDir;

	mov	eax, DWORD PTR _nDir$[esp-4]
	shl	eax, 6
	cdq
	idiv	ecx

; 107  : 	return nRet;
; 108  : }

	ret	0
?g_Dir2DirIndex@@YAHHH@Z ENDP				; g_Dir2DirIndex
_TEXT	ENDS
PUBLIC	?g_DirIndex2Dir@@YAHHH@Z			; g_DirIndex2Dir
; Function compile flags: /Ogtpy
;	COMDAT ?g_DirIndex2Dir@@YAHHH@Z
_TEXT	SEGMENT
_nDir$ = 8						; size = 4
_nMaxDir$ = 12						; size = 4
?g_DirIndex2Dir@@YAHHH@Z PROC				; g_DirIndex2Dir, COMDAT

; 112  : 	int		nRet = -1;
; 113  : 
; 114  : 	if (nMaxDir <= 0)

	mov	ecx, DWORD PTR _nMaxDir$[esp-4]
	test	ecx, ecx
	jg	SHORT $LN1@g_DirIndex

; 115  : 		return nRet;

	or	eax, -1

; 118  : 	return nRet;
; 119  : }

	ret	0
$LN1@g_DirIndex:

; 116  : 
; 117  : 	nRet = (nMaxDir * nDir) >> 6;	// (nMaxDir / 64) * nDir

	mov	eax, DWORD PTR _nDir$[esp-4]
	imul	eax, ecx
	sar	eax, 6

; 118  : 	return nRet;
; 119  : }

	ret	0
?g_DirIndex2Dir@@YAHHH@Z ENDP				; g_DirIndex2Dir
_TEXT	ENDS
PUBLIC	??_7KSkillSpecialNode@@6B@			; KSkillSpecialNode::`vftable'
PUBLIC	??0KSkillSpecialNode@@QAE@XZ			; KSkillSpecialNode::KSkillSpecialNode
PUBLIC	??_R4KSkillSpecialNode@@6B@			; KSkillSpecialNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKSkillSpecialNode@@@8			; KSkillSpecialNode `RTTI Type Descriptor'
PUBLIC	??_R3KSkillSpecialNode@@8			; KSkillSpecialNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KSkillSpecialNode@@8			; KSkillSpecialNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KSkillSpecialNode@@8		; KSkillSpecialNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EKSkillSpecialNode@@UAEPAXI@Z:PROC		; KSkillSpecialNode::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@KSkillSpecialNode@@8
; File e:\x-project\#2.jx\source\sources\engine\src\knode.h
rdata$r	SEGMENT
??_R1A@?0A@EA@KSkillSpecialNode@@8 DD FLAT:??_R0?AVKSkillSpecialNode@@@8 ; KSkillSpecialNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KSkillSpecialNode@@8
rdata$r	ENDS
;	COMDAT ??_R2KSkillSpecialNode@@8
rdata$r	SEGMENT
??_R2KSkillSpecialNode@@8 DD FLAT:??_R1A@?0A@EA@KSkillSpecialNode@@8 ; KSkillSpecialNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@KNode@@8
rdata$r	ENDS
;	COMDAT ??_R3KSkillSpecialNode@@8
rdata$r	SEGMENT
??_R3KSkillSpecialNode@@8 DD 00H			; KSkillSpecialNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2KSkillSpecialNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKSkillSpecialNode@@@8
_DATA	SEGMENT
??_R0?AVKSkillSpecialNode@@@8 DD FLAT:??_7type_info@@6B@ ; KSkillSpecialNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKSkillSpecialNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KSkillSpecialNode@@6B@
rdata$r	SEGMENT
??_R4KSkillSpecialNode@@6B@ DD 00H			; KSkillSpecialNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKSkillSpecialNode@@@8
	DD	FLAT:??_R3KSkillSpecialNode@@8
rdata$r	ENDS
;	COMDAT ??_7KSkillSpecialNode@@6B@
CONST	SEGMENT
??_7KSkillSpecialNode@@6B@ DD FLAT:??_R4KSkillSpecialNode@@6B@ ; KSkillSpecialNode::`vftable'
	DD	FLAT:??_EKSkillSpecialNode@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kskillspecial.h
CONST	ENDS
;	COMDAT ??0KSkillSpecialNode@@QAE@XZ
_TEXT	SEGMENT
??0KSkillSpecialNode@@QAE@XZ PROC			; KSkillSpecialNode::KSkillSpecialNode, COMDAT
; _this$ = ecx

; 56   : 	KSkillSpecialNode(){m_pSkillSpecial = NULL;};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7KSkillSpecialNode@@6B@
	mov	DWORD PTR [eax+12], ecx
	ret	0
??0KSkillSpecialNode@@QAE@XZ ENDP			; KSkillSpecialNode::KSkillSpecialNode
_TEXT	ENDS
PUBLIC	??1KSkillSpecialNode@@UAE@XZ			; KSkillSpecialNode::~KSkillSpecialNode
; Function compile flags: /Ogtpy
;	COMDAT ??1KSkillSpecialNode@@UAE@XZ
_TEXT	SEGMENT
??1KSkillSpecialNode@@UAE@XZ PROC			; KSkillSpecialNode::~KSkillSpecialNode, COMDAT
; _this$ = ecx

; 57   : 	~KSkillSpecialNode(){delete m_pSkillSpecial;};

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7KSkillSpecialNode@@6B@
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR [esi], OFFSET ??_7KNode@@6B@
	pop	esi
	ret	0
??1KSkillSpecialNode@@UAE@XZ ENDP			; KSkillSpecialNode::~KSkillSpecialNode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GKSkillSpecialNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GKSkillSpecialNode@@UAEPAXI@Z PROC			; KSkillSpecialNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7KSkillSpecialNode@@6B@
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi], OFFSET ??_7KNode@@6B@
	je	SHORT $LN8@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_GKSkillSpecialNode@@UAEPAXI@Z ENDP			; KSkillSpecialNode::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?SpecialMovieIsAllEnd@KMissleRes@@QAEHXZ	; KMissleRes::SpecialMovieIsAllEnd
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmissleres.h
;	COMDAT ?SpecialMovieIsAllEnd@KMissleRes@@QAEHXZ
_TEXT	SEGMENT
?SpecialMovieIsAllEnd@KMissleRes@@QAEHXZ PROC		; KMissleRes::SpecialMovieIsAllEnd, COMDAT
; _this$ = ecx

; 84   : 		
; 85   : 		if (m_SkillSpecialList.GetHead())

	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@SpecialMov
	test	eax, eax
	je	SHORT $LN1@SpecialMov

; 86   : 		{
; 87   : 			return FALSE;

	xor	eax, eax

; 91   : 	};

	ret	0
$LN1@SpecialMov:

; 88   : 		}
; 89   : 		
; 90   : 		return TRUE;

	mov	eax, 1

; 91   : 	};

	ret	0
?SpecialMovieIsAllEnd@KMissleRes@@QAEHXZ ENDP		; KMissleRes::SpecialMovieIsAllEnd
_TEXT	ENDS
PUBLIC	??_7KIndexNode@@6B@				; KIndexNode::`vftable'
PUBLIC	??0KIndexNode@@QAE@XZ				; KIndexNode::KIndexNode
PUBLIC	??_R4KIndexNode@@6B@				; KIndexNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKIndexNode@@@8				; KIndexNode `RTTI Type Descriptor'
PUBLIC	??_R3KIndexNode@@8				; KIndexNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KIndexNode@@8				; KIndexNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KIndexNode@@8			; KIndexNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EKIndexNode@@UAEPAXI@Z:PROC			; KIndexNode::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@KIndexNode@@8
; File e:\x-project\#2.jx\source\sources\engine\src\knode.h
rdata$r	SEGMENT
??_R1A@?0A@EA@KIndexNode@@8 DD FLAT:??_R0?AVKIndexNode@@@8 ; KIndexNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KIndexNode@@8
rdata$r	ENDS
;	COMDAT ??_R2KIndexNode@@8
rdata$r	SEGMENT
??_R2KIndexNode@@8 DD FLAT:??_R1A@?0A@EA@KIndexNode@@8	; KIndexNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@KNode@@8
rdata$r	ENDS
;	COMDAT ??_R3KIndexNode@@8
rdata$r	SEGMENT
??_R3KIndexNode@@8 DD 00H				; KIndexNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2KIndexNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKIndexNode@@@8
_DATA	SEGMENT
??_R0?AVKIndexNode@@@8 DD FLAT:??_7type_info@@6B@	; KIndexNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKIndexNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KIndexNode@@6B@
rdata$r	SEGMENT
??_R4KIndexNode@@6B@ DD 00H				; KIndexNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKIndexNode@@@8
	DD	FLAT:??_R3KIndexNode@@8
rdata$r	ENDS
;	COMDAT ??_7KIndexNode@@6B@
CONST	SEGMENT
??_7KIndexNode@@6B@ DD FLAT:??_R4KIndexNode@@6B@	; KIndexNode::`vftable'
	DD	FLAT:??_EKIndexNode@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kindexnode.h
CONST	ENDS
;	COMDAT ??0KIndexNode@@QAE@XZ
_TEXT	SEGMENT
??0KIndexNode@@QAE@XZ PROC				; KIndexNode::KIndexNode, COMDAT
; _this$ = ecx

; 10   : 	KIndexNode() { m_nIndex = NULL; m_Ref = 0; };

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7KIndexNode@@6B@
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	ret	0
??0KIndexNode@@QAE@XZ ENDP				; KIndexNode::KIndexNode
_TEXT	ENDS
PUBLIC	??1KIndexNode@@UAE@XZ				; KIndexNode::~KIndexNode
; Function compile flags: /Ogtpy
;	COMDAT ??1KIndexNode@@UAE@XZ
_TEXT	SEGMENT
??1KIndexNode@@UAE@XZ PROC				; KIndexNode::~KIndexNode, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7KNode@@6B@
	ret	0
??1KIndexNode@@UAE@XZ ENDP				; KIndexNode::~KIndexNode
_TEXT	ENDS
PUBLIC	?IsMatch@KNpc@@QAEHK@Z				; KNpc::IsMatch
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\knpc.h
;	COMDAT ?IsMatch@KNpc@@QAEHK@Z
_TEXT	SEGMENT
_dwID$ = 8						; size = 4
?IsMatch@KNpc@@QAEHK@Z PROC				; KNpc::IsMatch, COMDAT
; _this$ = ecx

; 562  : 	BOOL				IsMatch(DWORD dwID)	{ return dwID == m_dwID; };	// 是否ID与该Index匹配

	mov	edx, DWORD PTR _dwID$[esp-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al
	ret	4
?IsMatch@KNpc@@QAEHK@Z ENDP				; KNpc::IsMatch
_TEXT	ENDS
PUBLIC	??_7KWorldMsgNode@@6B@				; KWorldMsgNode::`vftable'
PUBLIC	??0KWorldMsgNode@@QAE@XZ			; KWorldMsgNode::KWorldMsgNode
PUBLIC	??_R4KWorldMsgNode@@6B@				; KWorldMsgNode::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKWorldMsgNode@@@8			; KWorldMsgNode `RTTI Type Descriptor'
PUBLIC	??_R3KWorldMsgNode@@8				; KWorldMsgNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KWorldMsgNode@@8				; KWorldMsgNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KWorldMsgNode@@8			; KWorldMsgNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_EKWorldMsgNode@@UAEPAXI@Z:PROC		; KWorldMsgNode::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@KWorldMsgNode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@KWorldMsgNode@@8 DD FLAT:??_R0?AVKWorldMsgNode@@@8 ; KWorldMsgNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KWorldMsgNode@@8
rdata$r	ENDS
;	COMDAT ??_R2KWorldMsgNode@@8
rdata$r	SEGMENT
??_R2KWorldMsgNode@@8 DD FLAT:??_R1A@?0A@EA@KWorldMsgNode@@8 ; KWorldMsgNode::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@KNode@@8
rdata$r	ENDS
;	COMDAT ??_R3KWorldMsgNode@@8
rdata$r	SEGMENT
??_R3KWorldMsgNode@@8 DD 00H				; KWorldMsgNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2KWorldMsgNode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKWorldMsgNode@@@8
_DATA	SEGMENT
??_R0?AVKWorldMsgNode@@@8 DD FLAT:??_7type_info@@6B@	; KWorldMsgNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKWorldMsgNode@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KWorldMsgNode@@6B@
rdata$r	SEGMENT
??_R4KWorldMsgNode@@6B@ DD 00H				; KWorldMsgNode::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKWorldMsgNode@@@8
	DD	FLAT:??_R3KWorldMsgNode@@8
rdata$r	ENDS
;	COMDAT ??_7KWorldMsgNode@@6B@
CONST	SEGMENT
??_7KWorldMsgNode@@6B@ DD FLAT:??_R4KWorldMsgNode@@6B@	; KWorldMsgNode::`vftable'
	DD	FLAT:??_EKWorldMsgNode@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0KWorldMsgNode@@QAE@XZ
_TEXT	SEGMENT
??0KWorldMsgNode@@QAE@XZ PROC				; KWorldMsgNode::KWorldMsgNode, COMDAT
; _this$ = ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], OFFSET ??_7KWorldMsgNode@@6B@
	ret	0
??0KWorldMsgNode@@QAE@XZ ENDP				; KWorldMsgNode::KWorldMsgNode
_TEXT	ENDS
PUBLIC	?GetMoney@KInventory@@QAEHXZ			; KInventory::GetMoney
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kinventory.h
;	COMDAT ?GetMoney@KInventory@@QAEHXZ
_TEXT	SEGMENT
?GetMoney@KInventory@@QAEHXZ PROC			; KInventory::GetMoney, COMDAT
; _this$ = ecx

; 28   : 	int		GetMoney() { return m_nMoney; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetMoney@KInventory@@QAEHXZ ENDP			; KInventory::GetMoney
_TEXT	ENDS
PUBLIC	?SetMoney@KInventory@@QAEHH@Z			; KInventory::SetMoney
; Function compile flags: /Ogtpy
;	COMDAT ?SetMoney@KInventory@@QAEHH@Z
_TEXT	SEGMENT
_nMoney$ = 8						; size = 4
?SetMoney@KInventory@@QAEHH@Z PROC			; KInventory::SetMoney, COMDAT
; _this$ = ecx

; 29   : 	BOOL	SetMoney(int nMoney) { if (nMoney < 0) return FALSE; m_nMoney = nMoney; return TRUE; }

	mov	eax, DWORD PTR _nMoney$[esp-4]
	test	eax, eax
	jge	SHORT $LN1@SetMoney
	xor	eax, eax
	ret	4
$LN1@SetMoney:
	mov	DWORD PTR [ecx+4], eax
	mov	eax, 1
	ret	4
?SetMoney@KInventory@@QAEHH@Z ENDP			; KInventory::SetMoney
_TEXT	ENDS
PUBLIC	??4KInventory@@QAEAAV0@ABV0@@Z			; KInventory::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4KInventory@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4KInventory@@QAEAAV0@ABV0@@Z PROC			; KInventory::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	4
??4KInventory@@QAEAAV0@ABV0@@Z ENDP			; KInventory::operator=
_TEXT	ENDS
PUBLIC	??1KWorldMsgNode@@UAE@XZ			; KWorldMsgNode::~KWorldMsgNode
; Function compile flags: /Ogtpy
;	COMDAT ??1KWorldMsgNode@@UAE@XZ
_TEXT	SEGMENT
??1KWorldMsgNode@@UAE@XZ PROC				; KWorldMsgNode::~KWorldMsgNode, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7KNode@@6B@
	ret	0
??1KWorldMsgNode@@UAE@XZ ENDP				; KWorldMsgNode::~KWorldMsgNode
_TEXT	ENDS
PUBLIC	?FindNpc@KRegion@@QAEHHHHH@Z			; KRegion::FindNpc
EXTRN	?GetRelation@KNpcSet@@QAE?AW4NPC_RELATION@@HH@Z:PROC ; KNpcSet::GetRelation
EXTRN	?NpcSet@@3VKNpcSet@@A:BYTE			; NpcSet
EXTRN	?Npc@@3PAVKNpc@@A:BYTE				; Npc
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kregion.h
;	COMDAT ?FindNpc@KRegion@@QAEHHHHH@Z
_TEXT	SEGMENT
_nMapX$ = 8						; size = 4
_nMapY$ = 12						; size = 4
_nNpcIdx$ = 16						; size = 4
_nRelation$ = 20					; size = 4
?FindNpc@KRegion@@QAEHHHHH@Z PROC			; KRegion::FindNpc, COMDAT
; _this$ = ecx

; 137  : 	if (m_pNpcRef[nMapY * m_nWidth + nMapX] == 0)

	mov	eax, DWORD PTR [ecx+176]
	imul	eax, DWORD PTR _nMapY$[esp-4]
	add	eax, DWORD PTR [ecx+196]
	push	edi
	mov	edi, DWORD PTR _nMapX$[esp]
	cmp	BYTE PTR [eax+edi], 0
	jne	SHORT $LN5@FindNpc

; 138  : 		return 0;

	xor	eax, eax
	pop	edi

; 156  : }

	ret	16					; 00000010H
$LN5@FindNpc:

; 139  : 
; 140  : 	KIndexNode *pNode = NULL;
; 141  : 	
; 142  : 	pNode = (KIndexNode *)m_NpcList.GetHead();

	mov	ecx, DWORD PTR [ecx+12]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	neg	esi
	sbb	esi, esi
	and	esi, ecx

; 143  : 	
; 144  : 	while(pNode)

	je	SHORT $LN3@FindNpc
	mov	ebx, DWORD PTR _nRelation$[esp+12]
	mov	ebp, DWORD PTR _nNpcIdx$[esp+12]
	npad	5
$LL4@FindNpc:

; 145  : 	{
; 146  : 		if (Npc[pNode->m_nIndex].m_MapX == nMapX && Npc[pNode->m_nIndex].m_MapY == nMapY)

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, ecx
	imul	eax, 30432				; 000076e0H
	cmp	DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756], edi
	jne	SHORT $LN19@FindNpc
	mov	edx, DWORD PTR _nMapY$[esp+12]
	cmp	DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760], edx
	jne	SHORT $LN19@FindNpc

; 147  : 		{
; 148  : 			if (NpcSet.GetRelation(nNpcIdx, pNode->m_nIndex) & nRelation)

	push	ecx
	push	ebp
	mov	ecx, OFFSET ?NpcSet@@3VKNpcSet@@A	; NpcSet
	call	?GetRelation@KNpcSet@@QAE?AW4NPC_RELATION@@HH@Z ; KNpcSet::GetRelation
	test	eax, ebx
	jne	SHORT $LN17@FindNpc
$LN19@FindNpc:

; 151  : 			}
; 152  : 		}
; 153  : 		pNode = (KIndexNode *)pNode->GetNext();

	mov	esi, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN3@FindNpc

; 143  : 	
; 144  : 	while(pNode)

	test	esi, esi
	jne	SHORT $LL4@FindNpc
$LN3@FindNpc:
	pop	esi
	pop	ebp
	pop	ebx

; 154  : 	}	
; 155  : 	return 0;

	xor	eax, eax
	pop	edi

; 156  : }

	ret	16					; 00000010H
$LN17@FindNpc:

; 149  : 			{
; 150  : 				return pNode->m_nIndex;

	mov	eax, DWORD PTR [esi+12]
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 156  : }

	ret	16					; 00000010H
?FindNpc@KRegion@@QAEHHHHH@Z ENDP			; KRegion::FindNpc
_TEXT	ENDS
PUBLIC	?ZAxisMove@KMissle@@AAEXXZ			; KMissle::ZAxisMove
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmissle.h
;	COMDAT ?ZAxisMove@KMissle@@AAEXXZ
_TEXT	SEGMENT
?ZAxisMove@KMissle@@AAEXXZ PROC				; KMissle::ZAxisMove, COMDAT
; _this$ = ecx

; 202  : 		if (m_nZAcceleration)

	mov	edx, DWORD PTR [ecx+348]
	test	edx, edx
	je	SHORT $LN2@ZAxisMove

; 203  : 		{
; 204  : 			m_nHeight += m_nHeightSpeed;

	mov	eax, DWORD PTR [ecx+88]
	add	DWORD PTR [ecx+84], eax

; 205  : 			if (m_nHeight < 0) m_nHeight = 0;

	jns	SHORT $LN1@ZAxisMove
	mov	DWORD PTR [ecx+84], 0
$LN1@ZAxisMove:

; 206  : 			m_nHeightSpeed -= m_nZAcceleration;

	sub	eax, edx
	mov	DWORD PTR [ecx+88], eax

; 207  : 			m_nCurrentMapZ = m_nHeight >> 10;

	mov	eax, DWORD PTR [ecx+84]
	sar	eax, 10					; 0000000aH
	mov	DWORD PTR [ecx+224], eax
$LN2@ZAxisMove:

; 208  : 		}
; 209  : 	}

	ret	0
?ZAxisMove@KMissle@@AAEXXZ ENDP				; KMissle::ZAxisMove
_TEXT	ENDS
PUBLIC	?TestBarrier@KMissle@@AAEHXZ			; KMissle::TestBarrier
EXTRN	?TestBarrier@KSubWorld@@QAEEHHHHHHH@Z:PROC	; KSubWorld::TestBarrier
EXTRN	?SubWorld@@3PAVKSubWorld@@A:BYTE		; SubWorld
; Function compile flags: /Ogtpy
;	COMDAT ?TestBarrier@KMissle@@AAEHXZ
_TEXT	SEGMENT
?TestBarrier@KMissle@@AAEHXZ PROC			; KMissle::TestBarrier, COMDAT
; _this$ = ecx

; 213  : 		int nBarrierKind = SubWorld[m_nSubWorldId].TestBarrier(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nXOffset, m_nYOffset, 0, 0);

	mov	eax, DWORD PTR [ecx+232]
	mov	edx, DWORD PTR [ecx+228]
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR [ecx+220]
	push	edx
	mov	edx, DWORD PTR [ecx+216]
	push	eax
	mov	eax, DWORD PTR [ecx+364]
	mov	ecx, DWORD PTR [ecx+360]
	imul	ecx, 220				; 000000dcH
	push	edx
	push	eax
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?TestBarrier@KSubWorld@@QAEEHHHHHHH@Z	; KSubWorld::TestBarrier
	movzx	eax, al

; 214  : 		if (nBarrierKind == Obstacle_Normal || nBarrierKind == Obstacle_Jump)

	cmp	eax, 1
	je	SHORT $LN1@TestBarrie
	cmp	eax, 3
	je	SHORT $LN1@TestBarrie

; 218  : 		}
; 219  : 		return FALSE;

	xor	eax, eax

; 220  : 	}

	ret	0
$LN1@TestBarrie:

; 215  : 		{
; 216  : 			
; 217  : 			return TRUE;

	mov	eax, 1

; 220  : 	}

	ret	0
?TestBarrier@KMissle@@AAEHXZ ENDP			; KMissle::TestBarrier
_TEXT	ENDS
PUBLIC	?GetEquipment@KItemList@@QAEHH@Z		; KItemList::GetEquipment
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kitemlist.h
;	COMDAT ?GetEquipment@KItemList@@QAEHH@Z
_TEXT	SEGMENT
_nIdx$ = 8						; size = 4
?GetEquipment@KItemList@@QAEHH@Z PROC			; KItemList::GetEquipment, COMDAT
; _this$ = ecx

; 65   : 	int			GetEquipment(int nIdx) { return m_EquipItem[nIdx]; }

	mov	eax, DWORD PTR _nIdx$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+12]
	ret	4
?GetEquipment@KItemList@@QAEHH@Z ENDP			; KItemList::GetEquipment
_TEXT	ENDS
PUBLIC	?GetMoney@KItemList@@QAEHH@Z			; KItemList::GetMoney
; Function compile flags: /Ogtpy
;	COMDAT ?GetMoney@KItemList@@QAEHH@Z
_TEXT	SEGMENT
_nRoom$ = 8						; size = 4
?GetMoney@KItemList@@QAEHH@Z PROC			; KItemList::GetMoney, COMDAT
; _this$ = ecx

; 91   : 	int			GetMoney(int nRoom) { return m_Room[nRoom].GetMoney(); }	// 取得空间的钱

	mov	eax, DWORD PTR _nRoom$[esp-4]
	shl	eax, 4
	mov	eax, DWORD PTR [eax+ecx+7988]
	ret	4
?GetMoney@KItemList@@QAEHH@Z ENDP			; KItemList::GetMoney
_TEXT	ENDS
PUBLIC	?Hand@KItemList@@QAEHXZ				; KItemList::Hand
; Function compile flags: /Ogtpy
;	COMDAT ?Hand@KItemList@@QAEHXZ
_TEXT	SEGMENT
?Hand@KItemList@@QAEHXZ PROC				; KItemList::Hand, COMDAT
; _this$ = ecx

; 93   : 	int			Hand() { return m_Hand; };

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?Hand@KItemList@@QAEHXZ ENDP				; KItemList::Hand
_TEXT	ENDS
PUBLIC	?IsLockOperation@KItemList@@QAEHXZ		; KItemList::IsLockOperation
; Function compile flags: /Ogtpy
;	COMDAT ?IsLockOperation@KItemList@@QAEHXZ
_TEXT	SEGMENT
?IsLockOperation@KItemList@@QAEHXZ PROC			; KItemList::IsLockOperation, COMDAT
; _this$ = ecx

; 125  : 	BOOL		IsLockOperation() { return m_bLockOperation; };

	mov	eax, DWORD PTR [ecx+7980]
	ret	0
?IsLockOperation@KItemList@@QAEHXZ ENDP			; KItemList::IsLockOperation
_TEXT	ENDS
PUBLIC	??4KItemList@@QAEAAV0@ABV0@@Z			; KItemList::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4KItemList@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4KItemList@@QAEAAV0@ABV0@@Z PROC			; KItemList::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	8080					; 00001f90H
	mov	esi, ecx
	push	eax
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	4
??4KItemList@@QAEAAV0@ABV0@@Z ENDP			; KItemList::operator=
_TEXT	ENDS
PUBLIC	?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z	; KSkillManager::GetSkill
EXTRN	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z:PROC ; KSkillManager::InstanceSkill
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kskillmanager.h
;	COMDAT ?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z
_TEXT	SEGMENT
_nSkillID$ = 8						; size = 4
_nSkillLevel$ = 12					; size = 4
?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z PROC	; KSkillManager::GetSkill, COMDAT
; _this$ = ecx

; 76   : //	_ASSERT((nSkillID <= MAX_SKILL)    && (nSkillID > 0));
; 77   : //	_ASSERT((nSkillLevel <= MAX_SKILLLEVEL) && (nSkillLevel > 0));
; 78   : 
; 79   : 	if (nSkillID > MAX_SKILL || nSkillID <= 0 || nSkillLevel <= 0 || nSkillLevel > MAX_SKILLLEVEL)

	mov	edx, DWORD PTR _nSkillID$[esp-4]
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 499				; 000001f3H
	push	esi
	ja	SHORT $LN2@GetSkill
	mov	esi, DWORD PTR _nSkillLevel$[esp]
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@GetSkill

; 81   : 
; 82   :     unsigned long ulSkillID = nSkillID;
; 83   :     unsigned long ulSkillLevel = nSkillLevel;
; 84   : 
; 85   :     if (m_pOrdinSkill[ulSkillID - 1][ulSkillLevel - 1])

	mov	eax, edx
	shl	eax, 6
	add	eax, esi
	mov	eax, DWORD PTR [ecx+eax*4+7740]
	test	eax, eax

; 86   :     { 
; 87   :         return m_pOrdinSkill[ulSkillID - 1][ulSkillLevel - 1];

	jne	SHORT $LN4@GetSkill

; 88   :     }
; 89   : 
; 90   : 	return InstanceSkill(ulSkillID , ulSkillLevel);

	push	esi
	push	edx
	call	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z ; KSkillManager::InstanceSkill
	pop	esi

; 91   : }

	ret	8
$LN2@GetSkill:

; 80   : 		return NULL;

	xor	eax, eax
$LN4@GetSkill:
	pop	esi

; 91   : }

	ret	8
?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z ENDP	; KSkillManager::GetSkill
_TEXT	ENDS
PUBLIC	??0KMissleSet@@QAE@XZ				; KMissleSet::KMissleSet
EXTRN	__imp_??1KLinkArray@@QAE@XZ:PROC
EXTRN	__imp_??0KLinkArray@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0KMissleSet@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0KMissleSet@@QAE@XZ$0
__ehfuncinfo$??0KMissleSet@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0KMissleSet@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0KMissleSet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0KMissleSet@@QAE@XZ PROC				; KMissleSet::KMissleSet, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0KMissleSet@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	DWORD PTR __imp_??0KLinkArray@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??0KLinkArray@@QAE@XZ
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0KMissleSet@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1KLinkArray@@QAE@XZ
__ehhandler$??0KMissleSet@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0KMissleSet@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0KMissleSet@@QAE@XZ ENDP				; KMissleSet::KMissleSet
PUBLIC	??1KMissleSet@@QAE@XZ				; KMissleSet::~KMissleSet
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1KMissleSet@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1KMissleSet@@QAE@XZ$0
__ehfuncinfo$??1KMissleSet@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1KMissleSet@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1KMissleSet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1KMissleSet@@QAE@XZ PROC				; KMissleSet::~KMissleSet, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1KMissleSet@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR __imp_??1KLinkArray@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	edi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1KMissleSet@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1KLinkArray@@QAE@XZ
__ehhandler$??1KMissleSet@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1KMissleSet@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1KMissleSet@@QAE@XZ ENDP				; KMissleSet::~KMissleSet
PUBLIC	??4KMissleSet@@QAEAAV0@ABV0@@Z			; KMissleSet::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4KMissleSet@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4KMissleSet@@QAEAAV0@ABV0@@Z PROC			; KMissleSet::operator=, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR ___that$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
	ret	4
??4KMissleSet@@QAEAAV0@ABV0@@Z ENDP			; KMissleSet::operator=
_TEXT	ENDS
PUBLIC	?KSG_StringGetInt@@YAHPAPADH@Z			; KSG_StringGetInt
EXTRN	__imp_?KSG_StringGetInt@@YAHPAPBDH@Z:PROC
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\engine\src\ksg_stringprocess.h
;	COMDAT ?KSG_StringGetInt@@YAHPAPADH@Z
_TEXT	SEGMENT
_ppszString$ = 8					; size = 4
_nDefaultValue$ = 12					; size = 4
?KSG_StringGetInt@@YAHPAPADH@Z PROC			; KSG_StringGetInt, COMDAT

; 20   :     return KSG_StringGetInt((const char **)ppszString, nDefaultValue);    

	jmp	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
?KSG_StringGetInt@@YAHPAPADH@Z ENDP			; KSG_StringGetInt
_TEXT	ENDS
PUBLIC	?KSG_StringSkipSymbol@@YA_NPAPADH@Z		; KSG_StringSkipSymbol
EXTRN	__imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?KSG_StringSkipSymbol@@YA_NPAPADH@Z
_TEXT	SEGMENT
_ppszString$ = 8					; size = 4
_nSymbol$ = 12						; size = 4
?KSG_StringSkipSymbol@@YA_NPAPADH@Z PROC		; KSG_StringSkipSymbol, COMDAT

; 25   :     return KSG_StringSkipSymbol((const char **)ppszString, nSymbol);

	jmp	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z
?KSG_StringSkipSymbol@@YA_NPAPADH@Z ENDP		; KSG_StringSkipSymbol
_TEXT	ENDS
PUBLIC	??_7KMissle@@6B@				; KMissle::`vftable'
PUBLIC	??0KMissle@@QAE@XZ				; KMissle::KMissle
PUBLIC	??_R4KMissle@@6B@				; KMissle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVKMissle@@@8				; KMissle `RTTI Type Descriptor'
PUBLIC	??_R3KMissle@@8					; KMissle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KMissle@@8					; KMissle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@KMissle@@8			; KMissle::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??0KMissleRes@@QAE@XZ:PROC			; KMissleRes::KMissleRes
EXTRN	??_EKMissle@@UAEPAXI@Z:PROC			; KMissle::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@KMissle@@8
; File e:\x-project\#2.jx\source\sources\engine\src\knode.h
rdata$r	SEGMENT
??_R1A@?0A@EA@KMissle@@8 DD FLAT:??_R0?AVKMissle@@@8	; KMissle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KMissle@@8
rdata$r	ENDS
;	COMDAT ??_R2KMissle@@8
rdata$r	SEGMENT
??_R2KMissle@@8 DD FLAT:??_R1A@?0A@EA@KMissle@@8	; KMissle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3KMissle@@8
rdata$r	SEGMENT
??_R3KMissle@@8 DD 00H					; KMissle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2KMissle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKMissle@@@8
_DATA	SEGMENT
??_R0?AVKMissle@@@8 DD FLAT:??_7type_info@@6B@		; KMissle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKMissle@@', 00H
_DATA	ENDS
;	COMDAT ??_R4KMissle@@6B@
rdata$r	SEGMENT
??_R4KMissle@@6B@ DD 00H				; KMissle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKMissle@@@8
	DD	FLAT:??_R3KMissle@@8
rdata$r	ENDS
;	COMDAT ??_7KMissle@@6B@
CONST	SEGMENT
??_7KMissle@@6B@ DD FLAT:??_R4KMissle@@6B@		; KMissle::`vftable'
	DD	FLAT:??_EKMissle@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0KMissle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0KMissle@@QAE@XZ$0
__ehfuncinfo$??0KMissle@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0KMissle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmissle.cpp
xdata$x	ENDS
;	COMDAT ??0KMissle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0KMissle@@QAE@XZ PROC					; KMissle::KMissle, COMDAT
; _this$ = ecx

; 138  : {

	push	-1
	push	__ehhandler$??0KMissle@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], OFFSET ??_7KMissle@@6B@
	xor	edi, edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+4], OFFSET ??_7KIndexNode@@6B@
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	lea	ecx, DWORD PTR [esi+464]
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??0KMissleRes@@QAE@XZ			; KMissleRes::KMissleRes

; 139  : 	m_nMissleId = -1;
; 140  : 	m_nCollideOrVanishTime = 0;
; 141  : 	m_ulDamageInterval = 0;
; 142  : 	m_nTempParam1 = 0;
; 143  : 	m_nTempParam2 = 0;
; 144  : 	m_nFirstReclaimTime = 0;
; 145  : 	m_nEndReclaimTime = 0;
; 146  : 	
; 147  : #ifdef _SERVER
; 148  : 	m_pMagicAttribsData = NULL;
; 149  : 	m_ulNextCalDamageTime = 0;
; 150  : #else
; 151  : 	m_bFollowNpcWhenCollid = 1;
; 152  : 	m_bRemoving	= FALSE;
; 153  : 	m_btRedLum = m_btGreenLum = m_btBlueLum = 0xff;

	mov	eax, 255				; 000000ffH
	mov	DWORD PTR [esi+456], eax
	mov	DWORD PTR [esi+452], eax
	mov	DWORD PTR [esi+448], eax
	mov	DWORD PTR [esi+356], -1
	mov	DWORD PTR [esi+212], edi
	mov	DWORD PTR [esi+196], edi
	mov	DWORD PTR [esi+412], edi
	mov	DWORD PTR [esi+416], edi
	mov	DWORD PTR [esi+404], edi
	mov	DWORD PTR [esi+408], edi
	mov	DWORD PTR [esi+444], 1
	mov	DWORD PTR [esi+68], edi

; 154  : 	m_usLightRadius = 50;

	mov	WORD PTR [esi+460], 50			; 00000032H

; 155  : #endif
; 156  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0KMissle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1KIndexNode@@UAE@XZ
__ehhandler$??0KMissle@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0KMissle@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0KMissle@@QAE@XZ ENDP					; KMissle::KMissle
PUBLIC	?Release@KMissle@@AAEXXZ			; KMissle::Release
EXTRN	?Clear@KMissleRes@@QAEXXZ:PROC			; KMissleRes::Clear
EXTRN	?RemoveObject@KScenePlaceC@@QAEXIHAAI@Z:PROC	; KScenePlaceC::RemoveObject
EXTRN	?g_ScenePlace@@3VKScenePlaceC@@A:BYTE		; g_ScenePlace
; Function compile flags: /Ogtpy
;	COMDAT ?Release@KMissle@@AAEXXZ
_TEXT	SEGMENT
?Release@KMissle@@AAEXXZ PROC				; KMissle::Release, COMDAT
; _this$ = ecx

; 159  : {

	push	esi
	mov	esi, ecx

; 160  : ///#pragma	message(ATTENTION("子弹消亡时，需更新发送者使用该技能时的当前使用次数，使之减一"))
; 161  : #ifndef _SERVER	
; 162  : 	g_ScenePlace.RemoveObject(CGOG_MISSLE, m_nMissleId, m_SceneID);

	mov	ecx, DWORD PTR [esi+356]
	lea	eax, DWORD PTR [esi+2932]
	push	eax
	push	ecx
	push	9
	mov	ecx, OFFSET ?g_ScenePlace@@3VKScenePlaceC@@A ; g_ScenePlace
	call	?RemoveObject@KScenePlaceC@@QAEXIHAAI@Z	; KScenePlaceC::RemoveObject

; 163  : 	m_MissleRes.Clear();

	lea	ecx, DWORD PTR [esi+464]
	call	?Clear@KMissleRes@@QAEXXZ		; KMissleRes::Clear

; 164  : 	m_nMissleId = -1;

	mov	DWORD PTR [esi+356], -1

; 165  : 	m_nFollowNpcIdx = 0;

	mov	DWORD PTR [esi+324], 0
	pop	esi

; 166  : #endif
; 167  : #ifdef _SERVER
; 168  : 	if (m_pMagicAttribsData)
; 169  : 		if (m_pMagicAttribsData->DelRef() == 0)
; 170  : 			delete m_pMagicAttribsData;
; 171  : 		m_pMagicAttribsData = NULL;
; 172  : #endif
; 173  : }

	ret	0
?Release@KMissle@@AAEXXZ ENDP				; KMissle::Release
_TEXT	ENDS
PUBLIC	??1KMissle@@UAE@XZ				; KMissle::~KMissle
EXTRN	??1KMissleRes@@QAE@XZ:PROC			; KMissleRes::~KMissleRes
;	COMDAT xdata$x
; File e:\x-project\#2.jx\source\sources\engine\src\knode.h
xdata$x	SEGMENT
__unwindtable$??1KMissle@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1KMissle@@UAE@XZ$0
__ehfuncinfo$??1KMissle@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1KMissle@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmissle.cpp
xdata$x	ENDS
;	COMDAT ??1KMissle@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1KMissle@@UAE@XZ PROC					; KMissle::~KMissle, COMDAT
; _this$ = ecx

; 176  : {

	push	-1
	push	__ehhandler$??1KMissle@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7KMissle@@6B@

; 177  : 	
; 178  : }

	lea	ecx, DWORD PTR [esi+464]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??1KMissleRes@@QAE@XZ			; KMissleRes::~KMissleRes
	mov	DWORD PTR [esi+4], OFFSET ??_7KNode@@6B@
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1KMissle@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1KIndexNode@@UAE@XZ
__ehhandler$??1KMissle@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1KMissle@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1KMissle@@UAE@XZ ENDP					; KMissle::~KMissle
PUBLIC	??_C@_0BA@GDAGDNFN@ColFollowTarget?$AA@		; `string'
PUBLIC	??_C@_07ENECPCFF@SubStop?$AA@			; `string'
PUBLIC	??_C@_08LDEEPICG@SubStart?$AA@			; `string'
PUBLIC	??_C@_07CIOKCCJI@SubLoop?$AA@			; `string'
PUBLIC	??_C@_08KAEMHMEA@LoopPlay?$AA@			; `string'
PUBLIC	??_C@_0BA@FIDNIGBN@AnimFileInfoB?$CFd?$AA@	; `string'
PUBLIC	??_C@_0L@GKLHFOAD@SndFileB?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@HMKCHJCG@AnimFileB?$CFd?$AA@		; `string'
PUBLIC	??_C@_0P@LLOPAKJN@AnimFileInfo?$CFd?$AA@	; `string'
PUBLIC	??_C@_09OJFLPHLB@SndFile?$CFd?$AA@		; `string'
PUBLIC	??_C@_0L@JALDJHGO@AnimFile?$CFd?$AA@		; `string'
PUBLIC	??_C@_09NPEJILIG@MultiShow?$AA@			; `string'
PUBLIC	??_C@_0M@GNBGAFGI@LightRadius?$AA@		; `string'
PUBLIC	??_C@_07OEOFPPAM@BlueLum?$AA@			; `string'
PUBLIC	??_C@_08LJGOHPCB@GreenLum?$AA@			; `string'
PUBLIC	??_C@_06LBPJMPKP@RedLum?$AA@			; `string'
PUBLIC	??_C@_0M@KFGBNFHO@DmgInterval?$AA@		; `string'
PUBLIC	??_C@_0M@BOKIJCK@AutoExplode?$AA@		; `string'
PUBLIC	??_C@_06DGACALED@Param3?$AA@			; `string'
PUBLIC	??_C@_06CPBJDKAC@Param2?$AA@			; `string'
PUBLIC	??_C@_06EDEGJMB@Param1?$AA@			; `string'
PUBLIC	??_C@_06NCCHKJIB@Zspeed?$AA@			; `string'
PUBLIC	??_C@_04MMKFACPD@Zacc?$AA@			; `string'
PUBLIC	??_C@_0L@PGHGJNCL@FollowKind?$AA@		; `string'
PUBLIC	??_C@_08MCLEFPLG@MoveKind?$AA@			; `string'
PUBLIC	??_C@_08PEIIELCN@DmgRange?$AA@			; `string'
PUBLIC	??_C@_0L@IFIJAECJ@IsRangeDmg?$AA@		; `string'
PUBLIC	??_C@_07PEGFCGP@CanSlow?$AA@			; `string'
PUBLIC	??_C@_0N@IKLJCIGO@CanColFriend?$AA@		; `string'
PUBLIC	??_C@_09HFHEJGNK@ColVanish?$AA@			; `string'
PUBLIC	??_C@_0M@KKNFEODA@CollidRange?$AA@		; `string'
PUBLIC	??_C@_0O@LDEEIDCL@ResponseSkill?$AA@		; `string'
PUBLIC	??_C@_05HOIAGEJD@Speed?$AA@			; `string'
PUBLIC	??_C@_08INJDFBPH@LifeTime?$AA@			; `string'
PUBLIC	??_C@_0N@PHKKJBCM@MissleHeight?$AA@		; `string'
PUBLIC	??_C@_0L@GHFEFFIF@MissleName?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z ; KMissle::GetInfoFromTabFile
EXTRN	__imp__sprintf:PROC
;	COMDAT ??_C@_0BA@GDAGDNFN@ColFollowTarget?$AA@
CONST	SEGMENT
??_C@_0BA@GDAGDNFN@ColFollowTarget?$AA@ DB 'ColFollowTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ENECPCFF@SubStop?$AA@
CONST	SEGMENT
??_C@_07ENECPCFF@SubStop?$AA@ DB 'SubStop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LDEEPICG@SubStart?$AA@
CONST	SEGMENT
??_C@_08LDEEPICG@SubStart?$AA@ DB 'SubStart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIOKCCJI@SubLoop?$AA@
CONST	SEGMENT
??_C@_07CIOKCCJI@SubLoop?$AA@ DB 'SubLoop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KAEMHMEA@LoopPlay?$AA@
CONST	SEGMENT
??_C@_08KAEMHMEA@LoopPlay?$AA@ DB 'LoopPlay', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FIDNIGBN@AnimFileInfoB?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@FIDNIGBN@AnimFileInfoB?$CFd?$AA@ DB 'AnimFileInfoB%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKLHFOAD@SndFileB?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@GKLHFOAD@SndFileB?$CFd?$AA@ DB 'SndFileB%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HMKCHJCG@AnimFileB?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@HMKCHJCG@AnimFileB?$CFd?$AA@ DB 'AnimFileB%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LLOPAKJN@AnimFileInfo?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@LLOPAKJN@AnimFileInfo?$CFd?$AA@ DB 'AnimFileInfo%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJFLPHLB@SndFile?$CFd?$AA@
CONST	SEGMENT
??_C@_09OJFLPHLB@SndFile?$CFd?$AA@ DB 'SndFile%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JALDJHGO@AnimFile?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@JALDJHGO@AnimFile?$CFd?$AA@ DB 'AnimFile%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NPEJILIG@MultiShow?$AA@
CONST	SEGMENT
??_C@_09NPEJILIG@MultiShow?$AA@ DB 'MultiShow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNBGAFGI@LightRadius?$AA@
CONST	SEGMENT
??_C@_0M@GNBGAFGI@LightRadius?$AA@ DB 'LightRadius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEOFPPAM@BlueLum?$AA@
CONST	SEGMENT
??_C@_07OEOFPPAM@BlueLum?$AA@ DB 'BlueLum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJGOHPCB@GreenLum?$AA@
CONST	SEGMENT
??_C@_08LJGOHPCB@GreenLum?$AA@ DB 'GreenLum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LBPJMPKP@RedLum?$AA@
CONST	SEGMENT
??_C@_06LBPJMPKP@RedLum?$AA@ DB 'RedLum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFGBNFHO@DmgInterval?$AA@
CONST	SEGMENT
??_C@_0M@KFGBNFHO@DmgInterval?$AA@ DB 'DmgInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BOKIJCK@AutoExplode?$AA@
CONST	SEGMENT
??_C@_0M@BOKIJCK@AutoExplode?$AA@ DB 'AutoExplode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DGACALED@Param3?$AA@
CONST	SEGMENT
??_C@_06DGACALED@Param3?$AA@ DB 'Param3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CPBJDKAC@Param2?$AA@
CONST	SEGMENT
??_C@_06CPBJDKAC@Param2?$AA@ DB 'Param2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDEGJMB@Param1?$AA@
CONST	SEGMENT
??_C@_06EDEGJMB@Param1?$AA@ DB 'Param1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCCHKJIB@Zspeed?$AA@
CONST	SEGMENT
??_C@_06NCCHKJIB@Zspeed?$AA@ DB 'Zspeed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MMKFACPD@Zacc?$AA@
CONST	SEGMENT
??_C@_04MMKFACPD@Zacc?$AA@ DB 'Zacc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGHGJNCL@FollowKind?$AA@
CONST	SEGMENT
??_C@_0L@PGHGJNCL@FollowKind?$AA@ DB 'FollowKind', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MCLEFPLG@MoveKind?$AA@
CONST	SEGMENT
??_C@_08MCLEFPLG@MoveKind?$AA@ DB 'MoveKind', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PEIIELCN@DmgRange?$AA@
CONST	SEGMENT
??_C@_08PEIIELCN@DmgRange?$AA@ DB 'DmgRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IFIJAECJ@IsRangeDmg?$AA@
CONST	SEGMENT
??_C@_0L@IFIJAECJ@IsRangeDmg?$AA@ DB 'IsRangeDmg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEGFCGP@CanSlow?$AA@
CONST	SEGMENT
??_C@_07PEGFCGP@CanSlow?$AA@ DB 'CanSlow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKLJCIGO@CanColFriend?$AA@
CONST	SEGMENT
??_C@_0N@IKLJCIGO@CanColFriend?$AA@ DB 'CanColFriend', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFHEJGNK@ColVanish?$AA@
CONST	SEGMENT
??_C@_09HFHEJGNK@ColVanish?$AA@ DB 'ColVanish', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KKNFEODA@CollidRange?$AA@
CONST	SEGMENT
??_C@_0M@KKNFEODA@CollidRange?$AA@ DB 'CollidRange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDEEIDCL@ResponseSkill?$AA@
CONST	SEGMENT
??_C@_0O@LDEEIDCL@ResponseSkill?$AA@ DB 'ResponseSkill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HOIAGEJD@Speed?$AA@
CONST	SEGMENT
??_C@_05HOIAGEJD@Speed?$AA@ DB 'Speed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08INJDFBPH@LifeTime?$AA@
CONST	SEGMENT
??_C@_08INJDFBPH@LifeTime?$AA@ DB 'LifeTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PHKKJBCM@MissleHeight?$AA@
CONST	SEGMENT
??_C@_0N@PHKKJBCM@MissleHeight?$AA@ DB 'MissleHeight', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GHFEFFIF@MissleName?$AA@
CONST	SEGMENT
??_C@_0L@GHFEFFIF@MissleName?$AA@ DB 'MissleName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z
_TEXT	SEGMENT
_pcszTemp$ = -356					; size = 4
_bAutoExplode$ = -352					; size = 4
_nLightRadius$ = -348					; size = 4
tv599 = -344						; size = 4
_nHeightOld$ = -340					; size = 4
_this$GSCopy$ = -336					; size = 4
_SndFileCol$ = -332					; size = 64
_AnimFileCol$ = -268					; size = 64
_AnimFileInfoCol$ = -204				; size = 100
_szAnimFileInfo$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_pMisslesSetting$ = 8					; size = 4
_nMissleId$ = 12					; size = 4
?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z PROC	; KMissle::GetInfoFromTabFile, COMDAT
; _this$ = ecx

; 195  : {

	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+356], eax
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pMisslesSetting$[esp+364]
	push	edi

; 196  : 	if (nMissleId <= 0 ) return FALSE;

	mov	edi, DWORD PTR _nMissleId$[esp+368]
	xor	ebp, ebp
	cmp	edi, ebp
	mov	ebx, ecx

; 246  : 	for (int i  = 0; i < MAX_MISSLE_STATUS; i++)
; 247  : 	{
; 248  : 		sprintf(AnimFileCol, "AnimFile%d", i + 1);

	mov	DWORD PTR _this$GSCopy$[esp+372], ebx
	jg	SHORT $LN4@GetInfoFro

; 196  : 	if (nMissleId <= 0 ) return FALSE;

	xor	eax, eax
	jmp	$LN5@GetInfoFro
$LN4@GetInfoFro:

; 197  : 	m_nMissleId		= nMissleId;
; 198  : 	int nRow = nMissleId;
; 199  : 	
; 200  : 	pMisslesSetting->GetString(nRow, "MissleName",		   "", m_szMissleName,30, TRUE);

	push	1
	push	30					; 0000001eH
	lea	ecx, DWORD PTR [ebx+24]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	DWORD PTR [ebx+356], edi
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+36]
	push	OFFSET ??_C@_0L@GHFEFFIF@MissleName?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 201  : 	
; 202  : 	int nHeightOld ;
; 203  : 	pMisslesSetting->GetInteger(nRow, "MissleHeight",		0, &nHeightOld, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR _nHeightOld$[esp+376]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0N@PHKKJBCM@MissleHeight?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 204  : 	m_nHeight = nHeightOld << 10;

	mov	eax, DWORD PTR _nHeightOld$[esp+372]
	shl	eax, 10					; 0000000aH

; 205  : 	
; 206  : 	pMisslesSetting->GetInteger(nRow, "LifeTime",			0, &m_nLifeTime, TRUE);

	push	1
	mov	DWORD PTR [ebx+84], eax
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+48]
	lea	eax, DWORD PTR [ebx+92]
	push	eax
	push	ebp
	push	OFFSET ??_C@_08INJDFBPH@LifeTime?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 207  : 	pMisslesSetting->GetInteger(nRow, "Speed",				0, &m_nSpeed, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+96]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_05HOIAGEJD@Speed?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 208  : 	pMisslesSetting->GetInteger(nRow, "ResponseSkill",		0, &m_nSkillId, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+100]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0O@LDEEIDCL@ResponseSkill?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 209  : 	pMisslesSetting->GetInteger(nRow, "CollidRange",		0, &m_nCollideRange, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+144]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0M@KKNFEODA@CollidRange?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 210  : 	pMisslesSetting->GetInteger(nRow, "ColVanish",			0, &m_bCollideVanish, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+152]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_09HFHEJGNK@ColVanish?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 211  : 	pMisslesSetting->GetInteger(nRow, "CanColFriend",		0, &m_bCollideFriend, TRUE);

	mov	eax, DWORD PTR [esi]
	push	1
	lea	ecx, DWORD PTR [ebx+156]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0N@IKLJCIGO@CanColFriend?$AA@
	mov	edx, DWORD PTR [eax+48]
	push	edi
	mov	ecx, esi
	call	edx

; 212  : 	pMisslesSetting->GetInteger(nRow, "CanSlow",			0, &m_bCanSlow, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+160]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_07PEGFCGP@CanSlow?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 213  : 	pMisslesSetting->GetInteger(nRow, "IsRangeDmg",		0, &m_bRangeDamage, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+104]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0L@IFIJAECJ@IsRangeDmg?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 214  : 	pMisslesSetting->GetInteger(nRow, "DmgRange",			0, &m_nDamageRange, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+148]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_08PEIIELCN@DmgRange?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 215  : 	pMisslesSetting->GetInteger(nRow, "MoveKind",			0, (int*)&m_eMoveKind, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+76]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_08MCLEFPLG@MoveKind?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 216  : 	pMisslesSetting->GetInteger(nRow, "FollowKind",		0, (int*)&m_eFollowKind, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+80]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0L@PGHGJNCL@FollowKind?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 217  : 	pMisslesSetting->GetInteger(nRow, "Zacc",				0,(int*)&m_nZAcceleration, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+348]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_04MMKFACPD@Zacc?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 218  : 	pMisslesSetting->GetInteger(nRow, "Zspeed",				0,(int*)&m_nHeightSpeed, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+88]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_06NCCHKJIB@Zspeed?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 219  : 	pMisslesSetting->GetInteger(nRow, "Param1",			0, &m_nParam1, TRUE);

	mov	eax, DWORD PTR [esi]
	push	1
	lea	ecx, DWORD PTR [ebx+392]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_06EDEGJMB@Param1?$AA@
	push	edi
	mov	edx, DWORD PTR [eax+48]
	mov	ecx, esi
	call	edx

; 220  : 	pMisslesSetting->GetInteger(nRow, "Param2",			0, &m_nParam2, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+396]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_06CPBJDKAC@Param2?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 221  : 	pMisslesSetting->GetInteger(nRow, "Param3",			0, &m_nParam3, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+400]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_06DGACALED@Param3?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 222  : 	
; 223  : 	BOOL bAutoExplode = 0;
; 224  : 	pMisslesSetting->GetInteger(nRow, "AutoExplode",	0, (int*)&bAutoExplode, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR _bAutoExplode$[esp+376]
	push	ecx
	push	ebp
	push	OFFSET ??_C@_0M@BOKIJCK@AutoExplode?$AA@
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _bAutoExplode$[esp+392], ebp
	call	edx

; 225  : 	m_bAutoExplode = bAutoExplode;

	mov	eax, DWORD PTR _bAutoExplode$[esp+372]

; 226  : 	
; 227  : 	pMisslesSetting->GetInteger(nRow, "DmgInterval",	0, (int*)&m_ulDamageInterval, TRUE);

	push	1
	mov	DWORD PTR [ebx+112], eax
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+48]
	lea	eax, DWORD PTR [ebx+196]
	push	eax
	push	ebp
	push	OFFSET ??_C@_0M@KFGBNFHO@DmgInterval?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 228  : 	
; 229  : #ifndef _SERVER	
; 230  : 	char AnimFileCol[64];
; 231  : 	char SndFileCol[64];
; 232  : 	char AnimFileInfoCol[100];
; 233  : 	char szAnimFileInfo[100];
; 234  : 
; 235  :     const char *pcszTemp = NULL;
; 236  : 	
; 237  : 	pMisslesSetting->GetInteger(nRow, "RedLum",	    255, (int*)&m_btRedLum, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+448]
	push	ecx
	push	255					; 000000ffH
	push	OFFSET ??_C@_06LBPJMPKP@RedLum?$AA@
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _pcszTemp$[esp+392], ebp
	call	edx

; 238  : 	pMisslesSetting->GetInteger(nRow, "GreenLum",	255, (int*)&m_btGreenLum, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+452]
	push	ecx
	push	255					; 000000ffH
	push	OFFSET ??_C@_08LJGOHPCB@GreenLum?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 239  : 	pMisslesSetting->GetInteger(nRow, "BlueLum",	255, (int*)&m_btBlueLum, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+456]
	push	ecx
	push	255					; 000000ffH
	push	OFFSET ??_C@_07OEOFPPAM@BlueLum?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 240  : 	
; 241  : 	int nLightRadius = 0;
; 242  : 	pMisslesSetting->GetInteger(nRow, "LightRadius", 50, (int*)&nLightRadius, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _nLightRadius$[esp+372], ebp
	push	1
	lea	ecx, DWORD PTR _nLightRadius$[esp+376]
	mov	edx, DWORD PTR [eax+48]
	push	ecx
	push	50					; 00000032H
	push	OFFSET ??_C@_0M@GNBGAFGI@LightRadius?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 243  : 	m_usLightRadius = nLightRadius;

	mov	ax, WORD PTR _nLightRadius$[esp+372]

; 244  : 	
; 245  : 	pMisslesSetting->GetInteger(nRow, "MultiShow",		0, &m_bMultiShow, TRUE);

	push	1
	mov	WORD PTR [ebx+460], ax
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+48]
	lea	eax, DWORD PTR [ebx+440]
	push	eax
	push	ebp
	push	OFFSET ??_C@_09NPEJILIG@MultiShow?$AA@
	push	edi
	mov	ecx, esi
	call	edx
	mov	ebp, 1
	add	ebx, 608				; 00000260H
	mov	DWORD PTR tv599[esp+372], 4
$LL3@GetInfoFro:

; 246  : 	for (int i  = 0; i < MAX_MISSLE_STATUS; i++)
; 247  : 	{
; 248  : 		sprintf(AnimFileCol, "AnimFile%d", i + 1);

	push	ebp
	lea	eax, DWORD PTR _AnimFileCol$[esp+376]
	push	OFFSET ??_C@_0L@JALDJHGO@AnimFile?$CFd?$AA@
	push	eax
	call	DWORD PTR __imp__sprintf

; 249  : 		sprintf(SndFileCol,  "SndFile%d", i + 1);

	push	ebp
	lea	ecx, DWORD PTR _SndFileCol$[esp+388]
	push	OFFSET ??_C@_09OJFLPHLB@SndFile?$CFd?$AA@
	push	ecx
	call	DWORD PTR __imp__sprintf

; 250  : 		sprintf(AnimFileInfoCol, "AnimFileInfo%d", i + 1);

	push	ebp
	lea	edx, DWORD PTR _AnimFileInfoCol$[esp+400]
	push	OFFSET ??_C@_0P@LLOPAKJN@AnimFileInfo?$CFd?$AA@
	push	edx
	call	DWORD PTR __imp__sprintf

; 251  : 		
; 252  : 		pMisslesSetting->GetString(nRow, AnimFileCol,			"", m_MissleRes.m_MissleRes[i].AnimFileName, 64, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+36]
	add	esp, 36					; 00000024H
	push	1
	push	64					; 00000040H
	lea	ecx, DWORD PTR [ebx-112]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR _AnimFileCol$[esp+388]
	push	edx
	push	edi
	mov	ecx, esi
	call	eax

; 253  : 		pMisslesSetting->GetString(nRow, SndFileCol,			"", m_MissleRes.m_MissleRes[i].SndFileName, 64, TRUE);

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+36]
	push	1
	push	64					; 00000040H
	push	ebx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR _SndFileCol$[esp+388]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx

; 254  : 		pMisslesSetting->GetString(nRow, AnimFileInfoCol,		"", szAnimFileInfo, 100, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+36]
	push	1
	push	100					; 00000064H
	lea	ecx, DWORD PTR _szAnimFileInfo$[esp+380]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR _AnimFileInfoCol$[esp+388]
	push	edx
	push	edi
	mov	ecx, esi
	call	eax

; 255  : 		
; 256  : 		//m_MissleRes.m_MissleRes[i].nInterval = 1;
; 257  : 		//m_MissleRes.m_MissleRes[i].nDir = 16;
; 258  : 		//m_MissleRes.m_MissleRes[i].nTotalFrame = 100;
; 259  : 
; 260  :         pcszTemp = szAnimFileInfo;
; 261  :         m_MissleRes.m_MissleRes[i].nTotalFrame = KSG_StringGetInt(&pcszTemp, 100);

	lea	edx, DWORD PTR _pcszTemp$[esp+372]
	lea	ecx, DWORD PTR _szAnimFileInfo$[esp+372]
	push	100					; 00000064H
	push	edx
	mov	DWORD PTR _pcszTemp$[esp+380], ecx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	mov	DWORD PTR [ebx-12], eax

; 262  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	eax, DWORD PTR _pcszTemp$[esp+380]
	push	44					; 0000002cH
	push	eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 263  :         m_MissleRes.m_MissleRes[i].nDir = KSG_StringGetInt(&pcszTemp, 16);

	lea	ecx, DWORD PTR _pcszTemp$[esp+388]
	push	16					; 00000010H
	push	ecx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 264  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	edx, DWORD PTR _pcszTemp$[esp+396]
	push	44					; 0000002cH
	push	edx
	mov	DWORD PTR [ebx-4], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 265  :         m_MissleRes.m_MissleRes[i].nInterval = KSG_StringGetInt(&pcszTemp, 1);

	lea	eax, DWORD PTR _pcszTemp$[esp+404]
	push	1
	push	eax
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 266  : 		//sscanf(szAnimFileInfo, "%d,%d,%d", 
; 267  : 		//	&m_MissleRes.m_MissleRes[i].nTotalFrame,
; 268  : 		//	&m_MissleRes.m_MissleRes[i].nDir,
; 269  : 		//	&m_MissleRes.m_MissleRes[i].nInterval
; 270  :         //);
; 271  : 
; 272  : 		
; 273  : 		sprintf(AnimFileCol, "AnimFileB%d", i + 1);

	push	ebp
	lea	ecx, DWORD PTR _AnimFileCol$[esp+416]
	push	OFFSET ??_C@_0M@HMKCHJCG@AnimFileB?$CFd?$AA@
	push	ecx
	mov	DWORD PTR [ebx-8], eax
	call	DWORD PTR __imp__sprintf

; 274  : 		sprintf(SndFileCol,  "SndFileB%d", i + 1);

	push	ebp
	lea	edx, DWORD PTR _SndFileCol$[esp+428]
	push	OFFSET ??_C@_0L@GKLHFOAD@SndFileB?$CFd?$AA@
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 64					; 00000040H

; 275  : 		sprintf(AnimFileInfoCol, "AnimFileInfoB%d", i + 1);

	push	ebp
	lea	eax, DWORD PTR _AnimFileInfoCol$[esp+376]
	push	OFFSET ??_C@_0BA@FIDNIGBN@AnimFileInfoB?$CFd?$AA@
	push	eax
	call	DWORD PTR __imp__sprintf

; 276  : 		
; 277  : 		pMisslesSetting->GetString(nRow, AnimFileCol,			"", m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].AnimFileName, 64, TRUE);

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+36]
	add	esp, 12					; 0000000cH
	push	1
	push	64					; 00000040H
	lea	eax, DWORD PTR [ebx+736]
	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _AnimFileCol$[esp+388]
	push	ecx
	push	edi
	mov	ecx, esi
	call	edx

; 278  : 		pMisslesSetting->GetString(nRow, SndFileCol,			"", m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].SndFileName, 64, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+36]
	push	1
	push	64					; 00000040H
	lea	ecx, DWORD PTR [ebx+848]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	edx, DWORD PTR _SndFileCol$[esp+388]
	push	edx
	push	edi
	mov	ecx, esi
	call	eax

; 279  : 		pMisslesSetting->GetString(nRow, AnimFileInfoCol,		"", szAnimFileInfo, 100, TRUE);

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+36]
	push	1
	push	100					; 00000064H
	lea	eax, DWORD PTR _szAnimFileInfo$[esp+380]
	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _AnimFileInfoCol$[esp+388]
	push	ecx
	push	edi
	mov	ecx, esi
	call	edx

; 280  : 		
; 281  : 		//m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nInterval = 1;
; 282  : 		//m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nDir = 16;
; 283  : 		//m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nTotalFrame = 100;
; 284  : 		
; 285  :         pcszTemp = szAnimFileInfo;
; 286  :         m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nTotalFrame = KSG_StringGetInt(&pcszTemp, 100);

	lea	ecx, DWORD PTR _pcszTemp$[esp+372]
	lea	eax, DWORD PTR _szAnimFileInfo$[esp+372]
	push	100					; 00000064H
	push	ecx
	mov	DWORD PTR _pcszTemp$[esp+380], eax
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 287  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	edx, DWORD PTR _pcszTemp$[esp+380]
	push	44					; 0000002cH
	push	edx
	mov	DWORD PTR [ebx+836], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 288  :         m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nDir = KSG_StringGetInt(&pcszTemp, 16);

	lea	eax, DWORD PTR _pcszTemp$[esp+388]
	push	16					; 00000010H
	push	eax
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 289  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	ecx, DWORD PTR _pcszTemp$[esp+396]
	push	44					; 0000002cH
	push	ecx
	mov	DWORD PTR [ebx+844], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 290  :         m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nInterval = KSG_StringGetInt(&pcszTemp, 1);

	lea	edx, DWORD PTR _pcszTemp$[esp+404]
	push	1
	push	edx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	mov	DWORD PTR [ebx+840], eax
	add	esp, 40					; 00000028H
	add	ebp, 1
	add	ebx, 212				; 000000d4H
	sub	DWORD PTR tv599[esp+372], 1
	jne	$LL3@GetInfoFro

; 291  : 
; 292  : 		//sscanf(szAnimFileInfo, "%d,%d,%d", 
; 293  : 		//	&m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nTotalFrame,
; 294  : 		//	&m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nDir,
; 295  : 		//	&m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nInterval
; 296  :         //);
; 297  : 		
; 298  : 	}
; 299  : 	pMisslesSetting->GetInteger(nRow, "LoopPlay",			0, &m_MissleRes.m_bLoopAnim, TRUE);

	mov	ebx, DWORD PTR _this$GSCopy$[esp+372]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+492]
	push	ecx
	push	0
	push	OFFSET ??_C@_08KAEMHMEA@LoopPlay?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 300  : 	pMisslesSetting->GetInteger(nRow, "SubLoop",		0, &m_MissleRes.m_bSubLoop, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+2244]
	push	ecx
	push	0
	push	OFFSET ??_C@_07CIOKCCJI@SubLoop?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 301  : 	pMisslesSetting->GetInteger(nRow, "SubStart",		0, &m_MissleRes.m_nSubStart, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+2248]
	push	ecx
	push	0
	push	OFFSET ??_C@_08LDEEPICG@SubStart?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 302  : 	pMisslesSetting->GetInteger(nRow, "SubStop",		0, &m_MissleRes.m_nSubStop, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	lea	ecx, DWORD PTR [ebx+2252]
	push	ecx
	push	0
	push	OFFSET ??_C@_07ENECPCFF@SubStop?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 303  : 	pMisslesSetting->GetInteger(nRow, "ColFollowTarget",0, (int *)&m_bFollowNpcWhenCollid, TRUE);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+48]
	push	1
	add	ebx, 444				; 000001bcH
	push	ebx
	push	0
	push	OFFSET ??_C@_0BA@GDAGDNFN@ColFollowTarget?$AA@
	push	edi
	mov	ecx, esi
	call	edx

; 304  : #endif
; 305  : 	return TRUE;

	mov	eax, 1
$LN5@GetInfoFro:

; 306  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	ret	8
?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z ENDP	; KMissle::GetInfoFromTabFile
_TEXT	ENDS
PUBLIC	?Init@KMissle@@AAEHHHHHH@Z			; KMissle::Init
EXTRN	?Init@KMissleRes@@QAEHXZ:PROC			; KMissleRes::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@KMissle@@AAEHHHHHH@Z
_TEXT	SEGMENT
_nLauncher$ = 8						; size = 4
_nMissleId$ = 12					; size = 4
_nXFactor$ = 16						; size = 4
_nYFactor$ = 20						; size = 4
_nLevel$ = 24						; size = 4
?Init@KMissle@@AAEHHHHHH@Z PROC				; KMissle::Init, COMDAT
; _this$ = ecx

; 310  : #ifndef _SERVER
; 311  : 	m_MissleRes.Init();

	add	ecx, 464				; 000001d0H
	call	?Init@KMissleRes@@QAEHXZ		; KMissleRes::Init

; 312  : #endif
; 313  : 	return	TRUE;

	mov	eax, 1

; 314  : }

	ret	20					; 00000014H
?Init@KMissle@@AAEHHHHHH@Z ENDP				; KMissle::Init
_TEXT	ENDS
PUBLIC	?OnWait@KMissle@@AAEXXZ				; KMissle::OnWait
; Function compile flags: /Ogtpy
;	COMDAT ?OnWait@KMissle@@AAEXXZ
_TEXT	SEGMENT
?OnWait@KMissle@@AAEXXZ PROC				; KMissle::OnWait, COMDAT
; _this$ = ecx

; 456  : 	return;
; 457  : }

	ret	0
?OnWait@KMissle@@AAEXXZ ENDP				; KMissle::OnWait
_TEXT	ENDS
PUBLIC	?OnCollision@KMissle@@AAEXXZ			; KMissle::OnCollision
; Function compile flags: /Ogtpy
;	COMDAT ?OnCollision@KMissle@@AAEXXZ
_TEXT	SEGMENT
?OnCollision@KMissle@@AAEXXZ PROC			; KMissle::OnCollision, COMDAT
; _this$ = ecx

; 467  : 	return;	
; 468  : }

	ret	0
?OnCollision@KMissle@@AAEXXZ ENDP			; KMissle::OnCollision
_TEXT	ENDS
PUBLIC	?OnVanish@KMissle@@AAEXXZ			; KMissle::OnVanish
; Function compile flags: /Ogtpy
;	COMDAT ?OnVanish@KMissle@@AAEXXZ
_TEXT	SEGMENT
?OnVanish@KMissle@@AAEXXZ PROC				; KMissle::OnVanish, COMDAT
; _this$ = ecx

; 828  : 	
; 829  : }

	ret	0
?OnVanish@KMissle@@AAEXXZ ENDP				; KMissle::OnVanish
_TEXT	ENDS
PUBLIC	??4KMissle@@AAEAAV0@AAV0@@Z			; KMissle::operator=
EXTRN	__imp_?g_Random@@YAII@Z:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4KMissle@@AAEAAV0@AAV0@@Z
_TEXT	SEGMENT
tv1162 = 8						; size = 4
_Missle$ = 8						; size = 4
??4KMissle@@AAEAAV0@AAV0@@Z PROC			; KMissle::operator=, COMDAT
; _this$ = ecx

; 965  : {

	push	ebx
	push	ebp
	push	esi

; 966  : 	Missle.m_nTempParam1	=	0;

	mov	esi, DWORD PTR _Missle$[esp+8]
	xor	ebx, ebx
	push	edi

; 967  : 	Missle.m_nTempParam2	=	0;
; 968  : 	Missle.m_nDesMapX			=	0;
; 969  : 	Missle.m_nDesMapY			=	0;
; 970  : 	Missle.m_nDesRegion		=	0;
; 971  : 	Missle.m_bNeedReclaim	=	FALSE;
; 972  : 	Missle.m_nFirstReclaimTime = 0;
; 973  : 	Missle.m_nEndReclaimTime = 0;
; 974  : 	memset(Missle.m_NeedReclaimPos, 0, sizeof(m_NeedReclaimPos));

	push	48					; 00000030H
	lea	eax, DWORD PTR [esi+260]
	push	ebx
	push	eax
	mov	edi, ecx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+244], ebx
	mov	DWORD PTR [esi+248], ebx
	mov	DWORD PTR [esi+252], ebx
	mov	DWORD PTR [esi+256], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	call	_memset

; 975  : 
; 976  : 	Missle.m_bCanSlow		=	m_bCanSlow;

	mov	ecx, DWORD PTR [edi+160]
	mov	DWORD PTR [esi+160], ecx

; 977  : 	Missle.m_bCollideEvent	=	m_bCollideEvent;

	mov	edx, DWORD PTR [edi+188]
	mov	DWORD PTR [esi+188], edx

; 978  : 	Missle.m_bCollideFriend =	m_bCollideFriend;

	mov	eax, DWORD PTR [edi+156]
	mov	DWORD PTR [esi+156], eax

; 979  : 	Missle.m_bCollideVanish	=	m_bCollideVanish;

	mov	ecx, DWORD PTR [edi+152]
	mov	DWORD PTR [esi+152], ecx

; 980  : 	Missle.m_bRangeDamage	=	m_bRangeDamage;

	mov	edx, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], edx

; 981  : 	Missle.m_eFollowKind	=	m_eFollowKind;

	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax

; 982  : 	Missle.m_eMoveKind		=	m_eMoveKind;

	mov	ecx, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], ecx

; 983  : 	Missle.m_nAction		=	m_nAction;

	mov	edx, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], edx

; 984  : 	Missle.m_nAngle			=	m_nAngle;

	mov	eax, DWORD PTR [edi+428]
	mov	DWORD PTR [esi+428], eax

; 985  : 	Missle.m_nCollideRange	=	m_nCollideRange;

	mov	ecx, DWORD PTR [edi+144]
	mov	DWORD PTR [esi+144], ecx

; 986  : 	Missle.m_nCurrentLife	=	0;

	mov	DWORD PTR [esi+204], ebx

; 987  : 	Missle.m_nDamageRange	=	m_nDamageRange;

	mov	edx, DWORD PTR [edi+148]
	mov	DWORD PTR [esi+148], edx

; 988  : 	Missle.m_nHeight		=	m_nHeight;

	mov	eax, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], eax

; 989  : 	Missle.m_nLifeTime		=	m_nLifeTime;

	mov	ecx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], ecx

; 990  : 	Missle.m_nSpeed			=   m_nSpeed;

	mov	edx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], edx

; 991  : 	Missle.m_nParam1		=	m_nParam1;

	mov	eax, DWORD PTR [edi+392]
	mov	DWORD PTR [esi+392], eax

; 992  : 	Missle.m_nParam2		=	m_nParam2;

	mov	ecx, DWORD PTR [edi+396]
	mov	DWORD PTR [esi+396], ecx

; 993  : 	Missle.m_nParam3		=	m_nParam3;

	mov	edx, DWORD PTR [edi+400]
	mov	DWORD PTR [esi+400], edx

; 994  : 	Missle.m_nCurrentMapZ	=   m_nHeight >> 10;

	mov	eax, DWORD PTR [edi+84]
	sar	eax, 10					; 0000000aH
	mov	DWORD PTR [esi+224], eax

; 995  : 	Missle.m_bFlyEvent		=	m_bFlyEvent;

	mov	ecx, DWORD PTR [edi+172]
	mov	DWORD PTR [esi+172], ecx

; 996  : 	Missle.m_nFlyEventTime  =	m_nFlyEventTime;

	mov	edx, DWORD PTR [edi+176]
	mov	DWORD PTR [esi+176], edx

; 997  : 	Missle.m_nZAcceleration =	m_nZAcceleration;

	mov	eax, DWORD PTR [edi+348]
	mov	DWORD PTR [esi+348], eax

; 998  : 	Missle.m_nHeightSpeed	=	m_nHeightSpeed;

	mov	ecx, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], ecx

; 999  : 	Missle.m_bAutoExplode	=	m_bAutoExplode;

	mov	edx, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], edx

; 1000 : 	Missle.m_ulDamageInterval = m_ulDamageInterval;

	mov	eax, DWORD PTR [edi+196]
	mov	DWORD PTR [esi+196], eax

; 1001 : 	strcpy(Missle.m_szMissleName	,	m_szMissleName);

	lea	eax, DWORD PTR [edi+24]
	mov	ecx, esi
	add	esp, 12					; 0000000cH
	sub	ecx, eax
	lea	edx, DWORD PTR [ecx+24]
$LL9@operator:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	add	eax, 1
	cmp	cl, bl
	jne	SHORT $LL9@operator

; 1002 : 	
; 1003 : #ifndef  _SERVER
; 1004 : 	Missle.m_bMultiShow		=  m_bMultiShow;

	mov	edx, DWORD PTR [edi+440]
	mov	DWORD PTR [esi+440], edx

; 1005 : 	Missle.m_MissleRes.m_bLoopAnim = m_MissleRes.m_bLoopAnim;

	mov	eax, DWORD PTR [edi+492]
	mov	DWORD PTR [esi+492], eax

; 1006 : 	Missle.m_MissleRes.m_bHaveEnd = FALSE;

	mov	DWORD PTR [esi+488], ebx

; 1007 : 	Missle.m_btRedLum		= m_btRedLum;

	mov	ecx, DWORD PTR [edi+448]
	mov	DWORD PTR [esi+448], ecx

; 1008 : 	Missle.m_btGreenLum		= m_btGreenLum;

	mov	edx, DWORD PTR [edi+452]
	mov	DWORD PTR [esi+452], edx

; 1009 : 	Missle.m_btBlueLum		= m_btBlueLum;

	mov	eax, DWORD PTR [edi+456]
	mov	DWORD PTR [esi+456], eax

; 1010 : 	Missle.m_usLightRadius	= m_usLightRadius;

	mov	cx, WORD PTR [edi+460]
	mov	WORD PTR [esi+460], cx

; 1011 : 	int nOffset = 0;

	xor	eax, eax

; 1012 : 	
; 1013 : 	//如果是相同的子弹可以以不同方式显示时，则随机产生
; 1014 : 	if (m_bMultiShow)		

	cmp	DWORD PTR [edi+440], ebx
	je	SHORT $LN17@operator

; 1015 : 	{
; 1016 : 		if (g_Random(2) == 0)

	push	2
	call	DWORD PTR __imp_?g_Random@@YAII@Z
	add	esp, 4
	neg	eax
	sbb	eax, eax
	and	eax, 4
$LN17@operator:

; 1017 : 		{
; 1018 : 			nOffset = 0;
; 1019 : 		}
; 1020 : 		else
; 1021 : 			nOffset = MAX_MISSLE_STATUS;
; 1022 : 	}
; 1023 : 	
; 1024 : 	for (int t = 0; t < MAX_MISSLE_STATUS ; t++)

	imul	eax, 212				; 000000d4H
	lea	ebp, DWORD PTR [esi+596]
	lea	edx, DWORD PTR [eax+edi+496]
	mov	DWORD PTR tv1162[esp+12], 4
	npad	5
$LL3@operator:

; 1025 : 	{
; 1026 : 		strcpy(Missle.m_MissleRes.m_MissleRes[t].AnimFileName,m_MissleRes.m_MissleRes[t + nOffset].AnimFileName);

	mov	ecx, ebp
	sub	ecx, edx
	mov	eax, edx
	lea	ebx, DWORD PTR [ecx-100]
	npad	7
$LL10@operator:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [ebx+eax], cl
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL10@operator

; 1027 : 		
; 1028 : 		Missle.m_MissleRes.m_MissleRes[t].nTotalFrame = m_MissleRes.m_MissleRes[t + nOffset].nTotalFrame;

	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR [ebp], eax

; 1029 : 		Missle.m_MissleRes.m_MissleRes[t].nDir = m_MissleRes.m_MissleRes[t + nOffset].nDir;

	mov	ecx, DWORD PTR [edx+108]
	mov	DWORD PTR [ebp+8], ecx

; 1030 : 		Missle.m_MissleRes.m_MissleRes[t].nInterval = m_MissleRes.m_MissleRes[t + nOffset].nInterval;

	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR [ebp+4], eax

; 1031 : 		
; 1032 : 		strcpy(Missle.m_MissleRes.m_MissleRes[t].SndFileName,m_MissleRes.m_MissleRes[t + nOffset].SndFileName);

	lea	eax, DWORD PTR [edx+112]
	mov	ecx, ebp
	sub	ecx, eax
	lea	ebx, DWORD PTR [ecx+12]
$LL11@operator:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [ebx+eax], cl
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL11@operator
	add	ebp, 212				; 000000d4H
	add	edx, 212				; 000000d4H
	sub	DWORD PTR tv1162[esp+12], 1
	jne	SHORT $LL3@operator

; 1033 : 	}
; 1034 : 	Missle.m_MissleRes.m_bSubLoop = m_MissleRes.m_bSubLoop;

	mov	edx, DWORD PTR [edi+2244]
	mov	DWORD PTR [esi+2244], edx

; 1035 : 	Missle.m_MissleRes.m_nSubStart = m_MissleRes.m_nSubStart;

	mov	eax, DWORD PTR [edi+2248]
	mov	DWORD PTR [esi+2248], eax

; 1036 : 	Missle.m_MissleRes.m_nSubStop = m_MissleRes.m_nSubStop;

	mov	ecx, DWORD PTR [edi+2252]
	pop	edi
	mov	DWORD PTR [esi+2252], ecx

; 1037 : #endif	
; 1038 : 	
; 1039 : 	return (Missle);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1040 : }

	ret	4
??4KMissle@@AAEAAV0@AAV0@@Z ENDP			; KMissle::operator=
_TEXT	ENDS
PUBLIC	?ProcessDamage@KMissle@@AAEHH@Z			; KMissle::ProcessDamage
; Function compile flags: /Ogtpy
;	COMDAT ?ProcessDamage@KMissle@@AAEHH@Z
_TEXT	SEGMENT
_nNpcId$ = 8						; size = 4
?ProcessDamage@KMissle@@AAEHH@Z PROC			; KMissle::ProcessDamage, COMDAT
; _this$ = ecx

; 1052 : #ifdef _SERVER
; 1053 : 	bool bCalDamage = false;
; 1054 : 
; 1055 : 	_ASSERT (Npc[m_nLauncher].IsMatch(m_dwLauncherId));
; 1056 : 	
; 1057 : 	if (m_pMagicAttribsData) 
; 1058 : 	{
; 1059 : 		if (Npc[nNpcId].ReceiveDamage(m_nLauncher, m_bIsMelee, m_pMagicAttribsData->m_pDamageMagicAttribs, m_bUseAttackRating, m_bDoHurt))
; 1060 : 		{
; 1061 : 			if (m_pMagicAttribsData->m_nStateMagicAttribsNum > 0)
; 1062 : 				Npc[nNpcId].SetStateSkillEffect(m_nLauncher, m_nSkillId, m_nLevel, m_pMagicAttribsData->m_pStateMagicAttribs, m_pMagicAttribsData->m_nStateMagicAttribsNum, m_pMagicAttribsData->m_pStateMagicAttribs[0].nValue[1]);
; 1063 : 			
; 1064 : 			if (m_pMagicAttribsData->m_nImmediateMagicAttribsNum > 0)
; 1065 : 				Npc[nNpcId].SetImmediatelySkillEffect(m_nLauncher, m_pMagicAttribsData->m_pImmediateAttribs, m_pMagicAttribsData->m_nImmediateMagicAttribsNum);
; 1066 : 		}
; 1067 : 		return TRUE;
; 1068 : 	}
; 1069 : #endif //_SERVER
; 1070 : 	return FALSE;

	xor	eax, eax

; 1071 : }

	ret	4
?ProcessDamage@KMissle@@AAEHH@Z ENDP			; KMissle::ProcessDamage
_TEXT	ENDS
PUBLIC	?DoVanish@KMissle@@AAEXXZ			; KMissle::DoVanish
EXTRN	?Vanish@KSkill@@ABEXPAVKMissle@@@Z:PROC		; KSkill::Vanish
EXTRN	?g_SkillManager@@3VKSkillManager@@A:BYTE	; g_SkillManager
; Function compile flags: /Ogtpy
;	COMDAT ?DoVanish@KMissle@@AAEXXZ
_TEXT	SEGMENT
?DoVanish@KMissle@@AAEXXZ PROC				; KMissle::DoVanish, COMDAT
; _this$ = ecx

; 1074 : {

	push	esi
	mov	esi, ecx

; 1075 : 	if (m_eMissleStatus == MS_DoVanish) return ;

	cmp	DWORD PTR [esi+352], 2
	je	SHORT $LN1@DoVanish

; 1076 : 	
; 1077 : #ifndef _SERVER
; 1078 : 	m_MissleRes.m_bHaveEnd = TRUE;
; 1079 : 	m_nCollideOrVanishTime = m_nCurrentLife;
; 1080 : #endif
; 1081 : 	if (m_bVanishedEvent)	

	cmp	DWORD PTR [esi+192], 0
	mov	eax, DWORD PTR [esi+204]
	mov	DWORD PTR [esi+488], 1
	mov	DWORD PTR [esi+212], eax
	je	SHORT $LN2@DoVanish

; 1082 : 	{
; 1083 : 		_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 1084 : 		KSkill * pOrdinSkill = (KSkill *) g_SkillManager.GetSkill(m_nSkillId,m_nLevel);

	mov	ecx, DWORD PTR [esi+320]
	mov	edx, DWORD PTR [esi+100]
	push	ecx
	push	edx
	mov	ecx, OFFSET ?g_SkillManager@@3VKSkillManager@@A ; g_SkillManager
	call	?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z ; KSkillManager::GetSkill

; 1085 : 		if (pOrdinSkill)

	test	eax, eax
	je	SHORT $LN2@DoVanish

; 1086 :         {
; 1087 : 			pOrdinSkill->Vanish(this);

	push	esi
	mov	ecx, eax
	call	?Vanish@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::Vanish
$LN2@DoVanish:

; 1088 :         }
; 1089 : 	}
; 1090 : #ifdef _SERVER	//服务器端时子弹一旦进入消亡期则直接删除掉
; 1091 : 	SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_DEL, m_nMissleId);
; 1092 : 	m_eMissleStatus = MS_DoVanish;
; 1093 : 	return ;
; 1094 : #endif
; 1095 : 	m_eMissleStatus = MS_DoVanish;
; 1096 : #ifndef _SERVER 
; 1097 : 	if (m_nRegionId < 0)

	cmp	DWORD PTR [esi+364], 0
	mov	DWORD PTR [esi+352], 2
	jge	SHORT $LN1@DoVanish

; 1098 : 	{
; 1099 : 		_ASSERT(0);
; 1100 : 		m_bRemoving = TRUE;

	mov	DWORD PTR [esi+68], 1
$LN1@DoVanish:
	pop	esi

; 1101 : 		return ;
; 1102 : 	}
; 1103 : #endif
; 1104 : }

	ret	0
?DoVanish@KMissle@@AAEXXZ ENDP				; KMissle::DoVanish
_TEXT	ENDS
PUBLIC	?DoFly@KMissle@@AAEXXZ				; KMissle::DoFly
; Function compile flags: /Ogtpy
;	COMDAT ?DoFly@KMissle@@AAEXXZ
_TEXT	SEGMENT
?DoFly@KMissle@@AAEXXZ PROC				; KMissle::DoFly, COMDAT
; _this$ = ecx

; 1154 : 	if (m_eMissleStatus == MS_DoFly) return ;

	mov	eax, 1
	cmp	DWORD PTR [ecx+352], eax
	je	SHORT $LN2@DoFly

; 1155 : 	//初始化贴图
; 1156 : 	m_eMissleStatus = MS_DoFly;

	mov	DWORD PTR [ecx+352], eax
$LN2@DoFly:

; 1157 : }

	ret	0
?DoFly@KMissle@@AAEXXZ ENDP				; KMissle::DoFly
_TEXT	ENDS
PUBLIC	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z	; KMissle::GetOffsetAxis
; Function compile flags: /Ogtpy
;	COMDAT ?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z
_TEXT	SEGMENT
_nSubWorld$ = 8						; size = 4
_nSrcRegionId$ = 12					; size = 4
_nSrcMapX$ = 16						; size = 4
_nSrcMapY$ = 20						; size = 4
_nOffsetMapX$ = 24					; size = 4
_nOffsetMapY$ = 28					; size = 4
_nDesRegionId$ = 32					; size = 4
_nDesMapX$ = 36						; size = 4
_nDesMapY$ = 40						; size = 4
?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z PROC		; KMissle::GetOffsetAxis, COMDAT

; 1163 : 	nDesRegionId = -1;

	mov	eax, DWORD PTR _nDesRegionId$[esp-4]

; 1164 : 	// 确定目标格子实际的REGION和坐标确定
; 1165 : 	nDesMapX = nSrcMapX + nOffsetMapX;

	mov	ecx, DWORD PTR _nOffsetMapX$[esp-4]
	mov	edx, DWORD PTR _nSrcMapX$[esp-4]
	add	edx, ecx

; 1166 : 	nDesMapY = nSrcMapY + nOffsetMapY;

	mov	ecx, DWORD PTR _nSrcMapY$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nDesMapY$[esp]
	mov	DWORD PTR [eax], -1
	mov	eax, DWORD PTR _nOffsetMapY$[esp]
	push	esi
	mov	esi, DWORD PTR _nDesMapX$[esp+4]
	add	ecx, eax
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], ecx

; 1167 : 	
; 1168 : 	if (nSrcRegionId < 0) 

	mov	ecx, DWORD PTR _nSrcRegionId$[esp+4]
	test	ecx, ecx
	jge	SHORT $LN9@GetOffsetA
$LN12@GetOffsetA:
	pop	esi

; 1169 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1200 : 	// 从REGION的NPC列表中查找满足条件的NPC		
; 1201 : 	//int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nDesMapX, nDesMapY, nLauncherIdx, relation_all);
; 1202 : }

	ret	0
$LN9@GetOffsetA:

; 1170 : 
; 1171 : 	int nSearchRegion = nSrcRegionId;
; 1172 : 	if (nDesMapX < 0)
; 1173 : 	{
; 1174 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[2];

	mov	eax, DWORD PTR _nSubWorld$[esp+4]
	mov	edx, DWORD PTR [esi]
	imul	eax, 220				; 000000dcH
	test	edx, edx
	push	edi
	jge	SHORT $LN8@GetOffsetA
	mov	edi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	imul	ecx, 208				; 000000d0H
	mov	ecx, DWORD PTR [edi+ecx+112]

; 1175 : 		nDesMapX += SubWorld[nSubWorld].m_nRegionWidth;

	mov	edi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+140]
	add	edi, edx
	mov	DWORD PTR [esi], edi
	jmp	SHORT $LN6@GetOffsetA
$LN8@GetOffsetA:

; 1176 : 	}
; 1177 : 	else if (nDesMapX >= SubWorld[nSubWorld].m_nRegionWidth)

	mov	edi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+140]
	cmp	edx, edi
	jl	SHORT $LN6@GetOffsetA

; 1178 : 	{
; 1179 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[6];

	imul	ecx, 208				; 000000d0H
	push	ebp
	mov	ebp, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	mov	ecx, DWORD PTR [ecx+ebp+128]

; 1180 : 		nDesMapX -= SubWorld[nSubWorld].m_nRegionWidth;

	sub	edx, edi
	mov	DWORD PTR [esi], edx
	pop	ebp
$LN6@GetOffsetA:

; 1181 : 	}
; 1182 : 	if (nSearchRegion < 0) 

	test	ecx, ecx
	pop	edi

; 1183 : 		return FALSE;

	jl	SHORT $LN12@GetOffsetA

; 1184 : 	
; 1185 : 	if (nDesMapY < 0)

	mov	edx, DWORD PTR [ebx]
	test	edx, edx
	jge	SHORT $LN4@GetOffsetA

; 1186 : 	{
; 1187 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[4];

	mov	esi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	imul	ecx, 208				; 000000d0H

; 1188 : 		nDesMapY += SubWorld[nSubWorld].m_nRegionHeight;

	mov	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+144]
	mov	ecx, DWORD PTR [esi+ecx+120]
	add	eax, edx
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $LN2@GetOffsetA
$LN4@GetOffsetA:

; 1189 : 	}
; 1190 : 	else if (nDesMapY >= SubWorld[nSubWorld].m_nRegionHeight)

	mov	esi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+144]
	cmp	edx, esi
	jl	SHORT $LN2@GetOffsetA

; 1191 : 	{
; 1192 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[0];

	mov	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	imul	ecx, 208				; 000000d0H
	mov	ecx, DWORD PTR [eax+ecx+104]

; 1193 : 		nDesMapY -= SubWorld[nSubWorld].m_nRegionHeight;

	sub	edx, esi
	mov	DWORD PTR [ebx], edx
$LN2@GetOffsetA:

; 1194 : 	}	
; 1195 : 
; 1196 : 	if (nSearchRegion < 0) 

	test	ecx, ecx

; 1197 : 		return FALSE;

	jl	$LN12@GetOffsetA

; 1198 : 	nDesRegionId = nSearchRegion;

	mov	edx, DWORD PTR _nDesRegionId$[esp+4]
	pop	esi
	mov	DWORD PTR [edx], ecx

; 1199 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 1200 : 	// 从REGION的NPC列表中查找满足条件的NPC		
; 1201 : 	//int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nDesMapX, nDesMapY, nLauncherIdx, relation_all);
; 1202 : }

	ret	0
?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ENDP		; KMissle::GetOffsetAxis
_TEXT	ENDS
PUBLIC	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
EXTRN	?Init@KSkillSpecial@@QAEHXZ:PROC		; KSkillSpecial::Init
EXTRN	?g_SubWorldSet@@3VKSubWorldSet@@A:BYTE		; g_SubWorldSet
EXTRN	??0KSkillSpecial@@QAE@XZ:PROC			; KSkillSpecial::KSkillSpecial
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?PlaySoundA@KMissleRes@@QAEXHHHH@Z:PROC		; KMissleRes::PlaySoundA
;	COMDAT xdata$x
; File e:\x-project\#2.jx\source\sources\engine\src\knode.h
xdata$x	SEGMENT
__unwindtable$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z$1
__ehfuncinfo$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmissle.cpp
xdata$x	ENDS
;	COMDAT ?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eStatus$ = 8						; size = 4
_nPX$ = 12						; size = 4
_nPY$ = 16						; size = 4
_nPZ$ = 20						; size = 4
$T99445 = 24						; size = 4
_nNpcIndex$ = 24					; size = 4
?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z PROC ; KMissle::CreateSpecialEffect, COMDAT
; _this$ = ecx

; 1301 : {

	push	-1
	push	__ehhandler$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+36], ebx

; 1302 : 	
; 1303 : 	KSkillSpecialNode * pNode = NULL;
; 1304 : 	//同一颗子碟不能有几个爆炸效果在一个Npc身上
; 1305 : 	if (nNpcIndex > 0)

	mov	edi, DWORD PTR _nNpcIndex$[esp+32]
	xor	ebp, ebp
	cmp	edi, ebp
	jle	SHORT $LN3@CreateSpec

; 1306 : 	{
; 1307 : 		pNode = (KSkillSpecialNode*)m_MissleRes.m_SkillSpecialList.GetHead();

	mov	ecx, DWORD PTR [ebx+468]
	mov	eax, DWORD PTR [ecx+4]
	neg	eax
	sbb	eax, eax
	and	eax, ecx

; 1308 : 		while(pNode)

	cmp	eax, ebp
	je	SHORT $LN3@CreateSpec
	mov	ecx, edi
	imul	ecx, 30432				; 000076e0H
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[ecx]
	npad	10
$LL4@CreateSpec:

; 1309 : 		{
; 1310 : 			if (pNode->m_pSkillSpecial->m_dwMatchID == Npc[nNpcIndex].m_dwID) return FALSE;

	mov	edx, DWORD PTR [eax+12]
	cmp	DWORD PTR [edx+44], ecx
	je	$LN40@CreateSpec

; 1311 : 			pNode = (KSkillSpecialNode*)pNode->GetNext();

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+4], ebp
	je	SHORT $LN3@CreateSpec

; 1308 : 		while(pNode)

	cmp	eax, ebp
	jne	SHORT $LL4@CreateSpec
$LN3@CreateSpec:

; 1312 : 		}
; 1313 : 	}
; 1314 : 	m_MissleRes.PlaySound(eStatus, nPX, nPY, 0);

	mov	eax, DWORD PTR _nPY$[esp+32]
	mov	ecx, DWORD PTR _nPX$[esp+32]
	mov	esi, DWORD PTR _eStatus$[esp+32]
	push	ebp
	push	eax
	push	ecx
	push	esi
	lea	ecx, DWORD PTR [ebx+464]
	call	?PlaySoundA@KMissleRes@@QAEXHHHH@Z	; KMissleRes::PlaySoundA

; 1315 : 	if (!m_MissleRes.m_MissleRes[eStatus].AnimFileName[0]) return FALSE; 

	imul	esi, 212				; 000000d4H
	add	ebx, esi
	cmp	BYTE PTR [ebx+496], 0
	lea	esi, DWORD PTR [ebx+496]
	je	$LN40@CreateSpec

; 1316 : 	pNode = new KSkillSpecialNode;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN8@CreateSpec
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [eax], OFFSET ??_7KSkillSpecialNode@@6B@
	mov	ebp, eax
$LN8@CreateSpec:

; 1317 : 	KSkillSpecial * pSkillSpecial = new KSkillSpecial;

	push	240					; 000000f0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T99445[esp+32], eax
	xor	ecx, ecx
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+44], ecx
	je	SHORT $LN10@CreateSpec
	mov	ecx, eax
	call	??0KSkillSpecial@@QAE@XZ		; KSkillSpecial::KSkillSpecial
	mov	ecx, eax
$LN10@CreateSpec:

; 1318 : 	pNode->m_pSkillSpecial = pSkillSpecial;
; 1319 : 	
; 1320 : 	int nSrcX = nPX;
; 1321 : 	int nSrcY = nPY;
; 1322 : 	
; 1323 : 	pSkillSpecial->m_nPX = nSrcX;

	mov	edx, DWORD PTR _nPX$[esp+32]

; 1324 : 	pSkillSpecial->m_nPY = nSrcY - 5;// MISSLE_Y_OFFSET;

	mov	eax, DWORD PTR _nPY$[esp+32]
	mov	DWORD PTR [ebp+12], ecx

; 1325 : 	pSkillSpecial->m_nPZ = nPZ;
; 1326 : 	pSkillSpecial->m_nNpcIndex = nNpcIndex;

	mov	DWORD PTR [ecx+40], edi

; 1327 : 	pSkillSpecial->m_dwMatchID = Npc[nNpcIndex].m_dwID;

	imul	edi, 30432				; 000076e0H
	mov	DWORD PTR [ecx+24], edx
	mov	edx, DWORD PTR _nPZ$[esp+32]
	add	eax, -5					; fffffffbH
	mov	DWORD PTR [ecx+28], eax
	mov	DWORD PTR [ecx+32], edx
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[edi]
	mov	DWORD PTR [ecx+44], eax

; 1328 : 	pSkillSpecial->m_pMissleRes = &m_MissleRes.m_MissleRes[eStatus];

	mov	DWORD PTR [ecx+48], esi

; 1329 : 	pSkillSpecial->m_nBeginTime = g_SubWorldSet.GetGameTime();

	mov	edx, DWORD PTR ?g_SubWorldSet@@3VKSubWorldSet@@A
	mov	DWORD PTR [ecx+52], edx

; 1330 : 	pSkillSpecial->m_nEndTime = g_SubWorldSet.GetGameTime() + (pSkillSpecial->m_pMissleRes->nInterval * pSkillSpecial->m_pMissleRes->nTotalFrame / pSkillSpecial->m_pMissleRes->nDir);

	mov	eax, DWORD PTR [esi+104]
	imul	eax, DWORD PTR [esi+100]
	cdq
	idiv	DWORD PTR [esi+108]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	add	eax, DWORD PTR ?g_SubWorldSet@@3VKSubWorldSet@@A
	mov	DWORD PTR [ecx+56], eax

; 1331 : 	pSkillSpecial->m_nCurDir = g_DirIndex2Dir(m_nDirIndex, m_MissleRes.m_MissleRes[eStatus].nDir);

	mov	edx, DWORD PTR [ebx+604]
	test	edx, edx
	jg	SHORT $LN30@CreateSpec
	or	eax, -1
	jmp	SHORT $LN31@CreateSpec
$LN40@CreateSpec:

; 1309 : 		{
; 1310 : 			if (pNode->m_pSkillSpecial->m_dwMatchID == Npc[nNpcIndex].m_dwID) return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@CreateSpec

; 1331 : 	pSkillSpecial->m_nCurDir = g_DirIndex2Dir(m_nDirIndex, m_MissleRes.m_MissleRes[eStatus].nDir);

$LN30@CreateSpec:
	mov	eax, DWORD PTR _this$[esp+36]
	mov	eax, DWORD PTR [eax+420]
	imul	eax, edx
	sar	eax, 6
$LN31@CreateSpec:
	mov	DWORD PTR [ecx+36], eax

; 1332 : 	pSkillSpecial->Init();

	call	?Init@KSkillSpecial@@QAEHXZ		; KSkillSpecial::Init

; 1333 : 	m_MissleRes.m_SkillSpecialList.AddTail(pNode);

	mov	eax, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [eax+484]
	add	eax, 476				; 000001dcH
	test	ecx, ecx
	je	SHORT $LN35@CreateSpec
	mov	DWORD PTR [ebp+8], ecx
	mov	DWORD PTR [ebp+4], eax
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [eax+8], ebp
$LN35@CreateSpec:

; 1334 : 	
; 1335 : 	return TRUE;

	mov	eax, 1
$LN6@CreateSpec:

; 1336 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z$1:
	mov	eax, DWORD PTR $T99445[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ENDP ; KMissle::CreateSpecialEffect
PUBLIC	?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z ; KMissle::CreateMissleForShow
EXTRN	?LoadResource@KMissleRes@@QAEXHPAD0@Z:PROC	; KMissleRes::LoadResource
EXTRN	?Add@KMissleSet@@QAEHHHH@Z:PROC			; KMissleSet::Add
EXTRN	?MissleSet@@3VKMissleSet@@A:BYTE		; MissleSet
EXTRN	?Player@@3PAVKPlayer@@A:BYTE			; Player
EXTRN	?GetMpsPos@KNpc@@QAEXPAH0@Z:PROC		; KNpc::GetMpsPos
; Function compile flags: /Ogtpy
;	COMDAT ?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z
_TEXT	SEGMENT
_nPY$ = -8						; size = 4
_nPX$ = -4						; size = 4
_szMovie$ = 8						; size = 4
_szFormat$ = 12						; size = 4
_szSound$ = 16						; size = 4
_pcszTemp$ = 20						; size = 4
_pShowParam$ = 20					; size = 4
?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z PROC ; KMissle::CreateMissleForShow, COMDAT

; 1339 : {

	sub	esp, 8
	push	ebx
	push	edi

; 1340 : 	if (!pShowParam || !szMovie || !szMovie[0])

	mov	edi, DWORD PTR _pShowParam$[esp+12]
	xor	ebx, ebx
	cmp	edi, ebx
	je	$LN4@CreateMiss
	mov	eax, DWORD PTR _szMovie$[esp+12]
	cmp	eax, ebx
	je	$LN4@CreateMiss
	cmp	BYTE PTR [eax], bl
	je	$LN4@CreateMiss

; 1342 : 	int nPX = 0;
; 1343 : 	int nPY = 0;
; 1344 : 	int nPZ = 0;
; 1345 : 	
; 1346 : 	if (pShowParam->nNpcIndex > 0)

	mov	ecx, DWORD PTR [edi+12]
	cmp	ecx, ebx
	mov	DWORD PTR _nPX$[esp+16], ebx
	mov	DWORD PTR _nPY$[esp+16], ebx
	jle	SHORT $LN3@CreateMiss

; 1347 : 	{
; 1348 : 		Npc[pShowParam->nNpcIndex].GetMpsPos(&nPX, &nPY);

	imul	ecx, 30432				; 000076e0H
	lea	eax, DWORD PTR _nPY$[esp+16]
	push	eax
	lea	edx, DWORD PTR _nPX$[esp+20]
	push	edx
	add	ecx, OFFSET ?Npc@@3PAVKNpc@@A		; Npc
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 1349 : 	}
; 1350 : 	else

	jmp	SHORT $LN2@CreateMiss
$LN3@CreateMiss:

; 1351 : 	{
; 1352 : 		nPX = pShowParam->nPX;

	mov	eax, DWORD PTR [edi]

; 1353 : 		nPY = pShowParam->nPY;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _nPX$[esp+16], eax
	mov	DWORD PTR _nPY$[esp+16], ecx
$LN2@CreateMiss:

; 1354 : 	}
; 1355 : 
; 1356 : 	int nSubWorldId = Npc[Player[CLIENT_PLAYER_INDEX].m_nIndex].m_SubWorldIndex;

	mov	edx, DWORD PTR ?Player@@3PAVKPlayer@@A+24048

; 1357 : 	int nMissleIndex = MissleSet.Add(nSubWorldId , nPX , nPY);

	mov	eax, DWORD PTR _nPY$[esp+16]
	imul	edx, 30432				; 000076e0H
	mov	ecx, DWORD PTR _nPX$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR ?Npc@@3PAVKNpc@@A[edx+2380]
	push	eax
	push	ecx
	push	ebp
	mov	ecx, OFFSET ?MissleSet@@3VKMissleSet@@A	; MissleSet
	call	?Add@KMissleSet@@QAEHHHH@Z		; KMissleSet::Add

; 1358 : 	if (nMissleIndex < 0)	

	cmp	eax, ebx
	jge	SHORT $LN1@CreateMiss
	pop	ebp
	pop	edi

; 1359 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1388 : }

	add	esp, 8
	ret	0
$LN1@CreateMiss:

; 1360 : 	
; 1361 : 	Missle[nMissleIndex].m_nDir				= Npc[Player[CLIENT_PLAYER_INDEX].m_nIndex].m_Dir;

	mov	edx, DWORD PTR ?Player@@3PAVKPlayer@@A+24048
	imul	edx, 30432				; 000076e0H
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[edx+2740]
	imul	esi, 2936				; 00000b78H
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+424], eax

; 1362 : 	Missle[nMissleIndex].m_nDirIndex		= g_Dir2DirIndex(Missle[nMissleIndex].m_nDir, MaxMissleDir);

	shl	eax, 6
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+420], eax

; 1363 : 	Missle[nMissleIndex].m_nFollowNpcIdx	= 0;
; 1364 : 	Missle[nMissleIndex].m_dwBornTime		= SubWorld[nSubWorldId].m_dwCurrentTime;

	mov	eax, ebp
	imul	eax, 220				; 000000dcH
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+168]
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+432], ecx

; 1365 : 	Missle[nMissleIndex].m_nSubWorldId		= nSubWorldId;

	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+360], ebp
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+324], ebx

; 1366 : 	Missle[nMissleIndex].m_nLauncher		= pShowParam->nLauncherIndex;

	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+332], edx

; 1367 : 	Missle[nMissleIndex].m_dwLauncherId		= Npc[pShowParam->nLauncherIndex].m_dwID;

	mov	eax, DWORD PTR [edi+16]
	imul	eax, 30432				; 000076e0H
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax]
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+336], ecx

; 1368 : 	
; 1369 : 	Missle[nMissleIndex].m_nParentMissleIndex = 0;
; 1370 : 	
; 1371 : 	Missle[nMissleIndex].m_nSkillId			= 0;
; 1372 : 	Missle[nMissleIndex].m_nStartLifeTime	= 0;
; 1373 : 	Missle[nMissleIndex].m_nLifeTime		= 1;
; 1374 : 	Missle[nMissleIndex].m_nRefPX			= 0;
; 1375 : 	Missle[nMissleIndex].m_nRefPY			= 0;
; 1376 : 	Missle[nMissleIndex].m_MissleRes.Clear();

	lea	ebp, DWORD PTR ?Missle@@3PAVKMissle@@A[esi+464]
	mov	ecx, ebp
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+340], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+100], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+208], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+92], 1
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+236], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+240], ebx
	call	?Clear@KMissleRes@@QAEXXZ		; KMissleRes::Clear

; 1377 : 
; 1378 : 	Missle[nMissleIndex].m_MissleRes.LoadResource(MS_DoWait, szMovie, szSound);

	mov	edx, DWORD PTR _szSound$[esp+20]
	mov	eax, DWORD PTR _szMovie$[esp+20]
	push	edx
	push	eax
	push	ebx
	mov	ecx, ebp
	call	?LoadResource@KMissleRes@@QAEXHPAD0@Z	; KMissleRes::LoadResource

; 1379 : 	char * pcszTemp = szFormat;

	mov	ecx, DWORD PTR _szFormat$[esp+20]

; 1380 : 	Missle[nMissleIndex].m_MissleRes.m_MissleRes[MS_DoWait].nTotalFrame = KSG_StringGetInt(&pcszTemp, 100);

	mov	ebp, DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	lea	edx, DWORD PTR _pcszTemp$[esp+20]
	push	100					; 00000064H
	push	edx
	mov	DWORD PTR _pcszTemp$[esp+28], ecx
	call	ebp
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+596], eax

; 1381 : 	KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	eax, DWORD PTR _pcszTemp$[esp+28]
	push	44					; 0000002cH
	push	eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 1382 : 	Missle[nMissleIndex].m_MissleRes.m_MissleRes[MS_DoWait].nDir = KSG_StringGetInt(&pcszTemp, 16);

	lea	ecx, DWORD PTR _pcszTemp$[esp+36]
	push	16					; 00000010H
	push	ecx
	call	ebp

; 1383 : 	KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	edx, DWORD PTR _pcszTemp$[esp+44]
	push	44					; 0000002cH
	push	edx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+604], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 1384 :     Missle[nMissleIndex].m_MissleRes.m_MissleRes[MS_DoWait].nInterval = KSG_StringGetInt(&pcszTemp, 1);

	lea	eax, DWORD PTR _pcszTemp$[esp+52]
	push	1
	push	eax
	call	ebp

; 1385 : 
; 1386 : 	Missle[nMissleIndex].CreateSpecialEffect(MS_DoWait, nPX, nPY, nPZ, pShowParam->nNpcIndex);

	mov	edx, DWORD PTR _nPY$[esp+64]
	add	esp, 40					; 00000028H
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+600], eax
	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR _nPX$[esp+24]
	push	ecx
	push	ebx
	push	edx
	push	eax
	push	ebx
	lea	ecx, DWORD PTR ?Missle@@3PAVKMissle@@A[esi]
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
	pop	esi

; 1387 : 	return TRUE;

	mov	eax, 1
	pop	ebp
	pop	edi
	pop	ebx

; 1388 : }

	add	esp, 8
	ret	0
$LN4@CreateMiss:
	pop	edi

; 1341 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1388 : }

	add	esp, 8
	ret	0
?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z ENDP ; KMissle::CreateMissleForShow
_TEXT	ENDS
PUBLIC	?DoWait@KMissle@@AAEXXZ				; KMissle::DoWait
EXTRN	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z:PROC	; KSubWorld::Map2Mps
; Function compile flags: /Ogtpy
;	COMDAT ?DoWait@KMissle@@AAEXXZ
_TEXT	SEGMENT
_nSrcY$ = -8						; size = 4
_nSrcX$ = -4						; size = 4
?DoWait@KMissle@@AAEXXZ PROC				; KMissle::DoWait, COMDAT
; _this$ = ecx

; 1410 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 1411 : 	//	if (m_eMissleStatus == MS_DoWait) return;
; 1412 : 	m_eMissleStatus = MS_DoWait;
; 1413 : 	
; 1414 : #ifndef _SERVER 
; 1415 : 	int nSrcX = 0 ;
; 1416 : 	int nSrcY = 0 ;
; 1417 : 	SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY$[esp+12]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	lea	ecx, DWORD PTR _nSrcX$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR [esi+352], 0
	mov	DWORD PTR _nSrcX$[esp+40], 0
	mov	DWORD PTR _nSrcY$[esp+40], 0
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1418 : 	CreateSpecialEffect(MS_DoWait, nSrcX, nSrcY, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$[esp+12]
	mov	eax, DWORD PTR _nSrcX$[esp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	push	0
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
	pop	esi

; 1419 : #endif
; 1420 : 	
; 1421 : }

	add	esp, 8
	ret	0
?DoWait@KMissle@@AAEXXZ ENDP				; KMissle::DoWait
_TEXT	ENDS
PUBLIC	?CheckNearestCollision@KMissle@@AAEHXZ		; KMissle::CheckNearestCollision
; Function compile flags: /Ogtpy
;	COMDAT ?CheckNearestCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT
_i$98166 = -36						; size = 4
_nRMy$ = -32						; size = 4
_nRMx$ = -28						; size = 4
_nSearchRegion$ = -24					; size = 4
_nCellWidth$ = -20					; size = 4
_nNpcOffsetY$ = -16					; size = 4
_nCellHeight$ = -12					; size = 4
_j$98170 = -8						; size = 4
_nNpcIdx$ = -4						; size = 4
?CheckNearestCollision@KMissle@@AAEHXZ PROC		; KMissle::CheckNearestCollision, COMDAT
; _this$ = ecx

; 1492 : {

	sub	esp, 36					; 00000024H
	push	ebx

; 1493 : 	int nSearchRegion = 0;

	xor	eax, eax
	push	ebp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _nSearchRegion$[esp+48], eax

; 1494 : 	int nRMx = 0;

	mov	DWORD PTR _nRMx$[esp+48], eax

; 1495 : 	int nRMy = 0;

	mov	DWORD PTR _nRMy$[esp+48], eax

; 1496 : 	BOOL bCollision = TRUE;
; 1497 : 	int nNpcIdx = 0;
; 1498 : 	int nDX = 0;
; 1499 : 	int nDY = 0;
; 1500 : 	int nNpcOffsetX = 0;
; 1501 : 	int nNpcOffsetY = 0;
; 1502 : 	int nAbsX = 0;
; 1503 : 	int nAbsY = 0;
; 1504 : 	int nCellWidth = CellWidth;

	mov	eax, DWORD PTR [esi+360]
	imul	eax, 220				; 000000dcH
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+148]

; 1505 : 	int nCellHeight = CellHeight;

	mov	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+152]
	shl	ecx, 10					; 0000000aH
	shl	eax, 10					; 0000000aH
	push	edi
	mov	DWORD PTR _nCellWidth$[esp+52], ecx
	mov	DWORD PTR _nCellHeight$[esp+52], eax

; 1506 : 	_ASSERT(nCellWidth > 0 && nCellHeight > 0);
; 1507 : 	
; 1508 : 	for (int i = -1; i <= 1; i ++)

	mov	DWORD PTR _i$98166[esp+52], -1
	npad	11
$LL36@CheckNeare:

; 1509 : 		for (int j = -1; j <= 1; j ++)

	or	eax, -1
	mov	DWORD PTR _j$98170[esp+52], eax
	npad	9
$LL35@CheckNeare:

; 1510 : 		{
; 1511 : 			if (!KMissle::GetOffsetAxis(
; 1512 : 				m_nSubWorldId,
; 1513 : 				m_nRegionId, 
; 1514 : 				m_nCurrentMapX, 
; 1515 : 				m_nCurrentMapY, 
; 1516 : 				i , 
; 1517 : 				j , 
; 1518 : 				nSearchRegion, 
; 1519 : 				nRMx, 
; 1520 : 				nRMy
; 1521 : 				))

	mov	edi, DWORD PTR [esi+360]
	lea	ecx, DWORD PTR _nRMy$[esp+52]
	push	ecx
	lea	edx, DWORD PTR _nRMx$[esp+56]
	push	edx
	mov	edx, DWORD PTR _i$98166[esp+60]
	lea	ecx, DWORD PTR _nSearchRegion$[esp+60]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	push	ecx
	push	edx
	push	edi
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$LN21@CheckNeare

; 1522 : 				continue;
; 1523 : 			
; 1524 : 			_ASSERT(nSearchRegion >= 0);
; 1525 : 			
; 1526 : 			nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, m_nLauncher, m_eRelation);

	mov	eax, DWORD PTR [esi+108]
	imul	edi, 220				; 000000dcH
	mov	ecx, DWORD PTR [esi+332]
	mov	edx, DWORD PTR _nRMy$[esp+52]
	push	eax
	mov	eax, DWORD PTR _nRMx$[esp+56]
	push	ecx
	mov	ecx, DWORD PTR _nSearchRegion$[esp+60]
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+8]
	push	edx
	push	eax
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc

; 1527 : 			
; 1528 : 			if (nNpcIdx > 0)

	test	eax, eax
	mov	DWORD PTR _nNpcIdx$[esp+52], eax
	jle	$LN21@CheckNeare

; 1529 : 			{
; 1530 : 				bCollision = TRUE;
; 1531 : 				nDX = m_nCurrentMapX - Npc[nNpcIdx].m_MapX;
; 1532 : 				nDY = m_nCurrentMapY - Npc[nNpcIdx].m_MapY;

	mov	edi, DWORD PTR [esi+220]
	imul	eax, 30432				; 000076e0H
	sub	edi, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760]

; 1533 : 				nNpcOffsetX = Npc[nNpcIdx].m_OffX;
; 1534 : 				nNpcOffsetY = Npc[nNpcIdx].m_OffY;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2772]
	mov	ebp, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2768]
	mov	ecx, DWORD PTR [esi+216]
	sub	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756]
	mov	DWORD PTR _nNpcOffsetY$[esp+52], edx

; 1535 : 				nAbsX = abs(nDX);
; 1536 : 				nAbsY = abs(nDY);

	mov	eax, edi
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 1537 : 				
; 1538 : 				if (nAbsX)

	je	SHORT $LN33@CheckNeare

; 1539 : 				{
; 1540 : 					if (nDX < 0)

	test	ecx, ecx
	jge	SHORT $LN37@CheckNeare

; 1541 : 					{
; 1542 : 						if (nCellWidth - m_nXOffset + nNpcOffsetX > nCellWidth)

	mov	eax, DWORD PTR _nCellWidth$[esp+52]
	mov	ecx, eax
	sub	ecx, DWORD PTR [esi+228]
	add	ecx, ebp
	cmp	ecx, eax

; 1543 : 						{
; 1544 : 							bCollision = FALSE;
; 1545 : 							goto CheckCollision;
; 1546 : 						}
; 1547 : 					}

	jmp	SHORT $LN38@CheckNeare
$LN37@CheckNeare:

; 1548 : 					else if (nDX > 0)

	jle	SHORT $LN33@CheckNeare

; 1549 : 					{
; 1550 : 						if (nCellWidth - nNpcOffsetX + m_nXOffset > nCellWidth)

	mov	edx, DWORD PTR [esi+228]
	mov	eax, DWORD PTR _nCellWidth$[esp+52]
	sub	edx, ebp
	add	edx, eax
	cmp	edx, eax
$LN38@CheckNeare:

; 1571 : 						{
; 1572 : 							bCollision = FALSE;
; 1573 : 							goto CheckCollision;
; 1574 : 						}
; 1575 : 					}
; 1576 : 				}
; 1577 : 				
; 1578 : 				
; 1579 : CheckCollision:

	jg	SHORT $LN21@CheckNeare
$LN33@CheckNeare:

; 1551 : 						{
; 1552 : 							bCollision = FALSE;
; 1553 : 							goto CheckCollision;
; 1554 : 						}
; 1555 : 					}
; 1556 : 				}
; 1557 : 				
; 1558 : 				if (nAbsY)

	test	ebx, ebx
	je	SHORT $LN30@CheckNeare

; 1559 : 				{
; 1560 : 					if (nDY <0)

	test	edi, edi
	jge	SHORT $LN39@CheckNeare

; 1561 : 					{
; 1562 : 						if (nCellHeight - m_nYOffset + nNpcOffsetY > nCellHeight)

	mov	eax, DWORD PTR _nCellHeight$[esp+52]
	mov	ecx, eax
	sub	ecx, DWORD PTR [esi+232]
	add	ecx, DWORD PTR _nNpcOffsetY$[esp+52]
	cmp	ecx, eax

; 1571 : 						{
; 1572 : 							bCollision = FALSE;
; 1573 : 							goto CheckCollision;
; 1574 : 						}
; 1575 : 					}
; 1576 : 				}
; 1577 : 				
; 1578 : 				
; 1579 : CheckCollision:

	jmp	SHORT $LN40@CheckNeare
$LN39@CheckNeare:

; 1563 : 						{
; 1564 : 							bCollision = FALSE;
; 1565 : 							goto CheckCollision;
; 1566 : 						}
; 1567 : 					}
; 1568 : 					else if (nDY >0)

	jle	SHORT $LN30@CheckNeare

; 1569 : 					{
; 1570 : 						if (nCellHeight - nNpcOffsetY + m_nYOffset > nCellHeight)

	mov	edx, DWORD PTR [esi+232]
	sub	edx, DWORD PTR _nNpcOffsetY$[esp+52]
	mov	eax, DWORD PTR _nCellHeight$[esp+52]
	add	edx, eax
	cmp	edx, eax
$LN40@CheckNeare:
	jle	SHORT $LN30@CheckNeare
$LN21@CheckNeare:

; 1509 : 		for (int j = -1; j <= 1; j ++)

	mov	eax, DWORD PTR _j$98170[esp+52]
	add	eax, 1
	cmp	eax, 1
	mov	DWORD PTR _j$98170[esp+52], eax
	jle	$LL35@CheckNeare
	mov	eax, DWORD PTR _i$98166[esp+52]
	add	eax, 1
	cmp	eax, 1
	mov	DWORD PTR _i$98166[esp+52], eax
	jle	$LL36@CheckNeare
	pop	edi
	pop	esi
	pop	ebp

; 1582 : 			}
; 1583 : 		}
; 1584 : 		
; 1585 : 		return 0;

	xor	eax, eax
	pop	ebx

; 1586 : }

	add	esp, 36					; 00000024H
	ret	0
$LN30@CheckNeare:

; 1580 : 				if (bCollision)
; 1581 : 					return nNpcIdx;

	mov	eax, DWORD PTR _nNpcIdx$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1586 : }

	add	esp, 36					; 00000024H
	ret	0
?CheckNearestCollision@KMissle@@AAEHXZ ENDP		; KMissle::CheckNearestCollision
_TEXT	ENDS
PUBLIC	?GetMpsPos@KMissle@@QAEXPAH0@Z			; KMissle::GetMpsPos
; Function compile flags: /Ogtpy
;	COMDAT ?GetMpsPos@KMissle@@QAEXPAH0@Z
_TEXT	SEGMENT
_pPosX$ = 8						; size = 4
_pPosY$ = 12						; size = 4
?GetMpsPos@KMissle@@QAEXPAH0@Z PROC			; KMissle::GetMpsPos, COMDAT
; _this$ = ecx

; 1590 : 	SubWorld[m_nSubWorldId].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nXOffset, m_nYOffset, pPosX, pPosY);

	mov	eax, DWORD PTR _pPosY$[esp-4]
	mov	edx, DWORD PTR _pPosX$[esp-4]
	push	eax
	mov	eax, DWORD PTR [ecx+232]
	push	edx
	mov	edx, DWORD PTR [ecx+228]
	push	eax
	mov	eax, DWORD PTR [ecx+220]
	push	edx
	mov	edx, DWORD PTR [ecx+216]
	push	eax
	mov	eax, DWORD PTR [ecx+364]
	mov	ecx, DWORD PTR [ecx+360]
	imul	ecx, 220				; 000000dcH
	push	edx
	push	eax
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1591 : };

	ret	8
?GetMpsPos@KMissle@@QAEXPAH0@Z ENDP			; KMissle::GetMpsPos
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GKIndexNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GKIndexNode@@UAEPAXI@Z PROC				; KIndexNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7KNode@@6B@
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_GKIndexNode@@UAEPAXI@Z ENDP				; KIndexNode::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Send@KWorldMsg@@QAEHKHHH@Z			; KWorldMsg::Send
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kworldmsg.h
;	COMDAT ?Send@KWorldMsg@@QAEHKHHH@Z
_TEXT	SEGMENT
_dwMsgType$ = 8						; size = 4
_nParam1$ = 12						; size = 4
_nParam2$ = 16						; size = 4
_nParam3$ = 20						; size = 4
?Send@KWorldMsg@@QAEHKHHH@Z PROC			; KWorldMsg::Send, COMDAT
; _this$ = ecx

; 71   : {

	push	esi

; 72   : 	KWorldMsgNode *pNode = NULL;
; 73   : 
; 74   : 	pNode = new KWorldMsgNode;

	push	28					; 0000001cH
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@Send

; 77   : 
; 78   : 	pNode->m_dwMsgType	= dwMsgType;

	mov	ecx, DWORD PTR _dwMsgType$[esp]

; 79   : 	pNode->m_nParam[0]	= nParam1;

	mov	edx, DWORD PTR _nParam1$[esp]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax], OFFSET ??_7KWorldMsgNode@@6B@
	mov	DWORD PTR [eax+12], ecx

; 80   : 	pNode->m_nParam[1]	= nParam2;

	mov	ecx, DWORD PTR _nParam2$[esp]
	mov	DWORD PTR [eax+16], edx

; 81   : 	pNode->m_nParam[2]	= nParam3;

	mov	edx, DWORD PTR _nParam3$[esp]
	mov	DWORD PTR [eax+20], ecx

; 82   : 
; 83   : 	m_LocalMsgQueue.AddTail(pNode);

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $LN13@Send
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [ecx+8], eax
$LN13@Send:

; 84   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 85   : }

	ret	16					; 00000010H
$LN17@Send:

; 75   : 	if (!pNode)
; 76   : 		return FALSE;

	xor	eax, eax
	pop	esi

; 85   : }

	ret	16					; 00000010H
?Send@KWorldMsg@@QAEHKHHH@Z ENDP			; KWorldMsg::Send
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GKWorldMsgNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GKWorldMsgNode@@UAEPAXI@Z PROC			; KWorldMsgNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7KNode@@6B@
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GKWorldMsgNode@@UAEPAXI@Z ENDP			; KWorldMsgNode::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GKMissle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GKMissle@@UAEPAXI@Z PROC				; KMissle::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1KMissle@@UAE@XZ			; KMissle::~KMissle
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GKMissle@@UAEPAXI@Z ENDP				; KMissle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetInfoFromTabFile@KMissle@@QAEHH@Z		; KMissle::GetInfoFromTabFile
EXTRN	?g_MisslesSetting@@3VKTabFile@@A:BYTE		; g_MisslesSetting
; Function compile flags: /Ogtpy
; File e:\x-project\#2.jx\source\sources\core\src\kmissle.cpp
;	COMDAT ?GetInfoFromTabFile@KMissle@@QAEHH@Z
_TEXT	SEGMENT
_nMissleId$ = 8						; size = 4
?GetInfoFromTabFile@KMissle@@QAEHH@Z PROC		; KMissle::GetInfoFromTabFile, COMDAT
; _this$ = ecx

; 189  : 	if (nMissleId <= 0 ) return FALSE;

	mov	eax, DWORD PTR _nMissleId$[esp-4]
	test	eax, eax
	jg	SHORT $LN1@GetInfoFro@2
	xor	eax, eax

; 192  : }

	ret	4
$LN1@GetInfoFro@2:

; 190  : 	KITabFile * pITabFile = &g_MisslesSetting;
; 191  : 	return GetInfoFromTabFile(pITabFile, nMissleId);

	push	eax
	push	OFFSET ?g_MisslesSetting@@3VKTabFile@@A	; g_MisslesSetting
	call	?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z ; KMissle::GetInfoFromTabFile

; 192  : }

	ret	4
?GetInfoFromTabFile@KMissle@@QAEHH@Z ENDP		; KMissle::GetInfoFromTabFile
_TEXT	ENDS
PUBLIC	?Paint@KMissle@@QAEXXZ				; KMissle::Paint
EXTRN	?Draw@KMissleRes@@QAEHHHHHHHH@Z:PROC		; KMissleRes::Draw
; Function compile flags: /Ogtpy
;	COMDAT ?Paint@KMissle@@QAEXXZ
_TEXT	SEGMENT
_nSrcY$ = -8						; size = 4
_nSrcX$ = -4						; size = 4
?Paint@KMissle@@QAEXXZ PROC				; KMissle::Paint, COMDAT
; _this$ = ecx

; 833  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 834  : 	if (m_nMissleId <= 0 ) return;

	cmp	DWORD PTR [esi+356], 0
	jle	$LN1@Paint

; 835  : 	int nSrcX;
; 836  : 	int nSrcY;
; 837  : 	SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	push	edi
	lea	eax, DWORD PTR _nSrcY$[esp+16]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	lea	ecx, DWORD PTR _nSrcX$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 838  : 	
; 839  : 	if (!m_nZAcceleration)

	cmp	DWORD PTR [esi+348], 0

; 840  : 	{
; 841  : 		m_MissleRes.Draw(m_eMissleStatus, nSrcX, nSrcY, m_nCurrentMapZ, m_nDir,m_nLifeTime - m_nStartLifeTime,  m_nCurrentLife - m_nStartLifeTime );

	mov	eax, DWORD PTR [esi+208]
	lea	edi, DWORD PTR [esi+464]
	jne	SHORT $LN3@Paint
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+92]
	sub	ecx, eax
	sub	edx, eax
	mov	eax, DWORD PTR [esi+424]
	push	ecx
	push	edx

; 842  : 	}
; 843  : 	else

	jmp	SHORT $LN20@Paint
$LN3@Paint:

; 844  : 	{
; 845  : 		int nDirIndex = g_GetDirIndex(0,0,m_nXFactor, m_nYFactor);
; 846  : 		int nDir = g_DirIndex2Dir(nDirIndex, 64);
; 847  : 		m_MissleRes.Draw(m_eMissleStatus, nSrcX, nSrcY, m_nCurrentMapZ, nDir,m_nLifeTime - m_nStartLifeTime,  m_nCurrentLife - m_nStartLifeTime );

	mov	edx, DWORD PTR [esi+204]
	mov	ecx, DWORD PTR [esi+92]
	sub	edx, eax
	push	edx
	mov	edx, DWORD PTR [esi+316]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+312]
	push	ecx
	push	edx
	push	eax
	push	0
	push	0
	call	?g_GetDirIndex@@YAHHHHH@Z		; g_GetDirIndex
	shl	eax, 6
	add	esp, 16					; 00000010H
	sar	eax, 6
$LN20@Paint:
	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$[esp+24]
	push	eax
	mov	eax, DWORD PTR _nSrcX$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+352]
	push	edx
	push	eax
	push	ecx
	mov	ecx, edi
	call	?Draw@KMissleRes@@QAEHHHHHHHH@Z		; KMissleRes::Draw

; 848  : 	}
; 849  : 	
; 850  : 	//对于客户端，直到子弹及其产生的效果全部播放完才终止并删除掉!
; 851  : 	if (m_MissleRes.m_bHaveEnd && (m_MissleRes.SpecialMovieIsAllEnd()))

	cmp	DWORD PTR [esi+488], 0
	je	SHORT $LN19@Paint
	mov	edi, DWORD PTR [edi+4]
	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN10@Paint
	test	edi, edi
	jne	SHORT $LN19@Paint
$LN10@Paint:

; 852  : 		SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_DEL, m_nMissleId);

	mov	ecx, DWORD PTR [esi+360]
	mov	edx, DWORD PTR [esi+356]
	imul	ecx, 220				; 000000dcH
	push	0
	push	0
	push	edx
	push	4001					; 00000fa1H
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A+172
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$LN19@Paint:
	pop	edi
$LN1@Paint:
	pop	esi

; 853  : }

	add	esp, 8
	ret	0
?Paint@KMissle@@QAEXXZ ENDP				; KMissle::Paint
_TEXT	ENDS
PUBLIC	?CheckBeyondRegion@KMissle@@AAEHHH@Z		; KMissle::CheckBeyondRegion
EXTRN	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z:PROC	; KRegion::AddRef
EXTRN	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z:PROC	; KRegion::DecRef
; Function compile flags: /Ogtpy
;	COMDAT ?CheckBeyondRegion@KMissle@@AAEHHH@Z
_TEXT	SEGMENT
_nNewYOffset$ = -24					; size = 4
tv340 = -20						; size = 4
tv333 = -16						; size = 4
tv334 = -12						; size = 4
tv339 = -8						; size = 4
_nOldRegion$ = -4					; size = 4
_nNewMapX$ = 8						; size = 4
_nDOffsetX$ = 8						; size = 4
_nNewMapY$ = 12						; size = 4
_nDOffsetY$ = 12					; size = 4
?CheckBeyondRegion@KMissle@@AAEHHH@Z PROC		; KMissle::CheckBeyondRegion, COMDAT
; _this$ = ecx

; 858  : {

	sub	esp, 24					; 00000018H
	push	ebp
	push	esi
	mov	esi, ecx

; 859  : 	if (m_nRegionId < 0) 

	mov	ebp, DWORD PTR [esi+364]
	test	ebp, ebp
	jge	SHORT $LN20@CheckBeyon
	pop	esi

; 860  : 		return FALSE;

	xor	eax, eax
	pop	ebp

; 962  : }

	add	esp, 24					; 00000018H
	ret	8
$LN20@CheckBeyon:

; 861  : 	//未动
; 862  : 	if (nDOffsetX == 0 && nDOffsetY == 0) return TRUE;

	mov	ecx, DWORD PTR _nDOffsetX$[esp+28]
	test	ecx, ecx
	jne	SHORT $LN24@CheckBeyon
	cmp	DWORD PTR _nDOffsetY$[esp+28], ecx
	jne	SHORT $LN24@CheckBeyon
	pop	esi
	lea	eax, DWORD PTR [ecx+1]
	pop	ebp

; 962  : }

	add	esp, 24					; 00000018H
	ret	8
$LN24@CheckBeyon:
	push	ebx
	push	edi

; 863  : 
; 864  : 	if (abs(nDOffsetX) > CellWidth) 

	mov	edi, DWORD PTR [esi+360]
	imul	edi, 220				; 000000dcH
	mov	ebx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+148]
	mov	eax, ecx
	cdq
	xor	eax, edx
	shl	ebx, 10					; 0000000aH
	sub	eax, edx
	cmp	eax, ebx
	mov	DWORD PTR tv334[esp+40], ebx

; 865  : 	{
; 866  : 		return FALSE;

	jg	$LN32@CheckBeyon

; 867  : 	}
; 868  : 
; 869  : 	if (abs(nDOffsetY) > CellHeight) 

	mov	eax, DWORD PTR _nDOffsetY$[esp+36]
	mov	ebx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+152]
	cdq
	xor	eax, edx
	shl	ebx, 10					; 0000000aH
	sub	eax, edx
	cmp	eax, ebx
	mov	DWORD PTR tv340[esp+40], ebx

; 870  : 	{
; 871  : 		return FALSE;

	jg	$LN32@CheckBeyon

; 872  : 	}
; 873  : 
; 874  : 	int nOldRegion		= m_nRegionId;
; 875  : 	int nNewXOffset		= m_nXOffset + nDOffsetX;

	mov	ebx, DWORD PTR [esi+228]

; 876  : 	int nNewYOffset		= m_nYOffset + nDOffsetY;

	mov	eax, DWORD PTR [esi+232]
	add	eax, DWORD PTR _nDOffsetY$[esp+36]

; 877  : 	int nNewMapX		= m_nCurrentMapX;

	mov	edx, DWORD PTR [esi+216]
	add	ebx, ecx

; 878  : 	int nNewMapY		= m_nCurrentMapY;
; 879  : 	int nNewRegion		= m_nRegionId;
; 880  : 	
; 881  : 	DWORD nRegionWidth = RegionWidth;
; 882  : 	DWORD nRegionHeight = RegionHeight;
; 883  : 	
; 884  : 	_ASSERT(abs(nNewXOffset) <= CellWidth * 2);
; 885  : 	_ASSERT(abs(nNewYOffset) <= CellHeight * 2);
; 886  : 	
; 887  : 	//	处理NPC的坐标变幻
; 888  : 	//	CELLWIDTH、CELLHEIGHT、OffX、OffY均是放大了1024倍
; 889  : 	
; 890  : 	if (nNewXOffset < 0)

	test	ebx, ebx
	mov	ecx, DWORD PTR [esi+220]
	mov	DWORD PTR _nOldRegion$[esp+40], ebp
	mov	DWORD PTR _nNewYOffset$[esp+40], eax
	mov	DWORD PTR _nNewMapX$[esp+36], edx
	mov	DWORD PTR _nNewMapY$[esp+36], ecx
	jge	SHORT $LN16@CheckBeyon

; 891  : 	{
; 892  : 		nNewMapX--;
; 893  : 		nNewXOffset += CellWidth;

	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+148]
	shl	ecx, 10					; 0000000aH
	sub	edx, 1
	add	ebx, ecx
	jmp	SHORT $LN28@CheckBeyon
$LN16@CheckBeyon:

; 894  : 	}
; 895  : 	else if (nNewXOffset > CellWidth)

	mov	ecx, DWORD PTR tv334[esp+40]
	cmp	ebx, ecx
	jle	SHORT $LN23@CheckBeyon

; 896  : 	{
; 897  : 		nNewMapX++;

	add	edx, 1

; 898  : 		nNewXOffset -= CellWidth;

	sub	ebx, ecx
$LN28@CheckBeyon:

; 896  : 	{
; 897  : 		nNewMapX++;

	mov	DWORD PTR _nNewMapX$[esp+36], edx
$LN23@CheckBeyon:

; 899  : 	}
; 900  : 	
; 901  : 	if (nNewYOffset < 0)

	test	eax, eax
	jge	SHORT $LN13@CheckBeyon

; 902  : 	{
; 903  : 		nNewMapY--;
; 904  : 		nNewYOffset += CellHeight;

	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+152]
	sub	DWORD PTR _nNewMapY$[esp+36], 1
	shl	ecx, 10					; 0000000aH
	add	eax, ecx
	jmp	SHORT $LN29@CheckBeyon
$LN13@CheckBeyon:

; 905  : 	}
; 906  : 	else if (nNewYOffset > CellHeight)

	cmp	eax, DWORD PTR tv340[esp+40]
	jle	SHORT $LN11@CheckBeyon

; 907  : 	{
; 908  : 		nNewMapY++;

	add	DWORD PTR _nNewMapY$[esp+36], 1

; 909  : 		nNewYOffset -= CellHeight;

	sub	eax, DWORD PTR tv340[esp+40]
$LN29@CheckBeyon:
	mov	DWORD PTR _nNewYOffset$[esp+40], eax
$LN11@CheckBeyon:

; 910  : 	}
; 911  : 	
; 912  : 	if (nNewMapX < 0)

	test	edx, edx
	jge	SHORT $LN10@CheckBeyon

; 913  : 	{
; 914  : 		nNewRegion = LeftRegion(m_nRegionId);

	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+8]
	mov	eax, ebp
	imul	eax, 208				; 000000d0H
	mov	ebp, DWORD PTR [ecx+eax+112]

; 915  : 		nNewMapX += nRegionWidth;

	add	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+140]
	jmp	SHORT $LN30@CheckBeyon
$LN10@CheckBeyon:

; 916  : 	}
; 917  : 	else if ((DWORD)nNewMapX >= nRegionWidth)

	mov	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+140]
	cmp	edx, eax
	jb	SHORT $LN8@CheckBeyon

; 918  : 	{
; 919  : 		nNewRegion = RightRegion(m_nRegionId);

	mov	ecx, ebp
	mov	ebp, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+8]
	imul	ecx, 208				; 000000d0H
	mov	ebp, DWORD PTR [ecx+ebp+128]

; 920  : 		nNewMapX -= nRegionWidth;

	sub	edx, eax
$LN30@CheckBeyon:
	mov	DWORD PTR _nNewMapX$[esp+36], edx
$LN8@CheckBeyon:

; 921  : 	}
; 922  : 
; 923  : 	if (nNewRegion < 0) 

	test	ebp, ebp

; 924  : 	{
; 925  : 		return FALSE; 

	jl	SHORT $LN32@CheckBeyon

; 926  : 	}
; 927  : 	
; 928  : 	if (nNewMapY < 0)

	mov	eax, DWORD PTR _nNewMapY$[esp+36]
	test	eax, eax
	jge	SHORT $LN6@CheckBeyon

; 929  : 	{
; 930  : 		nNewRegion = UpRegion(nNewRegion);

	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+8]
	imul	ebp, 208				; 000000d0H
	mov	ebp, DWORD PTR [edx+ebp+120]

; 931  : 		nNewMapY += nRegionHeight;

	add	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+144]
	jmp	SHORT $LN31@CheckBeyon
$LN6@CheckBeyon:

; 932  : 	}
; 933  : 	else if (nNewMapY >= RegionHeight)

	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+144]
	cmp	eax, ecx
	jl	SHORT $LN25@CheckBeyon

; 934  : 	{
; 935  : 		nNewRegion = DownRegion(nNewRegion);

	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+8]
	imul	ebp, 208				; 000000d0H
	mov	ebp, DWORD PTR [edx+ebp+104]

; 936  : 		nNewMapY -= nRegionHeight;

	sub	eax, ecx
$LN31@CheckBeyon:
	mov	DWORD PTR _nNewMapY$[esp+36], eax
$LN25@CheckBeyon:

; 937  : 	}
; 938  : 	
; 939  : 	//下一个位置为不合法位置，则消亡
; 940  : 	if (nNewRegion < 0) 

	test	ebp, ebp
	jge	SHORT $LN3@CheckBeyon
$LN32@CheckBeyon:
	pop	edi
	pop	ebx
	pop	esi

; 941  : 	{
; 942  : 		return FALSE; 

	xor	eax, eax
	pop	ebp

; 962  : }

	add	esp, 24					; 00000018H
	ret	8
$LN3@CheckBeyon:

; 943  : 	}
; 944  : 	else
; 945  : 	{
; 946  : 		CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	eax, DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+216]
	push	2
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+364]
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edi+8]
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 947  : 		_ASSERT(m_nCurrentMapX >= 0  &&  m_nCurrentMapY >= 0);
; 948  : 		
; 949  : 		m_nRegionId	   = nNewRegion;
; 950  : 		m_nCurrentMapX = nNewMapX;
; 951  : 		m_nCurrentMapY = nNewMapY;

	mov	eax, DWORD PTR _nNewMapY$[esp+36]
	mov	ecx, DWORD PTR _nNewMapX$[esp+36]

; 952  : 		m_nXOffset	   = nNewXOffset;
; 953  : 		m_nYOffset	   = nNewYOffset;

	mov	edx, DWORD PTR _nNewYOffset$[esp+40]

; 954  : 		CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	push	2
	push	eax
	mov	DWORD PTR [esi+216], ecx
	mov	DWORD PTR [esi+220], eax
	mov	eax, DWORD PTR [esi+360]
	push	ecx
	imul	eax, 220				; 000000dcH
	mov	ecx, ebp
	imul	ecx, 208				; 000000d0H
	mov	DWORD PTR [esi+364], ebp
	mov	DWORD PTR [esi+228], ebx
	mov	DWORD PTR [esi+232], edx
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 955  : 		
; 956  : 		if (nOldRegion != m_nRegionId)

	mov	eax, DWORD PTR [esi+364]
	mov	ecx, DWORD PTR _nOldRegion$[esp+40]
	cmp	ecx, eax
	je	SHORT $LN1@CheckBeyon

; 957  : 		{
; 958  : 			SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	edx, DWORD PTR [esi+356]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	push	4002					; 00000fa2H
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A+172
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$LN1@CheckBeyon:
	pop	edi
	pop	ebx
	pop	esi

; 959  : 		}
; 960  : 	}
; 961  : 	return TRUE;

	mov	eax, 1
	pop	ebp

; 962  : }

	add	esp, 24					; 00000018H
	ret	8
?CheckBeyondRegion@KMissle@@AAEHHH@Z ENDP		; KMissle::CheckBeyondRegion
_TEXT	ENDS
PUBLIC	?DoCollision@KMissle@@AAEXXZ			; KMissle::DoCollision
EXTRN	?Collidsion@KSkill@@ABEXPAVKMissle@@@Z:PROC	; KSkill::Collidsion
; Function compile flags: /Ogtpy
;	COMDAT ?DoCollision@KMissle@@AAEXXZ
_TEXT	SEGMENT
_nSrcY5$97994 = -16					; size = 4
_nSrcX5$97993 = -12					; size = 4
_nSrcY$ = -8						; size = 4
_nSrcX$ = -4						; size = 4
?DoCollision@KMissle@@AAEXXZ PROC			; KMissle::DoCollision, COMDAT
; _this$ = ecx

; 1107 : {

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 1108 : 	if (m_eMissleStatus == MS_DoCollision) return;

	cmp	DWORD PTR [esi+352], 3
	je	$LN2@DoCollisio

; 1109 : 	
; 1110 : #ifndef _SERVER
; 1111 : 	int nSrcX = 0 ;
; 1112 : 	int nSrcY = 0 ;
; 1113 : 	SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	push	edi
	lea	eax, DWORD PTR _nSrcY$[esp+24]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	lea	ecx, DWORD PTR _nSrcX$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	xor	edi, edi
	push	eax
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR _nSrcX$[esp+52], edi
	mov	DWORD PTR _nSrcY$[esp+52], edi
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1114 : #endif
; 1115 : 	
; 1116 : 	if (m_bCollideEvent)	

	cmp	DWORD PTR [esi+188], edi
	je	SHORT $LN4@DoCollisio

; 1117 : 	{
; 1118 : 		_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 1119 : 		KSkill * pOrdinSkill = (KSkill *)g_SkillManager.GetSkill(m_nSkillId, m_nLevel);

	mov	ecx, DWORD PTR [esi+320]
	mov	edx, DWORD PTR [esi+100]
	push	ecx
	push	edx
	mov	ecx, OFFSET ?g_SkillManager@@3VKSkillManager@@A ; g_SkillManager
	call	?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z ; KSkillManager::GetSkill

; 1120 : 		if (pOrdinSkill)

	cmp	eax, edi
	je	SHORT $LN4@DoCollisio

; 1121 :         {
; 1122 : 			pOrdinSkill->Collidsion(this);

	push	esi
	mov	ecx, eax
	call	?Collidsion@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::Collidsion
$LN4@DoCollisio:

; 1123 :         }
; 1124 : 	}
; 1125 : 	
; 1126 : 	if (m_bCollideVanish)

	cmp	DWORD PTR [esi+152], edi
	je	SHORT $LN3@DoCollisio

; 1127 : 	{
; 1128 : #ifndef _SERVER
; 1129 : 		m_MissleRes.m_bHaveEnd = TRUE;
; 1130 : #endif
; 1131 : 		
; 1132 : #ifndef _SERVER 
; 1133 : 		int nSrcX5 = 0 ;
; 1134 : 		int nSrcY5 = 0 ;
; 1135 : 		SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX5, &nSrcY5);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY5$97994[esp+24]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	lea	ecx, DWORD PTR _nSrcX5$97993[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR [esi+488], 1
	mov	DWORD PTR _nSrcX5$97993[esp+52], edi
	mov	DWORD PTR _nSrcY5$97994[esp+52], edi
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1136 : 		CreateSpecialEffect(MS_DoVanish, nSrcX5, nSrcY5, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY5$97994[esp+24]
	mov	eax, DWORD PTR _nSrcX5$97993[esp+24]
	push	edi
	push	ecx
	push	edx
	push	eax
	push	2
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect

; 1137 : #endif
; 1138 : 		
; 1139 : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
	pop	edi
	pop	esi

; 1149 : 	}
; 1150 : }

	add	esp, 16					; 00000010H
	ret	0
$LN3@DoCollisio:

; 1140 : 	}
; 1141 : 	else 
; 1142 : 	{
; 1143 : #ifndef _SERVER		
; 1144 : 		//增加撞后的效果	
; 1145 : 		if (m_MissleRes.SpecialMovieIsAllEnd())

	mov	eax, DWORD PTR [esi+468]
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN9@DoCollisio
	cmp	eax, edi
	jne	SHORT $LN1@DoCollisio
$LN9@DoCollisio:

; 1146 : 			CreateSpecialEffect(MS_DoCollision, nSrcX, nSrcY, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$[esp+24]
	mov	eax, DWORD PTR _nSrcX$[esp+24]
	push	edi
	push	ecx
	push	edx
	push	eax
	push	3
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
$LN1@DoCollisio:

; 1147 : #endif
; 1148 : 		m_eMissleStatus = MS_DoFly;

	mov	DWORD PTR [esi+352], 1
	pop	edi
$LN2@DoCollisio:
	pop	esi

; 1149 : 	}
; 1150 : }

	add	esp, 16					; 00000010H
	ret	0
?DoCollision@KMissle@@AAEXXZ ENDP			; KMissle::DoCollision
_TEXT	ENDS
PUBLIC	?ProcessCollision@KMissle@@AAEHHHHHHH@Z		; KMissle::ProcessCollision
; Function compile flags: /Ogtpy
;	COMDAT ?ProcessCollision@KMissle@@AAEHHHHHHH@Z
_TEXT	SEGMENT
_nSrcX$98055 = -36					; size = 4
_i$98043 = -32						; size = 4
_nRet$ = -28						; size = 4
_nSubWorld$ = -24					; size = 4
_nRMy$ = -20						; size = 4
_nRMx$ = -16						; size = 4
_nSearchRegion$ = -12					; size = 4
_nRangeX$ = -8						; size = 4
tv199 = -4						; size = 4
_nLauncherIdx$ = 8					; size = 4
_nRegionId$ = 12					; size = 4
_nMapX$ = 16						; size = 4
_nMapY$ = 20						; size = 4
_nSrcY$98056 = 24					; size = 4
_nRange$ = 24						; size = 4
_eRelation$ = 28					; size = 4
?ProcessCollision@KMissle@@AAEHHHHHHH@Z PROC		; KMissle::ProcessCollision, COMDAT
; _this$ = ecx

; 1218 : {

	sub	esp, 36					; 00000024H
	push	ebx
	mov	ebx, ecx

; 1219 : #ifdef TOOLVERSION 
; 1220 : 	return 0;
; 1221 : #endif
; 1222 : #ifdef _SERVER
; 1223 : 	if (m_ulDamageInterval)
; 1224 : 	{
; 1225 : 		if (m_ulNextCalDamageTime > g_SubWorldSet.GetGameTime())
; 1226 : 		{
; 1227 : 			return FALSE;
; 1228 : 		}
; 1229 : 		else
; 1230 : 		{
; 1231 : 			// 6.29 romandou missledamage interval 
; 1232 : 			m_ulNextCalDamageTime = g_SubWorldSet.GetGameTime() + m_ulDamageInterval;
; 1233 : 		}
; 1234 : 	}
; 1235 : #endif
; 1236 : 	if (nLauncherIdx <= 0 ) return 0;

	mov	ecx, DWORD PTR _nLauncherIdx$[esp+36]
	test	ecx, ecx
	jg	SHORT $LN12@ProcessCol
$LN22@ProcessCol:
	xor	eax, eax
	pop	ebx

; 1285 : }

	add	esp, 36					; 00000024H
	ret	24					; 00000018H
$LN12@ProcessCol:

; 1237 : 	if (nRange <= 0) return 0;

	mov	eax, DWORD PTR _nRange$[esp+36]
	test	eax, eax
	jle	SHORT $LN22@ProcessCol

; 1238 : 	
; 1239 : 	int nRangeX = nRange / 2;
; 1240 : 	int	nRangeY = nRangeX;
; 1241 : 	int	nSubWorld = Npc[nLauncherIdx].m_SubWorldIndex;

	imul	ecx, 30432				; 000076e0H
	cdq
	sub	eax, edx
	sar	eax, 1
	push	ebp

; 1242 : 	
; 1243 : 	_ASSERT(Npc[nLauncherIdx].m_SubWorldIndex >= 0);
; 1244 : 	_ASSERT(nRegionId >= 0);
; 1245 : 	
; 1246 : 	int	nRegion = nRegionId;
; 1247 : 	int	nRet = 0;
; 1248 : 	int	nRMx, nRMy, nSearchRegion;
; 1249 : 
; 1250 : 	// 检查范围内的格子里的NPC
; 1251 : 	for (int i = -nRangeX; i <= nRangeX; i++)

	mov	ebp, eax
	neg	ebp
	push	esi
	mov	esi, DWORD PTR ?Npc@@3PAVKNpc@@A[ecx+2380]
	mov	ecx, ebp
	cmp	ecx, eax
	mov	DWORD PTR _nRangeX$[esp+48], eax
	mov	DWORD PTR _nSubWorld$[esp+48], esi
	mov	DWORD PTR _nRet$[esp+48], 0
	mov	DWORD PTR tv199[esp+48], ebp
	mov	DWORD PTR _i$98043[esp+48], ebp
	jg	$LN8@ProcessCol
	push	edi
	npad	7
$LL10@ProcessCol:

; 1252 : 	{
; 1253 : 		for (int j = -nRangeY; j <= nRangeY; j++)

	cmp	ebp, eax
	jg	$LN9@ProcessCol
	npad	8
$LL7@ProcessCol:

; 1254 : 		{
; 1255 : 			// 去掉边角几个格子，保证视野是椭圆形
; 1256 : 			//if ((i * i + j * j ) > nRangeX * nRangeX)
; 1257 : 			//continue;
; 1258 : 
; 1259 : 			if (!GetOffsetAxis(nSubWorld, nRegionId, nMapX, nMapY, i , j , nSearchRegion, nRMx, nRMy))

	lea	eax, DWORD PTR _nRMy$[esp+52]
	push	eax
	lea	edx, DWORD PTR _nRMx$[esp+56]
	push	edx
	mov	edx, DWORD PTR _nMapX$[esp+56]
	lea	eax, DWORD PTR _nSearchRegion$[esp+60]
	push	eax
	mov	eax, DWORD PTR _nRegionId$[esp+60]
	push	ebp
	push	ecx
	mov	ecx, DWORD PTR _nMapY$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$LN6@ProcessCol

; 1260 : 				continue;
; 1261 : 
; 1262 : 			_ASSERT(nSearchRegion >= 0);
; 1263 : 
; 1264 : 			// 从REGION的NPC列表中查找满足条件的NPC		
; 1265 : 			int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, nLauncherIdx, eRelation);

	mov	ecx, DWORD PTR _eRelation$[esp+48]
	imul	esi, 220				; 000000dcH
	mov	edx, DWORD PTR _nLauncherIdx$[esp+48]
	mov	eax, DWORD PTR _nRMy$[esp+52]
	mov	edi, DWORD PTR _nSearchRegion$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR _nRMx$[esp+56]
	push	edx
	push	eax
	push	ecx
	mov	ecx, edi
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[esi+8]
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc
	mov	esi, eax

; 1266 : 			if (nNpcIdx > 0)	

	test	esi, esi
	jle	SHORT $LN6@ProcessCol

; 1267 : 			{
; 1268 : 				nRet++;

	add	DWORD PTR _nRet$[esp+52], 1

; 1269 : #ifndef _SERVER
; 1270 : 				int nSrcX = 0;

	xor	eax, eax
	mov	DWORD PTR _nSrcX$98055[esp+52], eax

; 1271 : 				int nSrcY = 0;

	mov	DWORD PTR _nSrcY$98056[esp+48], eax

; 1272 : 				SubWorld[0].Map2Mps(nSearchRegion, Npc[nNpcIdx].m_MapX,Npc[nNpcIdx].m_MapY, Npc[nNpcIdx].m_OffX, Npc[nNpcIdx].m_OffY,  &nSrcX, &nSrcY);

	mov	eax, esi
	imul	eax, 30432				; 000076e0H
	lea	edx, DWORD PTR _nSrcY$98056[esp+48]
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2772]
	lea	ecx, DWORD PTR _nSrcX$98055[esp+56]
	push	ecx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2768]
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760]
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756]
	push	ecx
	push	edx
	push	eax
	push	edi
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1273 : 				
; 1274 : 				if (m_bFollowNpcWhenCollid)

	cmp	DWORD PTR [ebx+444], 0

; 1275 : 					CreateSpecialEffect(MS_DoCollision, nSrcX, nSrcY, m_nCurrentMapZ, nNpcIdx);

	mov	ecx, DWORD PTR [ebx+224]
	mov	edx, DWORD PTR _nSrcY$98056[esp+48]
	mov	eax, DWORD PTR _nSrcX$98055[esp+52]
	je	SHORT $LN2@ProcessCol
	push	esi

; 1276 : 				else 

	jmp	SHORT $LN21@ProcessCol
$LN2@ProcessCol:

; 1277 : 					CreateSpecialEffect(MS_DoCollision, nSrcX, nSrcY, m_nCurrentMapZ);

	push	0
$LN21@ProcessCol:
	push	ecx
	push	edx
	push	eax
	push	3
	mov	ecx, ebx
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
$LN6@ProcessCol:
	mov	eax, DWORD PTR _nRangeX$[esp+52]
	mov	ecx, DWORD PTR _i$98043[esp+52]
	mov	esi, DWORD PTR _nSubWorld$[esp+52]
	add	ebp, 1
	cmp	ebp, eax
	jle	$LL7@ProcessCol

; 1252 : 	{
; 1253 : 		for (int j = -nRangeY; j <= nRangeY; j++)

	mov	ebp, DWORD PTR tv199[esp+52]
$LN9@ProcessCol:

; 1242 : 	
; 1243 : 	_ASSERT(Npc[nLauncherIdx].m_SubWorldIndex >= 0);
; 1244 : 	_ASSERT(nRegionId >= 0);
; 1245 : 	
; 1246 : 	int	nRegion = nRegionId;
; 1247 : 	int	nRet = 0;
; 1248 : 	int	nRMx, nRMy, nSearchRegion;
; 1249 : 
; 1250 : 	// 检查范围内的格子里的NPC
; 1251 : 	for (int i = -nRangeX; i <= nRangeX; i++)

	add	ecx, 1
	cmp	ecx, eax
	mov	DWORD PTR _i$98043[esp+52], ecx
	jle	$LL10@ProcessCol
	pop	edi
$LN8@ProcessCol:

; 1278 : #else
; 1279 : 				ProcessDamage(nNpcIdx);						
; 1280 : #endif
; 1281 : 			}
; 1282 : 		}
; 1283 : 	}
; 1284 : 	return nRet;

	mov	eax, DWORD PTR _nRet$[esp+48]
	pop	esi
	pop	ebp
	pop	ebx

; 1285 : }

	add	esp, 36					; 00000024H
	ret	24					; 00000018H
?ProcessCollision@KMissle@@AAEHHHHHHH@Z ENDP		; KMissle::ProcessCollision
_TEXT	ENDS
PUBLIC	?ProcessCollision@KMissle@@AAEHXZ		; KMissle::ProcessCollision
; Function compile flags: /Ogtpy
;	COMDAT ?ProcessCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT
?ProcessCollision@KMissle@@AAEHXZ PROC			; KMissle::ProcessCollision, COMDAT
; _this$ = ecx

; 1290 : #ifdef TOOLVERSION
; 1291 : 	return 0;
; 1292 : #endif
; 1293 : 	if (m_bClientSend) return 0;

	cmp	DWORD PTR [ecx+64], 0
	je	SHORT $LN1@ProcessCol@2
	xor	eax, eax

; 1295 : }

	ret	0
$LN1@ProcessCol@2:

; 1294 : 	return ProcessCollision(m_nLauncher, m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nDamageRange , m_eRelation);

	mov	eax, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR [ecx+148]
	push	eax
	mov	eax, DWORD PTR [ecx+220]
	push	edx
	mov	edx, DWORD PTR [ecx+216]
	push	eax
	mov	eax, DWORD PTR [ecx+364]
	push	edx
	mov	edx, DWORD PTR [ecx+332]
	push	eax
	push	edx
	call	?ProcessCollision@KMissle@@AAEHHHHHHH@Z	; KMissle::ProcessCollision

; 1295 : }

	ret	0
?ProcessCollision@KMissle@@AAEHXZ ENDP			; KMissle::ProcessCollision
_TEXT	ENDS
PUBLIC	?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z	; KMissle::GetLightInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z
_TEXT	SEGMENT
_nPY$ = -4						; size = 4
_nPX$ = 8						; size = 4
_pLightInfo$ = 8					; size = 4
?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z PROC	; KMissle::GetLightInfo, COMDAT
; _this$ = ecx

; 1391 : {

	push	ecx
	push	esi
	push	edi

; 1392 : 	if (!pLightInfo) 

	mov	edi, DWORD PTR _pLightInfo$[esp+8]
	test	edi, edi
	mov	esi, ecx
	je	SHORT $LN2@GetLightIn

; 1393 : 	{
; 1394 : 		return ;
; 1395 : 	}
; 1396 : 	
; 1397 : 	int nPX, nPY, nPZ;
; 1398 : 	GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$[esp+12]
	push	eax
	lea	ecx, DWORD PTR _nPX$[esp+12]
	push	ecx
	mov	ecx, esi
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1399 : 	nPZ = m_nCurrentMapZ;

	mov	eax, DWORD PTR [esi+224]

; 1400 : 	
; 1401 : 	pLightInfo->oPosition.nX = nPX;

	mov	edx, DWORD PTR _nPX$[esp+8]

; 1402 : 	pLightInfo->oPosition.nY = nPY;

	mov	ecx, DWORD PTR _nPY$[esp+12]
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [edi+4], ecx

; 1403 : 	pLightInfo->oPosition.nZ = nPZ;

	mov	DWORD PTR [edi+8], eax

; 1404 : 	pLightInfo->dwColor = 0xff000000 | m_btRedLum << 16 | m_btGreenLum << 8 | m_btBlueLum;

	mov	edx, DWORD PTR [esi+448]
	or	edx, -256				; ffffff00H
	shl	edx, 8
	or	edx, DWORD PTR [esi+452]
	shl	edx, 8
	or	edx, DWORD PTR [esi+456]
	mov	DWORD PTR [edi+12], edx

; 1405 : 	pLightInfo->nRadius = m_usLightRadius;

	movzx	eax, WORD PTR [esi+460]
	mov	DWORD PTR [edi+16], eax
$LN2@GetLightIn:
	pop	edi
	pop	esi

; 1406 : }

	pop	ecx
	ret	4
?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z ENDP	; KMissle::GetLightInfo
_TEXT	ENDS
PUBLIC	?PrePareFly@KMissle@@AAEHXZ			; KMissle::PrePareFly
EXTRN	?Mps2Map@KSubWorld@@QAEXHHPAH0000@Z:PROC	; KSubWorld::Mps2Map
; Function compile flags: /Ogtpy
;	COMDAT ?PrePareFly@KMissle@@AAEHXZ
_TEXT	SEGMENT
_nParentPY$98144 = -16					; size = 4
_nParentPX$98137 = -16					; size = 4
_nPX$98127 = -16					; size = 4
_nSrcPY$98146 = -12					; size = 4
_nSrcPX$98139 = -12					; size = 4
_nPY$98128 = -12					; size = 4
_nParentPX$98143 = -8					; size = 4
_nSrcPY$98140 = -8					; size = 4
_nOldRegion$98147 = -4					; size = 4
_nSrcPX$98145 = -4					; size = 4
_nParentPY$98138 = -4					; size = 4
?PrePareFly@KMissle@@AAEHXZ PROC			; KMissle::PrePareFly, COMDAT
; _this$ = ecx

; 1424 : {

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 1425 : 	if (m_eMoveKind == MISSLE_MMK_RollBack)

	cmp	DWORD PTR [esi+76], 100			; 00000064H
	jne	SHORT $LN10@PrePareFly

; 1426 : 		m_nTempParam2 =  m_nStartLifeTime + (m_nLifeTime - m_nStartLifeTime ) / 2;

	mov	ecx, DWORD PTR [esi+208]
	mov	eax, DWORD PTR [esi+92]
	sub	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [esi+416], eax
$LN10@PrePareFly:

; 1427 : 
; 1428 : 	//是否会随发送者的移动而中断，类式魔兽3中大型法术
; 1429 : 	if (m_nInteruptTypeWhenMove)

	cmp	DWORD PTR [esi+128], 0
	je	SHORT $LN8@PrePareFly

; 1430 : 	{
; 1431 : 		int nPX, nPY;
; 1432 : 		Npc[m_nLauncher].GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$98128[esp+20]
	push	eax
	lea	ecx, DWORD PTR _nPX$98127[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	imul	ecx, 30432				; 000076e0H
	add	ecx, OFFSET ?Npc@@3PAVKNpc@@A		; Npc
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 1433 : 		if (nPX != m_nLauncherSrcPX || nPY != m_nLauncherSrcPY)

	mov	edx, DWORD PTR _nPX$98127[esp+20]
	cmp	edx, DWORD PTR [esi+136]
	jne	SHORT $LN7@PrePareFly
	mov	eax, DWORD PTR _nPY$98128[esp+20]
	cmp	eax, DWORD PTR [esi+140]
	je	SHORT $LN8@PrePareFly
$LN7@PrePareFly:

; 1434 : 		{
; 1435 : 			return false;

	xor	eax, eax
	pop	esi

; 1488 : 	
; 1489 : }

	add	esp, 16					; 00000010H
	ret	0
$LN8@PrePareFly:

; 1436 : 		}
; 1437 : 	}
; 1438 : 	
; 1439 : 	//子碟位置需要更正为到适当的位置（子弹的出现总是以某个可能位置在不断变化的物体为参照物）
; 1440 : 	if (m_bHeelAtParent)

	cmp	DWORD PTR [esi+132], 0
	push	ebx
	push	ebp
	je	$LN1@PrePareFly

; 1441 : 	{
; 1442 : 		int nNewPX = 0;
; 1443 : 		int nNewPY = 0;
; 1444 : 		
; 1445 : 		if (m_nParentMissleIndex) // 参考点为母子弹

	mov	eax, DWORD PTR [esi+340]
	test	eax, eax
	je	SHORT $LN5@PrePareFly

; 1446 : 		{
; 1447 : 			if (Missle[m_nParentMissleIndex].m_dwLauncherId != m_dwLauncherId)

	imul	eax, 2936				; 00000b78H
	mov	ecx, DWORD PTR ?Missle@@3PAVKMissle@@A[eax+336]
	cmp	ecx, DWORD PTR [esi+336]
	je	SHORT $LN4@PrePareFly
	pop	ebp
	pop	ebx

; 1448 : 			{
; 1449 : 				return false;

	xor	eax, eax
	pop	esi

; 1488 : 	
; 1489 : }

	add	esp, 16					; 00000010H
	ret	0
$LN4@PrePareFly:

; 1450 : 			}
; 1451 : 			else
; 1452 : 			{
; 1453 : 				int nParentPX, nParentPY;
; 1454 : 				int nSrcPX, nSrcPY;
; 1455 : 				Missle[m_nParentMissleIndex].GetMpsPos(&nParentPX, &nParentPY);

	lea	edx, DWORD PTR _nParentPY$98138[esp+28]
	push	edx
	lea	ecx, DWORD PTR _nParentPX$98137[esp+32]
	push	ecx
	lea	ecx, DWORD PTR ?Missle@@3PAVKMissle@@A[eax]
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1456 : 				GetMpsPos(&nSrcPX, &nSrcPY);

	lea	edx, DWORD PTR _nSrcPY$98140[esp+28]
	push	edx
	lea	eax, DWORD PTR _nSrcPX$98139[esp+32]
	push	eax
	mov	ecx, esi
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1457 : 				nNewPX = nSrcPX + (nParentPX - m_nRefPX);

	mov	ebx, DWORD PTR _nSrcPX$98139[esp+28]
	sub	ebx, DWORD PTR [esi+236]

; 1458 : 				nNewPY = nSrcPY + (nParentPY - m_nRefPY);

	mov	ebp, DWORD PTR _nSrcPY$98140[esp+28]
	sub	ebp, DWORD PTR [esi+240]
	add	ebx, DWORD PTR _nParentPX$98137[esp+28]
	add	ebp, DWORD PTR _nParentPY$98138[esp+28]

; 1459 : 			}
; 1460 : 		}
; 1461 : 		else

	jmp	SHORT $LN2@PrePareFly
$LN5@PrePareFly:

; 1462 : 			//参考点为发送者
; 1463 : 		{
; 1464 : 			_ASSERT(m_nLauncher > 0);
; 1465 : 			int nParentPX, nParentPY;
; 1466 : 			int nSrcPX, nSrcPY;
; 1467 : 			
; 1468 : 			Npc[m_nLauncher].GetMpsPos(&nParentPX, &nParentPY);

	lea	ecx, DWORD PTR _nParentPY$98144[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	imul	ecx, 30432				; 000076e0H
	lea	edx, DWORD PTR _nParentPX$98143[esp+32]
	push	edx
	add	ecx, OFFSET ?Npc@@3PAVKNpc@@A		; Npc
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 1469 : 			GetMpsPos(&nSrcPX, &nSrcPY);

	lea	eax, DWORD PTR _nSrcPY$98146[esp+28]
	push	eax
	lea	ecx, DWORD PTR _nSrcPX$98145[esp+32]
	push	ecx
	mov	ecx, esi
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1470 : 			
; 1471 : 			nNewPX = nSrcPX + (nParentPX - m_nRefPX);

	mov	ebx, DWORD PTR _nSrcPX$98145[esp+28]
	sub	ebx, DWORD PTR [esi+236]

; 1472 : 			nNewPY = nSrcPY + (nParentPY - m_nRefPY);

	mov	ebp, DWORD PTR _nSrcPY$98146[esp+28]
	sub	ebp, DWORD PTR [esi+240]
	add	ebx, DWORD PTR _nParentPX$98143[esp+28]
	add	ebp, DWORD PTR _nParentPY$98144[esp+28]
$LN2@PrePareFly:

; 1473 : 		}
; 1474 : 		
; 1475 : 		int nOldRegion = m_nRegionId;
; 1476 : 		CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+364]
	mov	eax, DWORD PTR [esi+216]
	push	edi
	push	2
	push	edx
	mov	edx, DWORD PTR [esi+360]
	lea	edi, DWORD PTR [esi+364]
	imul	edx, 220				; 000000dcH
	mov	DWORD PTR _nOldRegion$98147[esp+40], ecx
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx+8]
	push	eax
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 1477 : 		SubWorld[m_nSubWorldId].Mps2Map(nNewPX, nNewPY, &m_nRegionId, &m_nCurrentMapX, &m_nCurrentMapY, &m_nXOffset, &m_nYOffset);

	lea	eax, DWORD PTR [esi+232]
	push	eax
	lea	ecx, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	lea	eax, DWORD PTR [esi+220]
	imul	ecx, 220				; 000000dcH
	push	eax
	lea	eax, DWORD PTR [esi+216]
	push	eax
	push	edi
	push	ebp
	push	ebx
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?Mps2Map@KSubWorld@@QAEXHHPAH0000@Z	; KSubWorld::Mps2Map

; 1478 : 		CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+216]
	imul	ecx, 208				; 000000d0H
	push	2
	push	edx
	mov	edx, DWORD PTR [esi+360]
	imul	edx, 220				; 000000dcH
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx+8]
	push	eax
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 1479 : 		
; 1480 : 		if (nOldRegion != m_nRegionId)

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR _nOldRegion$98147[esp+32]
	cmp	eax, edi
	je	SHORT $LN15@PrePareFly

; 1481 : 		{
; 1482 : 			SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	ecx, DWORD PTR [esi+356]
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	push	edi
	push	eax
	push	4002					; 00000fa2H
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A+172
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$LN15@PrePareFly:
	pop	edi
$LN1@PrePareFly:
	pop	ebp
	pop	ebx

; 1483 : 		} 
; 1484 : 		
; 1485 : 	}
; 1486 : 	
; 1487 : 	return true;

	mov	eax, 1
	pop	esi

; 1488 : 	
; 1489 : }

	add	esp, 16					; 00000010H
	ret	0
?PrePareFly@KMissle@@AAEHXZ ENDP			; KMissle::PrePareFly
_TEXT	ENDS
PUBLIC	?CheckCollision@KMissle@@AAEHXZ			; KMissle::CheckCollision
; Function compile flags: /Ogtpy
;	COMDAT ?CheckCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT
_nRMy$ = -12						; size = 4
_nRMx$ = -8						; size = 4
_nSearchRegion$ = -4					; size = 4
?CheckCollision@KMissle@@AAEHXZ PROC			; KMissle::CheckCollision, COMDAT
; _this$ = ecx

; 472  : {

	sub	esp, 12					; 0000000cH
	push	ebp
	push	esi
	mov	esi, ecx

; 473  : #ifdef TOOLVERSION
; 474  : 	return FALSE;
; 475  : #endif
; 476  : 	
; 477  : 	if (m_nCurrentMapZ <= MISSLE_MIN_COLLISION_ZHEIGHT) 

	mov	eax, DWORD PTR [esi+224]
	xor	ebp, ebp
	cmp	eax, ebp
	jg	SHORT $LN19@CheckColli
$LN29@CheckColli:
	pop	esi

; 478  : 	{
; 479  : 		return -1;

	or	eax, -1
	pop	ebp

; 552  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN19@CheckColli:

; 480  : 	}
; 481  : 	
; 482  : 	//子弹在高于一定高度时，不处理越界碰撞问题
; 483  : 	if (m_nCurrentMapZ > MISSLE_MAX_COLLISION_ZHEIGHT) return 0;

	cmp	eax, 20					; 00000014H
	jle	SHORT $LN18@CheckColli
	pop	esi
	xor	eax, eax
	pop	ebp

; 552  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN18@CheckColli:

; 484  : 	
; 485  : 	if (m_nRegionId < 0) 

	mov	ecx, DWORD PTR [esi+364]
	cmp	ecx, ebp

; 486  : 	{
; 487  : 		return -1;

	jl	SHORT $LN29@CheckColli

; 488  : 	}
; 489  : 
; 490  : 	int nAbsX = 0;
; 491  : 	int nAbsY = 0;
; 492  : 	int nCellWidth = CellWidth;
; 493  : 	int nCellHeight = CellHeight;
; 494  : 	_ASSERT(nCellWidth > 0 && nCellHeight > 0);
; 495  : 	int nRMx = 0;
; 496  : 	int nRMy = 0;
; 497  : 	int nSearchRegion = 0;
; 498  : 	int nNpcIdx = 0;
; 499  : 	int nDX = 0;
; 500  : 	int nDY = 0;
; 501  : 	int nNpcOffsetX = 0;
; 502  : 	int nNpcOffsetY = 0;
; 503  : 	BOOL bCollision = FALSE;
; 504  : 	
; 505  : 	int nColRegion = m_nRegionId;
; 506  : 	int nColMapX = m_nCurrentMapX;
; 507  : 	int nColMapY = m_nCurrentMapY;
; 508  : 		
; 509  : 	if (m_nCollideRange == 1)

	mov	eax, DWORD PTR [esi+144]
	cmp	eax, 1
	push	ebx
	mov	ebx, DWORD PTR [esi+220]
	push	edi
	mov	edi, DWORD PTR [esi+216]
	mov	DWORD PTR _nRMx$[esp+28], ebp
	mov	DWORD PTR _nRMy$[esp+28], ebp
	mov	DWORD PTR _nSearchRegion$[esp+28], ebp
	jne	$LN16@CheckColli

; 510  : 	{
; 511  : 		if (m_bNeedReclaim && m_nCurrentLife >= m_nFirstReclaimTime && m_nCurrentLife <= m_nEndReclaimTime)

	cmp	DWORD PTR [esi+256], ebp
	je	SHORT $LN15@CheckColli
	mov	eax, DWORD PTR [esi+204]
	cmp	eax, DWORD PTR [esi+404]
	jl	SHORT $LN15@CheckColli
	mov	edx, DWORD PTR [esi+408]
	cmp	eax, edx
	jg	SHORT $LN15@CheckColli

; 512  : 		{
; 513  : 			if (m_nCurrentLife == m_nEndReclaimTime) 

	jne	SHORT $LN14@CheckColli

; 514  : 				m_bNeedReclaim = FALSE;

	mov	DWORD PTR [esi+256], ebp
$LN14@CheckColli:

; 515  : 			nNpcIdx = 	CheckNearestCollision();

	mov	ecx, esi
	call	?CheckNearestCollision@KMissle@@AAEHXZ	; KMissle::CheckNearestCollision

; 516  : 		}
; 517  : 		else

	jmp	SHORT $LN13@CheckColli
$LN15@CheckColli:

; 518  : 		{
; 519  : 			nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nColRegion].FindNpc(nColMapX, nColMapY, m_nLauncher, m_eRelation);

	mov	eax, DWORD PTR [esi+108]
	imul	ecx, 208				; 000000d0H
	mov	edx, DWORD PTR [esi+332]
	push	eax
	mov	eax, DWORD PTR [esi+360]
	imul	eax, 220				; 000000dcH
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	push	edx
	push	ebx
	push	edi
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc
$LN13@CheckColli:

; 520  : 		}
; 521  : 
; 522  : 		if (nNpcIdx > 0)

	cmp	eax, ebp
	jle	$LN6@CheckColli

; 523  : 		{ 
; 524  : 			if (m_nDamageRange == 1)//在目标Npc处碰撞

	cmp	DWORD PTR [esi+148], 1
	jne	$LN24@CheckColli

; 525  : 				ProcessCollision(m_nLauncher, Npc[nNpcIdx].m_RegionIndex , Npc[nNpcIdx].m_MapX, Npc[nNpcIdx].m_MapY, m_nDamageRange , m_eRelation);

	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 30432				; 000076e0H
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760]
	push	ecx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756]
	push	1
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2384]
	mov	eax, DWORD PTR [esi+332]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHHHHHHH@Z	; KMissle::ProcessCollision

; 545  : 					DoCollision();//子弹作碰撞后的效果

	mov	ecx, esi
	call	?DoCollision@KMissle@@AAEXXZ		; KMissle::DoCollision
	pop	edi
	pop	ebx
	pop	esi

; 546  : 					return 1;

	mov	eax, 1
	pop	ebp

; 552  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN16@CheckColli:

; 526  : 			else
; 527  : 				ProcessCollision();//在子弹位置处理碰撞
; 528  : 			DoCollision();//子弹作碰撞后的效果
; 529  : 			return 1;
; 530  : 		}
; 531  : 	}
; 532  : 	else
; 533  : 	{
; 534  : 		for (int i = -m_nCollideRange; i <= m_nCollideRange; i ++)

	mov	ebp, eax
	neg	ebp
	cmp	ebp, eax
	jg	$LN6@CheckColli
	npad	5
$LL8@CheckColli:

; 535  : 			for (int j = -m_nCollideRange; j <= m_nCollideRange; j ++)

	mov	eax, DWORD PTR [esi+144]
	mov	edi, eax
	neg	edi
	cmp	edi, eax
	jg	SHORT $LN7@CheckColli
	npad	2
$LL5@CheckColli:

; 536  : 			{
; 537  : 				if (!GetOffsetAxis(m_nSubWorldId, m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, i , j , nSearchRegion, nRMx, nRMy))

	mov	ebx, DWORD PTR [esi+360]
	lea	ecx, DWORD PTR _nRMy$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	lea	edx, DWORD PTR _nRMx$[esp+32]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	lea	eax, DWORD PTR _nSearchRegion$[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	edi
	push	ebp
	push	ecx
	push	edx
	push	eax
	push	ebx
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN4@CheckColli

; 538  : 					continue;
; 539  : 				
; 540  : 				_ASSERT(nSearchRegion >= 0);
; 541  : 				nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, m_nLauncher, m_eRelation);

	mov	ecx, DWORD PTR [esi+108]
	imul	ebx, 220				; 000000dcH
	mov	edx, DWORD PTR [esi+332]
	mov	eax, DWORD PTR _nRMy$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR _nRMx$[esp+32]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _nSearchRegion$[esp+44]
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ebx+8]
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc

; 542  : 				if (nNpcIdx > 0)

	test	eax, eax
	jg	SHORT $LN24@CheckColli
$LN4@CheckColli:

; 535  : 			for (int j = -m_nCollideRange; j <= m_nCollideRange; j ++)

	add	edi, 1
	cmp	edi, DWORD PTR [esi+144]
	jle	SHORT $LL5@CheckColli
$LN7@CheckColli:

; 526  : 			else
; 527  : 				ProcessCollision();//在子弹位置处理碰撞
; 528  : 			DoCollision();//子弹作碰撞后的效果
; 529  : 			return 1;
; 530  : 		}
; 531  : 	}
; 532  : 	else
; 533  : 	{
; 534  : 		for (int i = -m_nCollideRange; i <= m_nCollideRange; i ++)

	add	ebp, 1
	cmp	ebp, DWORD PTR [esi+144]
	jle	$LL8@CheckColli
$LN6@CheckColli:
	pop	edi
	pop	ebx
	pop	esi

; 547  : 				}
; 548  : 			}
; 549  : 	}
; 550  : 	
; 551  : 	return 0;

	xor	eax, eax
	pop	ebp

; 552  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN24@CheckColli:

; 543  : 				{
; 544  : 					ProcessCollision();//处理碰撞

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision

; 545  : 					DoCollision();//子弹作碰撞后的效果

	mov	ecx, esi
	call	?DoCollision@KMissle@@AAEXXZ		; KMissle::DoCollision
	pop	edi
	pop	ebx
	pop	esi

; 546  : 					return 1;

	mov	eax, 1
	pop	ebp

; 552  : }

	add	esp, 12					; 0000000cH
	ret	0
?CheckCollision@KMissle@@AAEHXZ ENDP			; KMissle::CheckCollision
_TEXT	ENDS
PUBLIC	?OnFly@KMissle@@AAEXXZ				; KMissle::OnFly
EXTRN	?GetDistance@KSubWorld@@QAEHHHHH@Z:PROC		; KSubWorld::GetDistance
; Function compile flags: /Ogtpy
;	COMDAT ?OnFly@KMissle@@AAEXXZ
_TEXT	SEGMENT
_nDesMpsX$97882 = -16					; size = 4
_nPY$97829 = -16					; size = 4
_nSrcMpsY$97881 = -12					; size = 4
_nSrcX3$97835 = -12					; size = 4
_nSrcX2$97832 = -12					; size = 4
_nSrcX4$97900 = -8					; size = 4
_nDesMpsY$97883 = -8					; size = 4
_nSrcY3$97836 = -8					; size = 4
_nSrcY2$97833 = -8					; size = 4
tv904 = -4						; size = 4
tv902 = -4						; size = 4
_nSrcY4$97901 = -4					; size = 4
_nSrcMpsX$97880 = -4					; size = 4
_nPX$97828 = -4						; size = 4
?OnFly@KMissle@@AAEXXZ PROC				; KMissle::OnFly, COMDAT
; _this$ = ecx

; 560  : {

	sub	esp, 16					; 00000010H
	push	ebp
	push	esi
	mov	esi, ecx

; 561  : 	if (m_nInteruptTypeWhenMove)

	mov	eax, DWORD PTR [esi+128]
	xor	ebp, ebp
	cmp	eax, ebp
	je	$LN51@OnFly

; 562  : 	{
; 563  : 		//当发送者位置移动了，不仅正从do_wait状态到do_fly状态的新子弹被消失掉
; 564  : 		//而且已进入dofly状态的旧的所属子弹也要强制消失掉
; 565  : 		if (m_nInteruptTypeWhenMove == Interupt_EndOldMissleLifeWhenMove)

	cmp	eax, 2
	jne	$LN51@OnFly

; 566  : 		{
; 567  : 			int nPX, nPY;
; 568  : 			Npc[m_nLauncher].GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$97829[esp+24]
	push	eax
	lea	ecx, DWORD PTR _nPX$97828[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	imul	ecx, 30432				; 000076e0H
	add	ecx, OFFSET ?Npc@@3PAVKNpc@@A		; Npc
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 569  : 			if (nPX != m_nLauncherSrcPX || nPY != m_nLauncherSrcPY)

	mov	edx, DWORD PTR _nPX$97828[esp+24]
	cmp	edx, DWORD PTR [esi+136]
	jne	SHORT $LN40@OnFly
	mov	eax, DWORD PTR _nPY$97829[esp+24]
	cmp	eax, DWORD PTR [esi+140]
	je	SHORT $LN51@OnFly
$LN40@OnFly:

; 570  : 			{
; 571  : 				
; 572  : #ifndef _SERVER 
; 573  : 				int nSrcX2 = 0 ;
; 574  : 				int nSrcY2 = 0 ;
; 575  : 				SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX2, &nSrcY2);

	mov	eax, DWORD PTR [esi+232]
	lea	ecx, DWORD PTR _nSrcY2$97833[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [esi+228]
	lea	edx, DWORD PTR _nSrcX2$97832[esp+28]
	push	edx
	mov	edx, DWORD PTR [esi+220]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	mov	ecx, DWORD PTR [esi+364]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR _nSrcX2$97832[esp+52], ebp
	mov	DWORD PTR _nSrcY2$97833[esp+52], ebp
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 576  : 				CreateSpecialEffect(MS_DoVanish, nSrcX2, nSrcY2, m_nCurrentMapZ);

	mov	edx, DWORD PTR [esi+224]
	mov	eax, DWORD PTR _nSrcY2$97833[esp+24]
	mov	ecx, DWORD PTR _nSrcX2$97832[esp+24]
	push	ebp
	push	edx
	push	eax
	push	ecx
$LN60@OnFly:
	push	2
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect

; 577  : #endif
; 578  : 				
; 579  : 				DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$LN1@OnFly:
	pop	esi
	pop	ebp

; 817  : 	}
; 818  : }

	add	esp, 16					; 00000010H
	ret	0
$LN51@OnFly:

; 580  : 				return ;
; 581  : 			}
; 582  : 		}
; 583  : 	}
; 584  : 	
; 585  : 	//检测当前位置是否有障碍
; 586  : 	if (TestBarrier()) 

	mov	ecx, esi
	call	?TestBarrier@KMissle@@AAEHXZ		; KMissle::TestBarrier
	test	eax, eax
	je	SHORT $LN39@OnFly

; 587  : 	{
; 588  : #ifndef _SERVER 
; 589  : 		int nSrcX3 = 0 ;
; 590  : 		int nSrcY3 = 0 ;
; 591  : 		SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX3, &nSrcY3);

	mov	ecx, DWORD PTR [esi+232]
	lea	edx, DWORD PTR _nSrcY3$97836[esp+24]
	push	edx
	mov	edx, DWORD PTR [esi+228]
	lea	eax, DWORD PTR _nSrcX3$97835[esp+28]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR _nSrcX3$97835[esp+52], ebp
	mov	DWORD PTR _nSrcY3$97836[esp+52], ebp
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 592  : 		CreateSpecialEffect(MS_DoVanish, nSrcX3, nSrcY3, m_nCurrentMapZ);

	mov	eax, DWORD PTR [esi+224]
	mov	ecx, DWORD PTR _nSrcY3$97836[esp+24]
	mov	edx, DWORD PTR _nSrcX3$97835[esp+24]
	push	ebp
	push	eax
	push	ecx
	push	edx

; 593  : #endif
; 594  : 		DoVanish();
; 595  : 		return;

	jmp	SHORT $LN60@OnFly
$LN39@OnFly:

; 596  : 	}
; 597  : 	
; 598  : 	int nDOffsetX = 0;
; 599  : 	int nDOffsetY = 0;
; 600  : 	
; 601  : 	ZAxisMove();			

	mov	ecx, DWORD PTR [esi+348]
	push	ebx
	push	edi
	xor	edi, edi
	xor	ebx, ebx
	cmp	ecx, ebp
	je	SHORT $LN47@OnFly
	mov	eax, DWORD PTR [esi+88]
	add	DWORD PTR [esi+84], eax
	jns	SHORT $LN46@OnFly
	mov	DWORD PTR [esi+84], ebp
$LN46@OnFly:
	sub	eax, ecx
	mov	DWORD PTR [esi+88], eax
	mov	eax, DWORD PTR [esi+84]
	sar	eax, 10					; 0000000aH
	mov	DWORD PTR [esi+224], eax
$LN47@OnFly:

; 602  : 	switch(this->m_eMoveKind)

	mov	eax, DWORD PTR [esi+76]
	add	eax, -1
	cmp	eax, 99					; 00000063H
	ja	SHORT $LN52@OnFly
	movzx	ecx, BYTE PTR $LN50@OnFly[eax]
	jmp	DWORD PTR $LN61@OnFly[ecx*4]
$LN34@OnFly:

; 603  : 	{
; 604  : 	case	MISSLE_MMK_Stand:							//	原地
; 605  : 		{
; 606  : 			
; 607  : 		}
; 608  : 		break;
; 609  : 	case	MISSLE_MMK_Parabola:						//	抛物线
; 610  : 	case	MISSLE_MMK_Line:							//	直线飞行
; 611  : 		{
; 612  : 			nDOffsetX    = (m_nSpeed * m_nXFactor);
; 613  : 			nDOffsetY	 = (m_nSpeed * m_nYFactor);
; 614  : 		}
; 615  : 		break;
; 616  : 	case MISSLE_MMK_RollBack:
; 617  : 		{
; 618  : 			if (!m_nTempParam1)	

	cmp	DWORD PTR [esi+412], ebp
	jne	SHORT $LN6@OnFly

; 619  : 			{
; 620  : 				if (m_nTempParam2 <= m_nCurrentLife)

	mov	edx, DWORD PTR [esi+416]
	cmp	edx, DWORD PTR [esi+204]
	jg	SHORT $LN6@OnFly

; 621  : 				{
; 622  : 					m_nXFactor = -m_nXFactor;

	mov	eax, DWORD PTR [esi+312]

; 623  : 					m_nYFactor = -m_nYFactor;

	mov	ecx, DWORD PTR [esi+316]
	neg	eax
	neg	ecx

; 624  : 					m_nTempParam1 = 1;
; 625  : 					m_nDir = m_nDir - MaxMissleDir / 2;

	add	DWORD PTR [esi+424], -32		; ffffffe0H
	mov	DWORD PTR [esi+312], eax
	mov	eax, DWORD PTR [esi+424]
	mov	DWORD PTR [esi+316], ecx
	mov	DWORD PTR [esi+412], 1

; 626  : 					if (m_nDir < 0) m_nDir += MaxMissleDir;

	jns	SHORT $LN6@OnFly
	add	eax, 64					; 00000040H
	mov	DWORD PTR [esi+424], eax
$LN6@OnFly:

; 768  : 		
; 769  : 	case	MISSLE_MMK_Motion:							//	玩家动作类
; 770  : 		{
; 771  : 			
; 772  : 		}break;
; 773  : 		
; 774  : 	case MISSLE_MMK_SingleLine:						//	必中的单一直线飞行魔法
; 775  : 		{
; 776  : 			//单一必中类子弹，类式于传奇以及其它的同类网络游戏中的基本直线魔法			
; 777  : #ifdef _SERVER
; 778  : 			
; 779  : #else
; 780  : 			int x = m_nXOffset;
; 781  : 			int y = m_nYOffset;
; 782  : 			int dx = (m_nSpeed * m_nXFactor);

	mov	eax, DWORD PTR [esi+96]
	mov	edi, DWORD PTR [esi+312]

; 783  : 			int dy = (m_nSpeed * m_nYFactor);

	mov	ebx, DWORD PTR [esi+316]
	imul	edi, eax
	imul	ebx, eax
$LN52@OnFly:

; 784  : 			nDOffsetX	=  dx;//* m_nCurrentLife;
; 785  : 			nDOffsetY	=  dy;//* m_nCurrentLife;
; 786  : 			
; 787  : #endif
; 788  : 		}
; 789  : 		break;
; 790  : 	default:
; 791  : 		_ASSERT(0);
; 792  : 		
; 793  : 	}
; 794  : 	
; 795  : 	//
; 796  : 	if (CheckBeyondRegion(nDOffsetX, nDOffsetY))

	push	ebx
	push	edi
	mov	ecx, esi
	call	?CheckBeyondRegion@KMissle@@AAEHHH@Z	; KMissle::CheckBeyondRegion
	test	eax, eax
	pop	edi
	pop	ebx

; 797  : 	{
; 798  : 		if (CheckCollision() == -1) 

	mov	ecx, esi
	je	$LN4@OnFly
	call	?CheckCollision@KMissle@@AAEHXZ		; KMissle::CheckCollision
	cmp	eax, -1
	jne	$LN1@OnFly

; 799  : 		{
; 800  : 			if (m_bAutoExplode)

	cmp	DWORD PTR [esi+112], ebp
	je	SHORT $LN2@OnFly

; 801  : 			{
; 802  : 				ProcessCollision();//处理碰撞

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision
$LN2@OnFly:

; 803  : 			}
; 804  : #ifndef _SERVER 
; 805  : 			int nSrcX4 = 0 ;
; 806  : 			int nSrcY4 = 0 ;
; 807  : 			SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX4, &nSrcY4);

	mov	ecx, DWORD PTR [esi+232]
	lea	edx, DWORD PTR _nSrcY4$97901[esp+24]
	push	edx
	mov	edx, DWORD PTR [esi+228]
	lea	eax, DWORD PTR _nSrcX4$97900[esp+28]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR _nSrcX4$97900[esp+52], ebp
	mov	DWORD PTR _nSrcY4$97901[esp+52], ebp
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 808  : 			CreateSpecialEffect(MS_DoVanish, nSrcX4, nSrcY4, m_nCurrentMapZ);

	mov	eax, DWORD PTR [esi+224]
	mov	ecx, DWORD PTR _nSrcY4$97901[esp+24]
	mov	edx, DWORD PTR _nSrcX4$97900[esp+24]
	push	ebp
	push	eax
	push	ecx
	push	edx

; 809  : #endif
; 810  : 			DoVanish();
; 811  : 			return;

	jmp	$LN60@OnFly
$LN29@OnFly:

; 627  : 				}
; 628  : 			}
; 629  : 
; 630  : 			nDOffsetX = (m_nSpeed * m_nXFactor);
; 631  : 			nDOffsetY = (m_nSpeed * m_nYFactor);
; 632  : 		}break;
; 633  : 		//按照设计方案，随机飞行无法达到客服两端的同步
; 634  : 	case	MISSLE_MMK_Random:							//	随机飞行（暗黑二女巫的Charged Bolt）
; 635  : 		{
; 636  : 			
; 637  : 		}break;
; 638  : 		//参数一表示顺时针还是逆时针转动
; 639  : 		//参数二表示固定原心还是围饶发动者
; 640  : 		//dx = SinA * R
; 641  : 		//dy = Ctg(90-A/2).R = SinA*SinA / (1 + CosA) * R
; 642  : 	case	MISSLE_MMK_Circle:							//	环行飞行（围绕在身边，暗黑二刺客的集气）
; 643  : 		{
; 644  : 			int nPreAngle = m_nAngle - 1;

	mov	eax, DWORD PTR [esi+428]
	lea	ebx, DWORD PTR [eax-1]

; 645  : 			if (nPreAngle < 0) nPreAngle = MaxMissleDir - 1;

	cmp	ebx, ebp
	jge	SHORT $LN56@OnFly
	mov	ebx, 63					; 0000003fH
$LN56@OnFly:

; 646  : 			m_nDir = m_nAngle + (MaxMissleDir / 4);

	lea	ecx, DWORD PTR [eax+16]

; 647  : 			if (m_nDir >= MaxMissleDir) m_nDir = m_nDir - MaxMissleDir;

	cmp	ecx, 64					; 00000040H
	mov	DWORD PTR [esi+424], ecx
	jl	SHORT $LN27@OnFly
	add	ecx, -64				; ffffffc0H
	mov	DWORD PTR [esi+424], ecx
$LN27@OnFly:

; 648  : 			int dx = (m_nSpeed + 50)  * (g_DirCos(m_nAngle,MaxMissleDir) - g_DirCos(nPreAngle,MaxMissleDir)) ;

	push	64					; 00000040H
	push	eax
	call	?g_DirCos@@YAHHH@Z			; g_DirCos
	push	64					; 00000040H
	push	ebx
	mov	edi, eax
	call	?g_DirCos@@YAHHH@Z			; g_DirCos
	mov	edx, DWORD PTR [esi+96]
	sub	edi, eax
	add	edx, 50					; 00000032H

; 649  : 			int dy = (m_nSpeed + 50)  * (g_DirSin(m_nAngle,MaxMissleDir) - g_DirSin(nPreAngle, MaxMissleDir)) ; 

	push	64					; 00000040H
	imul	edi, edx
	push	ebx
	call	?g_DirSin@@YAHHH@Z			; g_DirSin
	mov	ecx, DWORD PTR [esi+428]
	push	64					; 00000040H
	push	ecx
	mov	DWORD PTR tv904[esp+64], eax
	call	?g_DirSin@@YAHHH@Z			; g_DirSin
	mov	edx, DWORD PTR [esi+96]
	mov	ebx, eax
	mov	eax, DWORD PTR tv904[esp+64]
	sub	ebx, eax
	add	edx, 50					; 00000032H
	add	esp, 32					; 00000020H
	imul	ebx, edx

; 650  : 			
; 651  : 			if (m_nParam2) //原地转

	cmp	DWORD PTR [esi+396], ebp

; 652  : 			{
; 653  : 				nDOffsetX = dx;
; 654  : 				nDOffsetY = dy;
; 655  : 			}
; 656  : 			else			// 围绕着发送者转

	jne	$LN25@OnFly

; 657  : 			{
; 658  : 				int nOldRegion = m_nRegionId;
; 659  : 				CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	eax, DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+364]
	mov	edx, DWORD PTR [esi+216]
	push	2
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ebp, ecx
	imul	eax, 220				; 000000dcH
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	push	edx
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 660  : 				m_nRegionId		= Npc[m_nLauncher].m_RegionIndex;

	mov	eax, DWORD PTR [esi+332]
	imul	eax, 30432				; 000076e0H
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2384]
	mov	DWORD PTR [esi+364], ecx

; 661  : 				m_nCurrentMapX	= Npc[m_nLauncher].m_MapX;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756]
	mov	DWORD PTR [esi+216], edx

; 662  : 				m_nCurrentMapY	= Npc[m_nLauncher].m_MapY;

	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760]
	mov	DWORD PTR [esi+220], ecx

; 663  : 				m_nXOffset		= Npc[m_nLauncher].m_OffX;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2768]
	mov	DWORD PTR [esi+228], edx

; 664  : 				m_nYOffset		= Npc[m_nLauncher].m_OffY;

	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2772]

; 665  : 				CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [esi+216]
	push	2
	push	ecx
	mov	ecx, DWORD PTR [esi+364]
	mov	DWORD PTR [esi+232], eax
	imul	ecx, 208				; 000000d0H
	mov	eax, DWORD PTR [esi+360]
	imul	eax, 220				; 000000dcH
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	push	edx
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 666  : 				
; 667  : 				if (nOldRegion != m_nRegionId)

	mov	eax, DWORD PTR [esi+364]
	cmp	ebp, eax
	je	SHORT $LN24@OnFly

; 668  : 				{
; 669  : 					SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	ecx, DWORD PTR [esi+356]
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	push	eax
	push	ebp
	push	4002					; 00000fa2H
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A+172
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$LN24@OnFly:

; 670  : 				}  
; 671  : 				nDOffsetX = dx;
; 672  : 				nDOffsetY = dy;

	xor	ebp, ebp
$LN25@OnFly:

; 673  : 			}
; 674  : 			
; 675  : 			//顺时针还是逆时针
; 676  : 			if (m_nParam1)

	cmp	DWORD PTR [esi+392], ebp
	je	$LN13@OnFly

; 677  : 			{
; 678  : 				m_nAngle ++;

	add	DWORD PTR [esi+428], 1

; 679  : 				if (m_nAngle >= MaxMissleDir)

	cmp	DWORD PTR [esi+428], 64			; 00000040H
	jl	$LN52@OnFly

; 680  : 					m_nAngle = 0;

	mov	DWORD PTR [esi+428], ebp

; 681  : 			}
; 682  : 			else

	jmp	$LN52@OnFly
$LN19@OnFly:

; 683  : 			{
; 684  : 				m_nAngle --;
; 685  : 				if (m_nAngle < 0 )
; 686  : 					m_nAngle = MaxMissleDir - 1;
; 687  : 			}
; 688  : 			
; 689  : 		}
; 690  : 		break;
; 691  : 		
; 692  : 		//参数一表示顺时针还是逆时针转动
; 693  : 		//参数二表示固定原心还是围饶发动者
; 694  : 	case	MISSLE_MMK_Helix:							//	阿基米德螺旋线（暗黑二游侠的Bless Hammer）
; 695  : 		{
; 696  : 			int nPreAngle = m_nAngle - 1;

	mov	eax, DWORD PTR [esi+428]
	lea	ebx, DWORD PTR [eax-1]

; 697  : 			if (nPreAngle < 0) 

	cmp	ebx, ebp
	jge	SHORT $LN57@OnFly

; 698  : 			{
; 699  : 				nPreAngle = MaxMissleDir -1;

	mov	ebx, 63					; 0000003fH
$LN57@OnFly:

; 700  : 			}
; 701  : 			m_nDir = m_nAngle + (MaxMissleDir / 4);

	lea	ecx, DWORD PTR [eax+16]

; 702  : 			if (m_nDir >= MaxMissleDir) m_nDir = m_nDir - MaxMissleDir;

	cmp	ecx, 64					; 00000040H
	mov	DWORD PTR [esi+424], ecx
	jl	SHORT $LN17@OnFly
	add	ecx, -64				; ffffffc0H
	mov	DWORD PTR [esi+424], ecx
$LN17@OnFly:

; 703  : 			
; 704  : 			int dx = (m_nSpeed + m_nCurrentLife + 50)  * (g_DirCos(m_nAngle,MaxMissleDir) - g_DirCos(nPreAngle, MaxMissleDir)) ;

	push	64					; 00000040H
	push	eax
	call	?g_DirCos@@YAHHH@Z			; g_DirCos
	push	64					; 00000040H
	push	ebx
	mov	edi, eax
	call	?g_DirCos@@YAHHH@Z			; g_DirCos
	mov	edx, DWORD PTR [esi+96]
	sub	edi, eax
	mov	eax, DWORD PTR [esi+204]
	lea	ecx, DWORD PTR [edx+eax+50]

; 705  : 			int dy = (m_nSpeed + m_nCurrentLife + 50)  * (g_DirSin(m_nAngle,MaxMissleDir) - g_DirSin(nPreAngle,MaxMissleDir)) ; 

	push	64					; 00000040H
	imul	edi, ecx
	push	ebx
	call	?g_DirSin@@YAHHH@Z			; g_DirSin
	mov	edx, DWORD PTR [esi+428]
	push	64					; 00000040H
	push	edx
	mov	DWORD PTR tv902[esp+64], eax
	call	?g_DirSin@@YAHHH@Z			; g_DirSin
	mov	ecx, DWORD PTR [esi+204]
	mov	ebx, eax
	mov	eax, DWORD PTR tv902[esp+64]
	sub	ebx, eax
	mov	eax, DWORD PTR [esi+96]
	lea	edx, DWORD PTR [eax+ecx+50]
	add	esp, 32					; 00000020H
	imul	ebx, edx

; 706  : 			
; 707  : 			if (m_nParam2) //原地转

	cmp	DWORD PTR [esi+396], ebp

; 708  : 			{
; 709  : 				nDOffsetX = dx;
; 710  : 				nDOffsetY = dy;
; 711  : 			}
; 712  : 			else			// 围绕着发送者转

	jne	$LN15@OnFly

; 713  : 			{
; 714  : 				int nOldRegion = m_nRegionId;
; 715  : 				CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	eax, DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+364]
	mov	edx, DWORD PTR [esi+216]
	push	2
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ebp, ecx
	imul	eax, 220				; 000000dcH
	imul	ecx, 208				; 000000d0H
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	push	edx
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 716  : 				m_nRegionId		= Npc[m_nLauncher].m_RegionIndex;

	mov	eax, DWORD PTR [esi+332]
	imul	eax, 30432				; 000076e0H
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2384]
	mov	DWORD PTR [esi+364], ecx

; 717  : 				m_nCurrentMapX	= Npc[m_nLauncher].m_MapX;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756]
	mov	DWORD PTR [esi+216], edx

; 718  : 				m_nCurrentMapY	= Npc[m_nLauncher].m_MapY;

	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760]
	mov	DWORD PTR [esi+220], ecx

; 719  : 				m_nXOffset		= Npc[m_nLauncher].m_OffX;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2768]
	mov	DWORD PTR [esi+228], edx

; 720  : 				m_nYOffset		= Npc[m_nLauncher].m_OffY;

	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2772]

; 721  : 				CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [esi+216]
	push	2
	push	ecx
	mov	ecx, DWORD PTR [esi+364]
	mov	DWORD PTR [esi+232], eax
	imul	ecx, 208				; 000000d0H
	mov	eax, DWORD PTR [esi+360]
	imul	eax, 220				; 000000dcH
	add	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+8]
	push	edx
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 722  : 				
; 723  : 				if (nOldRegion != m_nRegionId)

	mov	eax, DWORD PTR [esi+364]
	cmp	ebp, eax
	je	SHORT $LN14@OnFly

; 724  : 				{
; 725  : 					SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	ecx, DWORD PTR [esi+356]
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	push	eax
	push	ebp
	push	4002					; 00000fa2H
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A+172
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$LN14@OnFly:

; 726  : 				}  
; 727  : 				nDOffsetX = dx;
; 728  : 				nDOffsetY = dy;

	xor	ebp, ebp
$LN15@OnFly:

; 729  : 			}
; 730  : 			
; 731  : 			if (m_nParam1)

	cmp	DWORD PTR [esi+392], ebp
	je	SHORT $LN13@OnFly

; 732  : 			{
; 733  : 				m_nAngle ++;

	add	DWORD PTR [esi+428], 1

; 734  : 				if (m_nAngle >= MaxMissleDir)

	cmp	DWORD PTR [esi+428], 64			; 00000040H
	jl	$LN52@OnFly

; 735  : 					m_nAngle = 0;

	mov	DWORD PTR [esi+428], ebp

; 736  : 			}
; 737  : 			else

	jmp	$LN52@OnFly
$LN13@OnFly:

; 738  : 			{
; 739  : 				m_nAngle --;

	add	DWORD PTR [esi+428], -1

; 740  : 				if (m_nAngle < 0 )

	jns	$LN52@OnFly

; 741  : 					m_nAngle = MaxMissleDir - 1;

	mov	DWORD PTR [esi+428], 63			; 0000003fH

; 742  : 			}
; 743  : 		}
; 744  : 		break; 

	jmp	$LN52@OnFly
$LN9@OnFly:

; 745  : 	case	MISSLE_MMK_Follow:							//	跟踪目标飞行
; 746  : 		{
; 747  : 			int nDistance = 0;
; 748  : 			int nSrcMpsX = 0;
; 749  : 			int nSrcMpsY = 0;
; 750  : 			int nDesMpsX = 0;
; 751  : 			int nDesMpsY = 0;
; 752  : 			
; 753  : 			SubWorld[m_nSubWorldId].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nXOffset, m_nYOffset, &nSrcMpsX, &nSrcMpsY);

	mov	ecx, DWORD PTR [esi+232]
	lea	edx, DWORD PTR _nSrcMpsY$97881[esp+32]
	push	edx
	mov	edx, DWORD PTR [esi+228]
	lea	eax, DWORD PTR _nSrcMpsX$97880[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	push	edx
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR _nSrcMpsX$97880[esp+60], ebp
	mov	DWORD PTR _nSrcMpsY$97881[esp+60], ebp
	mov	DWORD PTR _nDesMpsX$97882[esp+60], ebp
	mov	DWORD PTR _nDesMpsY$97883[esp+60], ebp
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 754  : 			SubWorld[m_nSubWorldId].Map2Mps(Npc[m_nFollowNpcIdx].m_RegionIndex, Npc[m_nFollowNpcIdx].m_MapX, Npc[m_nFollowNpcIdx].m_MapY, Npc[m_nFollowNpcIdx].m_OffX, Npc[m_nFollowNpcIdx].m_OffY, &nDesMpsX, &nDesMpsY);

	mov	eax, DWORD PTR [esi+324]
	imul	eax, 30432				; 000076e0H
	lea	ecx, DWORD PTR _nDesMpsY$97883[esp+32]
	push	ecx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2772]
	lea	edx, DWORD PTR _nDesMpsX$97882[esp+36]
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2768]
	push	ecx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2760]
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2756]
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2384]
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	push	edx
	push	eax
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 755  : 			nDistance = SubWorld[m_nSubWorldId].GetDistance(nSrcMpsX, nSrcMpsY, nDesMpsX, nDesMpsY);

	mov	ecx, DWORD PTR _nDesMpsY$97883[esp+32]
	mov	edx, DWORD PTR _nDesMpsX$97882[esp+32]
	mov	eax, DWORD PTR _nSrcMpsY$97881[esp+32]
	push	ecx
	mov	ecx, DWORD PTR _nSrcMpsX$97880[esp+36]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	imul	ecx, 220				; 000000dcH
	add	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?GetDistance@KSubWorld@@QAEHHHHH@Z	; KSubWorld::GetDistance
	mov	ecx, eax

; 756  : 			
; 757  : 			if (nDistance != 0)

	cmp	ecx, ebp
	je	$LN52@OnFly

; 758  : 			{
; 759  : 				int nXFactor = ((nDesMpsX - nSrcMpsY ) << 10) / nDistance;
; 760  : 				int nYFactor = ((nDesMpsY - nSrcMpsY ) << 10) / nDistance;
; 761  : 				int dx		 = nXFactor * m_nSpeed;
; 762  : 				int dy		 = nYFactor * m_nSpeed;	
; 763  : 				nDOffsetX	 = dx;

	mov	ebx, DWORD PTR _nSrcMpsY$97881[esp+32]
	mov	eax, DWORD PTR _nDesMpsX$97882[esp+32]
	sub	eax, ebx
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ecx
	mov	ebp, DWORD PTR [esi+96]
	mov	edi, eax

; 764  : 				nDOffsetY	 = dy;

	mov	eax, DWORD PTR _nDesMpsY$97883[esp+32]
	imul	edi, ebp
	sub	eax, ebx
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ecx
	mov	ebx, eax
	imul	ebx, ebp

; 765  : 			}
; 766  : 			
; 767  : 		}break;

	xor	ebp, ebp
	jmp	$LN52@OnFly
$LN4@OnFly:
	pop	esi
	pop	ebp

; 817  : 	}
; 818  : }

	add	esp, 16					; 00000010H

; 812  : 		}
; 813  : 	}
; 814  : 	else//如果子弹飞行过程中进入了一个无效的Region则子弹自动消亡
; 815  : 	{
; 816  : 		DoVanish();

	jmp	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
	npad	2
$LN61@OnFly:

; 817  : 	}
; 818  : }

	DD	$LN6@OnFly
	DD	$LN29@OnFly
	DD	$LN19@OnFly
	DD	$LN9@OnFly
	DD	$LN34@OnFly
	DD	$LN52@OnFly
$LN50@OnFly:
	DB	0
	DB	5
	DB	1
	DB	2
	DB	3
	DB	5
	DB	0
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?OnFly@KMissle@@AAEXXZ ENDP				; KMissle::OnFly
_TEXT	ENDS
PUBLIC	?Activate@KMissle@@QAEHXZ			; KMissle::Activate
EXTRN	?MoveObject@KScenePlaceC@@QAEIIHHHHAAIH@Z:PROC	; KScenePlaceC::MoveObject
EXTRN	?FlyEvent@KSkill@@ABEXPAVKMissle@@@Z:PROC	; KSkill::FlyEvent
; Function compile flags: /Ogtpy
;	COMDAT ?Activate@KMissle@@QAEHXZ
_TEXT	SEGMENT
_nSrcX$97768 = -8					; size = 4
_nSrcY2$97750 = -8					; size = 4
_nSrcY$97769 = -4					; size = 4
_nSrcX2$97749 = -4					; size = 4
?Activate@KMissle@@QAEHXZ PROC				; KMissle::Activate, COMDAT
; _this$ = ecx

; 327  : {	

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 328  : 	if (m_nMissleId <= 0 || m_nRegionId < 0)

	cmp	DWORD PTR [esi+356], 0
	jle	$LN25@Activate
	cmp	DWORD PTR [esi+364], 0
	jl	$LN25@Activate

; 331  : 	}
; 332  : 	
; 333  : 	_ASSERT(m_nLauncher > 0);
; 334  : 	if (m_nLauncher <= 0)

	mov	eax, DWORD PTR [esi+332]
	test	eax, eax

; 335  : 		return 0;

	jle	$LN25@Activate

; 336  : 	
; 337  : 	//子弹的主人已经离开，So 子弹消亡
; 338  : 	if (!Npc[m_nLauncher].IsMatch(m_dwLauncherId) || Npc[m_nLauncher].m_SubWorldIndex != m_nSubWorldId || Npc[m_nLauncher].m_RegionIndex < 0)

	mov	ecx, DWORD PTR [esi+336]
	imul	eax, 30432				; 000076e0H
	cmp	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax]
	jne	$LN22@Activate
	mov	ecx, DWORD PTR [esi+360]
	cmp	DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2380], ecx
	jne	$LN22@Activate
	cmp	DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2384], 0
	jl	$LN22@Activate

; 341  : 		return 0;	
; 342  : 	}
; 343  : 	
; 344  : 	//跟踪的目标人物已经不在该地图上时，自动清空
; 345  : 	if (m_nFollowNpcIdx > 0)

	mov	eax, DWORD PTR [esi+324]
	test	eax, eax
	jle	SHORT $LN20@Activate

; 346  : 	{
; 347  : 		if (!Npc[m_nFollowNpcIdx].IsMatch(m_dwFollowNpcID) || Npc[m_nFollowNpcIdx].m_SubWorldIndex != m_nSubWorldId)

	mov	edx, DWORD PTR [esi+328]
	imul	eax, 30432				; 000076e0H
	cmp	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax]
	jne	SHORT $LN19@Activate
	cmp	DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2380], ecx
	je	SHORT $LN20@Activate
$LN19@Activate:

; 348  : 		{
; 349  : 			m_nFollowNpcIdx = 0;

	mov	DWORD PTR [esi+324], 0
$LN20@Activate:

; 350  : 		}
; 351  : 	}
; 352  : 	
; 353  : 	eMissleStatus eLastStatus = m_eMissleStatus;
; 354  : 	
; 355  : 	//如果当前状态是子弹生命正常结束正准备消亡状态时，而不是消亡中或者已碰撞中
; 356  : 	if (
; 357  : 		m_nCurrentLife >= m_nLifeTime 
; 358  : 		&& m_eMissleStatus != MS_DoVanish 
; 359  : 		&& m_eMissleStatus != MS_DoCollision
; 360  : 		)

	mov	eax, DWORD PTR [esi+204]
	cmp	eax, DWORD PTR [esi+92]
	jl	SHORT $LN18@Activate
	mov	eax, DWORD PTR [esi+352]
	cmp	eax, 2
	je	SHORT $LN18@Activate
	cmp	eax, 3
	je	SHORT $LN18@Activate

; 361  : 	{
; 362  : 		if (m_bAutoExplode)

	cmp	DWORD PTR [esi+112], 0
	je	SHORT $LN17@Activate

; 363  : 		{
; 364  : 			ProcessCollision();//处理碰撞

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision
$LN17@Activate:

; 365  : 		}
; 366  : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$LN18@Activate:

; 367  : #ifdef _SERVER
; 368  : 		m_nCurrentLife ++;
; 369  : 		return 1;
; 370  : #endif
; 371  : 	}
; 372  : 	
; 373  : 	if (m_nCurrentLife == m_nStartLifeTime && m_eMissleStatus != MS_DoVanish)	

	mov	ecx, DWORD PTR [esi+204]
	cmp	ecx, DWORD PTR [esi+208]
	jne	$LN14@Activate
	cmp	DWORD PTR [esi+352], 2
	je	SHORT $LN14@Activate

; 374  : 	{
; 375  : 		if (PrePareFly())

	mov	ecx, esi
	call	?PrePareFly@KMissle@@AAEHXZ		; KMissle::PrePareFly
	test	eax, eax
	je	SHORT $LN15@Activate

; 376  : 		{
; 377  : #ifndef _SERVER
; 378  : 			int nSrcX2 = 0 ;
; 379  : 			int nSrcY2 = 0 ;
; 380  : 			SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX2, &nSrcY2);

	mov	ecx, DWORD PTR [esi+232]
	lea	edx, DWORD PTR _nSrcY2$97750[esp+12]
	push	edx
	mov	edx, DWORD PTR [esi+228]
	lea	eax, DWORD PTR _nSrcX2$97749[esp+16]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	mov	DWORD PTR _nSrcX2$97749[esp+40], 0
	mov	DWORD PTR _nSrcY2$97750[esp+40], 0
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 381  : 			m_MissleRes.PlaySound(MS_DoFly, nSrcX2, nSrcY2, 0);

	mov	eax, DWORD PTR _nSrcY2$97750[esp+12]
	mov	ecx, DWORD PTR _nSrcX2$97749[esp+12]
	push	0
	push	eax
	push	ecx
	push	1
	lea	ecx, DWORD PTR [esi+464]
	call	?PlaySoundA@KMissleRes@@QAEXHHHH@Z	; KMissleRes::PlaySoundA

; 382  : 			//CreateSpecialEffect(MS_DoFly, nSrcX2, nSrcY2, m_nCurrentMapZ);
; 383  : #endif
; 384  : 			
; 385  : 			DoFly();

	mov	ecx, esi
	call	?DoFly@KMissle@@AAEXXZ			; KMissle::DoFly

; 386  : 		}
; 387  : 		else

	jmp	SHORT $LN14@Activate
$LN15@Activate:

; 388  : 			DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$LN14@Activate:

; 389  : 	}
; 390  : 	
; 391  : 	switch(m_eMissleStatus)

	mov	eax, DWORD PTR [esi+352]
	cmp	eax, 3
	ja	SHORT $LN4@Activate
	jmp	DWORD PTR $LN34@Activate[eax*4]
$LN10@Activate:

; 392  : 	{
; 393  : 	case MS_DoWait:
; 394  : 		{
; 395  : 			OnWait();
; 396  : 		}
; 397  : 		break;
; 398  : 	case MS_DoFly:
; 399  : 		{
; 400  : 			OnFly();

	mov	ecx, esi
	call	?OnFly@KMissle@@AAEXXZ			; KMissle::OnFly

; 401  : 			if (m_bFlyEvent)

	cmp	DWORD PTR [esi+172], 0
	je	SHORT $LN4@Activate

; 402  : 			{
; 403  : 				if ( (m_nCurrentLife - m_nStartLifeTime) % m_nFlyEventTime == 0 )

	mov	eax, DWORD PTR [esi+204]
	sub	eax, DWORD PTR [esi+208]
	cdq
	idiv	DWORD PTR [esi+176]
	test	edx, edx
	jne	SHORT $LN4@Activate

; 404  : 				{
; 405  : 					_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 406  : 					if (m_nLevel  <= 0 ) return 0;

	mov	eax, DWORD PTR [esi+320]
	test	eax, eax
	jle	$LN25@Activate

; 407  : 					KSkill * pOrdinSkill = (KSkill *) g_SkillManager.GetSkill(m_nSkillId , m_nLevel);

	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	edx
	mov	ecx, OFFSET ?g_SkillManager@@3VKSkillManager@@A ; g_SkillManager
	call	?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z ; KSkillManager::GetSkill

; 408  : 					if (pOrdinSkill)

	test	eax, eax
	je	SHORT $LN4@Activate

; 409  : 					{
; 410  : 						pOrdinSkill->FlyEvent(this);

	push	esi
	mov	ecx, eax
	call	?FlyEvent@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::FlyEvent
$LN4@Activate:

; 411  : 					}
; 412  : 				}
; 413  : 			}
; 414  : 		}
; 415  : 		break;
; 416  : 	case MS_DoCollision:
; 417  : 		{
; 418  : 			OnCollision();
; 419  : 		}
; 420  : 		break;
; 421  : 	case MS_DoVanish:
; 422  : 		{
; 423  : 			OnVanish();
; 424  : 		}
; 425  : 		break;
; 426  : 	}
; 427  : 	
; 428  : #ifndef _SERVER
; 429  : 	//子弹未消亡掉
; 430  : 	if (m_nMissleId > 0)

	cmp	DWORD PTR [esi+356], 0
	jle	$LN1@Activate

; 431  : 	{
; 432  : 		int nSrcX;
; 433  : 		int nSrcY;
; 434  : 		
; 435  : 		SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY$97769[esp+12]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	lea	ecx, DWORD PTR _nSrcX$97768[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET ?SubWorld@@3PAVKSubWorld@@A	; SubWorld
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 436  : 		if (m_usLightRadius && m_eMissleStatus != MS_DoWait)

	cmp	WORD PTR [esi+460], 0
	je	SHORT $LN2@Activate
	cmp	DWORD PTR [esi+352], 0
	je	SHORT $LN2@Activate

; 437  : 			g_ScenePlace.MoveObject(CGOG_MISSLE, m_nMissleId, nSrcX, nSrcY, m_nCurrentMapZ, m_SceneID, IPOT_RL_OBJECT | IPOT_RL_LIGHT_PROP );

	mov	edx, DWORD PTR [esi+224]
	mov	eax, DWORD PTR _nSrcY$97769[esp+12]
	push	10					; 0000000aH
	lea	ecx, DWORD PTR [esi+2932]
	push	ecx
	mov	ecx, DWORD PTR _nSrcX$97768[esp+20]
	push	edx
	mov	edx, DWORD PTR [esi+356]
	push	eax
	push	ecx
	push	edx

; 438  : 		else

	jmp	SHORT $LN33@Activate
$LN2@Activate:

; 439  : 			g_ScenePlace.MoveObject(CGOG_MISSLE, m_nMissleId, nSrcX, nSrcY, m_nCurrentMapZ, m_SceneID, IPOT_RL_OBJECT);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$97769[esp+12]
	push	2
	lea	eax, DWORD PTR [esi+2932]
	push	eax
	mov	eax, DWORD PTR _nSrcX$97768[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+356]
	push	edx
	push	eax
	push	ecx
$LN33@Activate:
	push	9
	mov	ecx, OFFSET ?g_ScenePlace@@3VKScenePlaceC@@A ; g_ScenePlace
	call	?MoveObject@KScenePlaceC@@QAEIIHHHHAAIH@Z ; KScenePlaceC::MoveObject
$LN1@Activate:

; 440  : 	}
; 441  : 	
; 442  : #endif
; 443  : 	m_nCurrentLife ++;

	add	DWORD PTR [esi+204], 1

; 444  : 	return 1;

	mov	eax, 1
	pop	esi

; 445  : }

	add	esp, 8
	ret	0
$LN22@Activate:

; 339  : 	{
; 340  : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$LN25@Activate:

; 329  : 	{
; 330  : 		return  0 ;

	xor	eax, eax
	pop	esi

; 445  : }

	add	esp, 8
	ret	0
	npad	2
$LN34@Activate:
	DD	$LN4@Activate
	DD	$LN10@Activate
	DD	$LN4@Activate
	DD	$LN4@Activate
?Activate@KMissle@@QAEHXZ ENDP				; KMissle::Activate
_TEXT	ENDS
EXTRN	_atexit:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??__Eg_MisslesLib@@YAXXZ
text$yc	SEGMENT
??__Eg_MisslesLib@@YAXXZ PROC				; `dynamic initializer for 'g_MisslesLib'', COMDAT

; 111  : KMissle g_MisslesLib[MAX_MISSLESTYLE];

	push	OFFSET ??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	OFFSET ??0KMissle@@QAE@XZ		; KMissle::KMissle
	push	200					; 000000c8H
	push	2936					; 00000b78H
	push	OFFSET ?g_MisslesLib@@3PAVKMissle@@A	; g_MisslesLib
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	push	OFFSET ??__Fg_MisslesLib@@YAXXZ		; `dynamic atexit destructor for 'g_MisslesLib''
	call	_atexit
	pop	ecx
	ret	0
??__Eg_MisslesLib@@YAXXZ ENDP				; `dynamic initializer for 'g_MisslesLib''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__EMissle@@YAXXZ
text$yc	SEGMENT
??__EMissle@@YAXXZ PROC					; `dynamic initializer for 'Missle'', COMDAT

; 132  : CORE_API KMissle Missle[MAX_MISSLE];

	push	OFFSET ??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	OFFSET ??0KMissle@@QAE@XZ		; KMissle::KMissle
	push	500					; 000001f4H
	push	2936					; 00000b78H
	push	OFFSET ?Missle@@3PAVKMissle@@A		; Missle
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	push	OFFSET ??__FMissle@@YAXXZ		; `dynamic atexit destructor for 'Missle''
	call	_atexit
	pop	ecx
	ret	0
??__EMissle@@YAXXZ ENDP					; `dynamic initializer for 'Missle''
text$yc	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??__Fg_MisslesLib@@YAXXZ
text$yd	SEGMENT
??__Fg_MisslesLib@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MisslesLib'', COMDAT
	push	OFFSET ??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	200					; 000000c8H
	push	2936					; 00000b78H
	push	OFFSET ?g_MisslesLib@@3PAVKMissle@@A	; g_MisslesLib
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
??__Fg_MisslesLib@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MisslesLib''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__FMissle@@YAXXZ
text$yd	SEGMENT
??__FMissle@@YAXXZ PROC					; `dynamic atexit destructor for 'Missle'', COMDAT
	push	OFFSET ??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	500					; 000001f4H
	push	2936					; 00000b78H
	push	OFFSET ?Missle@@3PAVKMissle@@A		; Missle
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
??__FMissle@@YAXXZ ENDP					; `dynamic atexit destructor for 'Missle''
text$yd	ENDS
PUBLIC	?Missle@@3PAVKMissle@@A				; Missle
PUBLIC	?g_MisslesLib@@3PAVKMissle@@A			; g_MisslesLib
_BSS	SEGMENT
?Missle@@3PAVKMissle@@A DB 0166660H DUP (?)		; Missle
?g_MisslesLib@@3PAVKMissle@@A DB 08f5c0H DUP (?)	; g_MisslesLib
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MisslesLib$initializer$ DD FLAT:??__Eg_MisslesLib@@YAXXZ
_Missle$initializer$ DD FLAT:??__EMissle@@YAXXZ
CRT$XCU	ENDS
END
